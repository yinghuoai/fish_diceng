Interrupt Vectors
    00000 940C 01FC JMP	__text_start|__start
    0001C 940C 10CE JMP	_timer1_ovf_isr
    00024 940C 0BBF JMP	_uart0_rx_isr
    0003A 940C 1074 JMP	_timer3_ovf_isr
    00042 940C 195A JMP	_twi_isr

Program Code (text area)
__text_start|__start:
    001FC EFCF      LDI	R28,0xFF
    001FD E1D0      LDI	R29,0x10
    001FE BFCD      OUT	0x3D,R28
    001FF BFDE      OUT	0x3E,R29
    00200 51C0      SUBI	R28,0x10
    00201 40D0      SBCI	R29,0
    00202 EA0A      LDI	R16,0xAA
    00203 8308      ST	Y,R16
    00204 2400      CLR	R0
    00205 E2E3      LDI	R30,0x23
    00206 E0F4      LDI	R31,4
    00207 E014      LDI	R17,4
    00208 33E4      CPI	R30,0x34
    00209 07F1      CPC	R31,R17
    0020A F011      BEQ	0x020D
    0020B 9201      ST	Z+,R0
    0020C CFFB      RJMP	0x0208
    0020D 8300      ST	Z,R16
    0020E EDE4      LDI	R30,0xD4
    0020F E0F0      LDI	R31,0
    00210 E0A0      LDI	R26,0
    00211 E0B1      LDI	R27,1
    00212 E013      LDI	R17,3
    00213 E000      LDI	R16,0
    00214 BF0B      OUT	0x3B,R16
    00215 3FE7      CPI	R30,0xF7
    00216 07F1      CPC	R31,R17
    00217 F021      BEQ	0x021C
    00218 95C8      LPM
    00219 9631      ADIW	R30,1
    0021A 920D      ST	X+,R0
    0021B CFF9      RJMP	0x0215
    0021C 940E 111B CALL	_main
_exit:
    0021E CFFF      RJMP	_exit
_delay:
  k                    --> Y,+0
  interval             --> Y,+4
    0021F 940E 1A35 CALL	push_arg4
    00221 9724      SBIW	R28,4
FILE: G:\wsg\SchoolTrain\FishRobot\机器鱼\机器鱼培训资料\机器鱼培训资料\机器鱼鱼体波程序\fish_0_100115\11fish.c
(0001) //ICC-AVR application builder : 2006-11-23 22:56:28
(0002) // Target : M128
(0003) // Crystal: 8.0000Mhz
(0004) /*  
(0005)    comunicating protocol with the radio controller:
(0006)    发送8位二进制数
(0007)    1表示接上
(0008)    0表示松开
(0009)    eg:   1111   X  X  X  X
(0010)                 前 后 左 右
(0011) */  
(0012) 
(0013) /*
(0014) *
(0015) *  手动模式和自动模式的切换：unsigned char is_uart=0;//若是想屏蔽掉开电运行的自动模式，置此标志位为1
(0016) *
(0017) *
(0018) *
(0019) */
(0020) #include <iom128v.h>
(0021) #include <macros.h>
(0022) #include "TWI_Master.h"
(0023) 
(0024) #define FLK 8 	   	  	 //晶振 crystal
(0025) #define PI 3.1416        //**圆周率
(0026) #define Joint_Num  3
(0027) 
(0028) #define SLA_W 0xA0
(0029) #define SLA_R 0xA1
(0030) 
(0031) ////////////////////////////----i2c地址--BEGIN----///////////////////////
(0032) //有些i2c一次可以写16个，而有些一次只能写8个，为了通用性，此处每次写入8个
(0033) //读不受限制
(0034) #define ADD_i 0x10//ID*1
(0035) #define ADD_f 0x20//频率*1
(0036) #define ADD_t 0x30//调直*3
(0037) #define ADD_s1 0x40//速度*16
(0038) #define ADD_s2 0x48
(0039) #define ADD_d 0x50//滞后角*3
(0040) #define ADD_1 0x60//幅度*48
(0041) #define ADD_2 0x68
(0042) #define ADD_3 0x70
(0043) #define ADD_4 0x78
(0044) #define ADD_5 0x80
(0045) #define ADD_6 0x88
(0046) #define ADD_10 0x90//转角偏移*24
(0047) #define ADD_20 0x98
(0048) #define ADD_30 0xa0
(0049) ////////////////////////////----i2c地址--END----///////////////////////
(0050) #define PWM_Period_ms 20	     //ms
(0051) #define PWM_Duty_Middle_us 1500  //us
(0052) #define PWM_Duty_LeftLimit_us 900  //us
(0053) #define PWM_Duty_RightLimit_us 2100  //us
(0054) 
(0055) #define D_MAX 60  //Dynamic_Offset_degree_origin[0]的最大值
(0056) #define D_Y_MAX 60  //Dynamic_Offset_degree_y[0]的最大值
(0057) 
(0058) #define A_MAX 20 //*0.85=Amplitude_degree_tem[0]的最大值
(0059) 
(0060) #define m_time 0x10 //模态变化中控制时间
(0061) #define y_time 0x2 //原始转弯模式中控制时间//每秒大概加2
(0062) 
(0063) 
(0064) int LeftLimit_value, RightLimit_value, MiddlePosition_value,PWM_Period_value;
(0065) unsigned char Speed=0;   
(0066) unsigned char Instant=0;
(0067) unsigned char redata;//串口数据
(0068) unsigned char redata_fan=0;//是速度或方向指令时，存储该指令
(0069) unsigned char id_fan=0;//由FISHID[0]和redata_fan组成的1个字节数，返回值
(0070) unsigned char redata_tem;//命令数据暂存
(0071) unsigned char redata_i2c;//i2c命令数据暂存
(0072) unsigned char baocun_i=0;
(0073) unsigned char t_dynamic=0;//转弯命令后，从原状态到新状态的过渡时间，收到命令后的0到Speed_dynamic/2时间段为过渡状态
(0074) unsigned char Speed_dynamic=0;//收到转弯命令时刻的Speed值
(0075) 
(0076) unsigned char n=0;
(0077) unsigned char m=0;//测试时循环发数据用
(0078) unsigned char s=0;//拆分数组子函数中使用
(0079) 
(0080) //////////////----需要写入i2c的数据--BEGIN----//////////////////
(0081) unsigned char FISHID[1]={0x01};//地址ADD_i
(0082) unsigned char FISHID_init[1]={0x01};
(0083) unsigned char FISHID_I2C[3]={0,0,0x01};
(0084) 
(0085) unsigned char freqs[1]={0};//地址ADD_f,freq[freqs[x]]
(0086) unsigned char freqs_init[1]={0};
(0087) unsigned char freqs_I2C[3]={0,0,0};
(0088) 
(0089) unsigned char Static_Offset_degree[3]={0,0,0};//地址ADD_t
(0090) unsigned char Static_Offset_degree_init[3]={0,0,0};
(0091) unsigned char degree_I2C[5]={0,0,0,0,0};
(0092) 
(0093) //Speed_tem[16]//地址ADD_s1,s2
(0094) unsigned char Speed_tem_init[16]={0,255,240,225,210,195,180,165,150,135,120,105,90,75,60,45};
(0095) unsigned char Speed_tem_I2C[18]={0};  
(0096) 
(0097) unsigned char Speed_tem_init1[8]={0};
(0098) unsigned char Speed_tem_init2[8]={0};
(0099) 
(0100) unsigned char Speed_tem_z[16]={0};//Dynamic_Offset_degree_origin[8][3]直接转成的1维数组
(0101) unsigned char Speed_tem_z1[8]={0};//0-7
(0102) unsigned char Speed_tem_z2[8]={0};//8-16
(0103) 
(0104) unsigned char Speed_tem_I2C1[10]={0};
(0105) unsigned char Speed_tem_I2C2[10]={0};
(0106) 
(0107) //Neighbouring_Offset_degree[3]//地址ADD_d
(0108) unsigned char Neighbouring_Offset_degree_init[3]={0,80,120};
(0109) unsigned char Neighbouring_Offset_degree_I2C[5]={0};
(0110) 
(0111) 
(0112) //Amplitude_degree_tem[16][3]//地址ADD_1,2,3,4,5,6
(0113) unsigned char Amplitude_degree_tem_init[48]=
(0114)               {
(0115) 			    0.1*A_MAX,0.1*A_MAX+10,0.1*A_MAX+15,//0 ，速度小摆幅小
(0116)                 0.15*A_MAX,0.15*A_MAX+10,0.15*A_MAX+15,//1
(0117)                 0.2*A_MAX,0.2*A_MAX+10,0.2*A_MAX+15,//
(0118)                 0.25*A_MAX,0.25*A_MAX+10,0.25*A_MAX+15,//3
(0119)                 0.3*A_MAX,0.3*A_MAX+10,0.3*A_MAX+15,//
(0120)                 0.35*A_MAX,0.35*A_MAX+10,0.35*A_MAX+15,//5
(0121)                 0.4*A_MAX,0.4*A_MAX+10,0.4*A_MAX+15,//
(0122)                 0.45*A_MAX,0.45*A_MAX+10,0.45*A_MAX+15,//7
(0123)                 0.5*A_MAX,0.5*A_MAX+10,0.5*A_MAX+15,//8******
(0124)                 0.55*A_MAX,0.55*A_MAX+10,0.55*A_MAX+15,//9
(0125)                 0.6*A_MAX,0.6*A_MAX+10,0.6*A_MAX+15,//
(0126)                 0.65*A_MAX,0.65*A_MAX+10,0.65*A_MAX+15,//11
(0127)                 0.7*A_MAX,0.7*A_MAX+10,0.7*A_MAX+15,//
(0128)                 0.75*A_MAX,0.75*A_MAX+10,0.75*A_MAX+15,//13
(0129)                 0.8*A_MAX,0.8*A_MAX+10,0.8*A_MAX+15,//
(0130)                 0.85*A_MAX,0.85*A_MAX+10,0.85*A_MAX+15//15，速度大摆幅大
(0131) 			  };
(0132) 			  //unsigned char Amplitude_degree_tem_I2C[50]={0};
(0133) unsigned char Amplitude_degree_tem_init1[8]={0};
(0134) unsigned char Amplitude_degree_tem_init2[8]={0};
(0135) unsigned char Amplitude_degree_tem_init3[8]={0};
(0136) unsigned char Amplitude_degree_tem_init4[8]={0};
(0137) unsigned char Amplitude_degree_tem_init5[8]={0};
(0138) unsigned char Amplitude_degree_tem_init6[8]={0};
(0139) unsigned char Amplitude_degree_tem_z[48]={0};//Amplitude_degree_tem[16][3]直接转成的1维数组
(0140) unsigned char Amplitude_degree_tem_z1[8]={0};//0-11
(0141) unsigned char Amplitude_degree_tem_z2[8]={0};//12-23
(0142) unsigned char Amplitude_degree_tem_z3[8]={0};//24-35
(0143) unsigned char Amplitude_degree_tem_z4[8]={0};//36-47
(0144) unsigned char Amplitude_degree_tem_z5[8]={0};//36-47
(0145) unsigned char Amplitude_degree_tem_z6[8]={0};//36-47
(0146) unsigned char Amplitude_degree_tem_I2C1[10]={0};
(0147) unsigned char Amplitude_degree_tem_I2C2[10]={0};
(0148) unsigned char Amplitude_degree_tem_I2C3[10]={0};
(0149) unsigned char Amplitude_degree_tem_I2C4[10]={0};
(0150) unsigned char Amplitude_degree_tem_I2C5[10]={0};
(0151) unsigned char Amplitude_degree_tem_I2C6[10]={0};
(0152) 
(0153) //Dynamic_Offset_degree_origin [8][3],地址ADD_10,20,30,40
(0154) unsigned char Dynamic_Offset_degree_origin_init[24]=
(0155) {
(0156)   D_MAX,D_MAX-5,0,  //右14，右15，左0，急//加负号是左
(0157)   0.8*D_MAX,0.8*D_MAX-5,0, //右13，左1，q
(0158)   0.6*D_MAX,0.6*D_MAX-5,0,  //右12，左2,w
(0159)   0.45*D_MAX,0.45*D_MAX-5,0, //右11，左3,e
(0160)   0.3*D_MAX,0.3*D_MAX-5,0,  //右10，左4.r
(0161)   0.15*D_MAX,0.15*D_MAX-5,0, //右9，左5.t
(0162)   0.1*D_MAX,0.1*D_MAX-5,0,  //右8，左6，缓.y
(0163)     0,  0,  0 //中7，不转
(0164) };
(0165) unsigned char Dynamic_Offset_degree_origin_init1[8]={0};
(0166) unsigned char Dynamic_Offset_degree_origin_init2[8]={0};
(0167) unsigned char Dynamic_Offset_degree_origin_init3[8]={0};
(0168) unsigned char Dynamic_Offset_degree_origin_z[24]={0};//Dynamic_Offset_degree_origin[8][3]直接转成的1维数组
(0169) unsigned char Dynamic_Offset_degree_origin_z1[8]={0};//0-11
(0170) unsigned char Dynamic_Offset_degree_origin_z2[8]={0};//12-23
(0171) unsigned char Dynamic_Offset_degree_origin_z3[8]={0};//12-23
(0172) unsigned char Dynamic_Offset_degree_origin_I2C1[10]={0};//
(0173) unsigned char Dynamic_Offset_degree_origin_I2C2[10]={0};//
(0174) unsigned char Dynamic_Offset_degree_origin_I2C3[10]={0};//
(0175) //////////////----需要写入i2c的数据--END----//////////////////
(0176) 
(0177) 
(0178) /////////////----定义标志位--BEGIN----//////////////////
(0179) unsigned char isSrlStart=0;//收到开始位时置1；当为1时，开始接收下一位地址码，并判断是否匹配
(0180) unsigned char isSrlStartI2c=0;//收到初始化I2c的起始位时置1；开始接收下一位地址码，并判断是否匹配
(0181) unsigned char addr=0;//地址位匹配时置1；开始接收下一位命令位
(0182) unsigned char addrI2c=0;//i2c地址位匹配时置1；开始接受下一位i2c命令位
(0183) unsigned char s_change=0;//速度改变时置1 
(0184) unsigned char d_change=0;//方向改变时置1
(0185) unsigned char d_change_t=0;//方向改变,过渡状态中为1，稳定后清零
(0186) unsigned char d_change_t_v=0;//方向改变时置1，将实时偏移角赋给last作为前一状态偏移角，然后清零该标志位
(0187) unsigned char t_change=0;//调直时置1
(0188) unsigned char ts_change=0;//保存或取消调直状态时置1
(0189) unsigned char a_change=0;//幅度改变时置1
(0190) unsigned char f_change=0;//频率改变时置1
(0191) unsigned char id_change=0;//id改变时置1
(0192) unsigned char e_change=0;//接收到结束位时置1
(0193) unsigned char i_change=0;//接收到i2c初始化命令时置为1
(0194) unsigned char i2c_change=0;//接收到i2c初始化命令的结束位时置为1
(0195) unsigned char isInstruction=0;//是否接收到指令，已接收置为1，未接收，置为0；设置个标志位，保证指令必须是四位才能够执行，
(0196) //比如aa 9_ d5 d0 fc这样的指令是无效的，但若无此标志位，这个指令就是有效的，并且执行d0命令 
(0197) unsigned char isInstructionI2c=0;//是否接收到i2c指令，已接收置为1，未接收，置为0；设置个标志位，
(0198) //保证指令必须是四位才能够执行，比如cc 74 8_ aa fc这样的指令是无效的，但若无此标志位，这个指令就是有效的，并且执行8_命令 
(0199) //以上标志位，接收到结束位，执行命令后，清0
(0200) 
(0201) unsigned char is_uart=1;//串口是否接收到命令，鱼刚开电时，此标志位若为0，自动运行设定的模式，当串口接受到控制命令时候，此标志位置为1，进入手动控制模式
(0202) unsigned char m_change=0;//接收到模态码时置1，接收到其它命令时清0
(0203) unsigned char m_cishu=0;//mm_cishu,mmm_cishu共同决定模态码置1后循环的次数
(0204) unsigned char mm_cishu=0;//
(0205) unsigned char mmm_cishu=m_time-1;//
(0206) unsigned char a_cishu=0;//aa_cishu,aaa_cishu共同决定自动状态循环的次数//*auto
(0207) unsigned char aa_cishu=0;//
(0208) unsigned char aaa_cishu=m_time-1;//
(0209) unsigned char cishu=0;//模态中动作循环，以3为周期，即0,1,2,0,1,2....
(0210) unsigned char auto_cishu=0;//模态中动作循环，以5为周期，即0,1,2,3,4,0,1,2,3,4....
(0211) unsigned char y_change=0;//接收到原始转弯方式时置为1，接收到其他命令时清0
(0212) unsigned char y_changing=0;//正在执行原始转弯方式时置为1，此时不接受其他命令
(0213) unsigned char yy_time=0xff;//与y_time共同决定原始转弯模式的时间
(0214) unsigned char y_cishu=0;   //
(0215) unsigned char yy_cishu=0;
(0216) unsigned char yyy_cishu=y_time-1;
(0217) unsigned char cishu_y=0;//0时转弯，1时回到收到命令前的速度，直游
(0218) unsigned char y_tem=0;//转弯档
(0219) unsigned char y_speed=0;//保存转弯前速度
(0220) /////////////----定义标志位--END----//////////////////
(0221) 
(0222) 
(0223) /////////////----各档参数--BEGIN----//////////////////
(0224) unsigned char s_tem=0;//速度档，Speed_tem[s_tem],Amplitude_degree_tem[s_tem][i]
(0225) unsigned char m_tem=0;//m_tem&0x0f=模态档
(0226) unsigned char d_tem=0;//方向档，Dynamic_Offset_degree_origin [d_tem][i]
(0227) unsigned char dd_tem=0;//方向档左右同一后，
(0228) unsigned char flag=0;
(0229) // d_tem 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15 //7前左，后右
(0230) //dd_tem 0  1  2  3  4  5  6  7  6  5  4   3   2   1   0   0 //加负号左
(0231) ////flag=1时，左转d_tem小于7，加负号，flag=0，右转d_tem大于等于7
(0232) //unsigned char y_tem=0;//原始转弯档
(0233) unsigned char i2c_canshu=0;//保存参数修改时置1
(0234) 
(0235) //4个频率，旧通信模块的改频率，新通信模块不用此变量
(0236) unsigned char freq[4]={0xff,0xf7,0xef,0xdf};
(0237) 
(0238) //16档速度值,0-15,Speed值越大，速度越小
(0239) unsigned char Speed_tem[16]=  
(0240) {
(0241)   0,255,240,225,210,195,180,165,150,135,120,105,90,75,60,45//初始值，8-150
(0242) };//最大255//最慢150比较合适
(0243) 
(0244) //16档转弯值，0-15,7不转
(0245) unsigned char Dynamic_Offset_degree_origin[8][Joint_Num]=
(0246) {
(0247)   {D_MAX,D_MAX-5,0},  //右14，右15，左0，急//加负号是左
(0248)   {0.9*D_MAX,0.9*D_MAX-5,0}, //右13，左1，q
(0249)   {0.8*D_MAX,0.8*D_MAX-5,0},  //右12，左2,w
(0250)   {0.7*D_MAX,0.7*D_MAX-5,0}, //右11，左3,e
(0251)   {0.5*D_MAX,0.5*D_MAX-5,0},  //右10，左4.r
(0252)   {0.3*D_MAX,0.3*D_MAX-5,0}, //右9，左5.t
(0253)   {0.1*D_MAX,0.1*D_MAX-5,0},  //右8，左6，缓.y
(0254)     {0,  0,  0} //中7，不转
(0255) };//常量数组，给出Dynamic_Offset_degree的值
(0256) 
(0257) //原始转弯方式，16档转弯值，0-15,7不转
(0258) int Dynamic_Offset_degree_y[16][Joint_Num] =
(0259) {
(0260)   {-D_Y_MAX,-D_Y_MAX-5,-D_Y_MAX-10},  //左0，急
(0261)   {-0.9*D_Y_MAX,-0.9*D_Y_MAX-5,-0.9*D_Y_MAX-10}, //左1
(0262)   {-0.8*D_Y_MAX,-0.8*D_Y_MAX-5,-0.8*D_Y_MAX-10},  //左2
(0263)   {-0.7*D_Y_MAX,-0.7*D_Y_MAX-5,-0.7*D_Y_MAX-10}, //左3
(0264)   {-0.5*D_Y_MAX,-0.5*D_Y_MAX-5,-0.5*D_Y_MAX-10},  //左4
(0265)   {-0.3*D_Y_MAX,-0.3*D_Y_MAX-5,-0.3*D_Y_MAX-10}, //左5
(0266)   {-0.1*D_Y_MAX,-0.1*D_Y_MAX-5,-0.1*D_Y_MAX-10},  //左6，缓
(0267)   {  0,  0,  0}, //中7，不转
(0268)   { 0.1*D_Y_MAX, 0.1*D_Y_MAX-5,0.1*D_Y_MAX-10},  //右8，缓
(0269)   { 0.2*D_Y_MAX, 0.2*D_Y_MAX-5,0.2*D_Y_MAX-10}, //右9
(0270)   { 0.3*D_Y_MAX, 0.3*D_Y_MAX-5,0.3*D_Y_MAX-10},  //右10
(0271)   { 0.5*D_Y_MAX, 0.5*D_Y_MAX-5,0.5*D_Y_MAX-10}, //右11
(0272)   { 0.7*D_Y_MAX, 0.7*D_Y_MAX-5,0.7*D_Y_MAX-10},  //右12
(0273)   { 0.8*D_Y_MAX, 0.8*D_Y_MAX-5,0.8*D_Y_MAX-10}, //右13
(0274)   { 0.9*D_Y_MAX, 0.9*D_Y_MAX-5,0.9*D_Y_MAX-10},  //右14
(0275)   { D_Y_MAX,  D_Y_MAX-5, D_Y_MAX-10} //右15，急
(0276) };//常量数组，给出Dynamic_Offset_degree的值
(0277) 
(0278) int Joint_Angle_value [Joint_Num] =     //the final value to be written in duty cycle register
(0279) {
(0280)   0, 0, 0
(0281) };//初始化值
(0282) 
(0283) int Static_Offset_value [Joint_Num] =//调直用, 单位为度
(0284) {
(0285)   0, 0, 0
(0286) };
(0287) 
(0288) 
(0289) int Dynamic_Offset_degree [Joint_Num] =// modified through communication转弯用
(0290) {
(0291)  0, 0, 0           
(0292) };//用来计算Dynamic_Offset_value
(0293) 
(0294) unsigned char Dynamic_Offset_degree_char[Joint_Num]={0,0,0};
(0295) 
(0296) int Dynamic_Offset_value [Joint_Num] =
(0297) {
(0298)  0, 0, 0
(0299) };//根据Dynamic_Offset_degree计算得到,存储收到的转弯命令的Dynamic_Offset_value值，也就是要达到的值
(0300) 
(0301) int Dynamic_Offset_value_per[Joint_Num]=
(0302) {
(0303)  0,0,0
(0304) };//过渡状态时，每次增加的偏移角
(0305) 
(0306) int Dynamic_Offset_value_last[Joint_Num]=
(0307) {
(0308)  0,0,0
(0309) };//收到转弯命令之前的Dynamic_Offset_value值
(0310) 
(0311) int Dynamic_Offset_value_t[Joint_Num]=
(0312) {
(0313)  0,0,0
(0314) };//实时的Dynamic_Offset_value值
(0315) 
(0316) unsigned char Neighbouring_Offset_degree[Joint_Num] =// modified through communication 每关节相位差
(0317) {
(0318) // 0,60,120
(0319)   0,80,120
(0320) };
(0321) //常量，绝对相位差
(0322) unsigned char Amplitude_degree[Joint_Num] =// modified through communication 各关节摆幅
(0323) {
(0324)   15,20,25
(0325) //   90,20,25
(0326) };//常量,控制摆幅，Asin(),最大90度
(0327) unsigned char Amplitude_degree_tem[16][Joint_Num] =//16档摆幅，对应速度，0-15
(0328) {
(0329)   {0.1*A_MAX,0.1*A_MAX+10,0.1*A_MAX+15},//0 ，速度小摆幅小
(0330)   {0.15*A_MAX,0.15*A_MAX+10,0.15*A_MAX+15},//1
(0331)   {0.2*A_MAX,0.2*A_MAX+10,0.2*A_MAX+15},//
(0332)   {0.25*A_MAX,0.25*A_MAX+10,0.25*A_MAX+15},//3
(0333)   {0.3*A_MAX,0.3*A_MAX+10,0.3*A_MAX+15},//
(0334)   {0.35*A_MAX,0.35*A_MAX+10,0.35*A_MAX+15},//5
(0335)   {0.4*A_MAX,0.4*A_MAX+10,0.4*A_MAX+15},//
(0336)   {0.45*A_MAX,0.45*A_MAX+10,0.45*A_MAX+15},//7
(0337)   {0.5*A_MAX,0.5*A_MAX+10,0.5*A_MAX+15},//8******
(0338)   {0.55*A_MAX,0.55*A_MAX+10,0.55*A_MAX+15},//9
(0339)   {0.6*A_MAX,0.6*A_MAX+10,0.6*A_MAX+15},//
(0340)   {0.65*A_MAX,0.65*A_MAX+10,0.65*A_MAX+15},//11
(0341)   {0.7*A_MAX,0.7*A_MAX+10,0.7*A_MAX+15},//
(0342)   {0.75*A_MAX,0.75*A_MAX+10,0.75*A_MAX+15},//13
(0343)   {0.8*A_MAX,0.8*A_MAX+10,0.8*A_MAX+15},//
(0344)   {0.85*A_MAX,0.85*A_MAX+10,0.85*A_MAX+15}//15，速度大摆幅大
(0345) };
(0346) /////////////----各档参数--END----//////////////////
(0347) 
(0348) 
(0349) //*************************delay延时函数**********************
(0350) void delay(double interval)
(0351) {
(0352) 	double k;
(0353) 	for(k=0;k<interval;k++);
    00222 ED00      LDI	R16,0xD0
    00223 E010      LDI	R17,0
    00224 940E 1A8C CALL	elpm32
    00226 8308      ST	Y,R16
    00227 8319      STD	Y+1,R17
    00228 832A      STD	Y+2,R18
    00229 833B      STD	Y+3,R19
    0022A C014      RJMP	0x023F
    0022B 8028      LD	R2,Y
    0022C 8039      LDD	R3,Y+1
    0022D 804A      LDD	R4,Y+2
    0022E 805B      LDD	R5,Y+3
    0022F EC0C      LDI	R16,0xCC
    00230 E010      LDI	R17,0
    00231 940E 1A8C CALL	elpm32
    00233 933A      ST	-Y,R19
    00234 932A      ST	-Y,R18
    00235 931A      ST	-Y,R17
    00236 930A      ST	-Y,R16
    00237 0181      MOVW	R16,R2
    00238 0192      MOVW	R18,R4
    00239 940E 1B6F CALL	fpadd2
    0023B 8308      ST	Y,R16
    0023C 8319      STD	Y+1,R17
    0023D 832A      STD	Y+2,R18
    0023E 833B      STD	Y+3,R19
    0023F 8108      LD	R16,Y
    00240 8119      LDD	R17,Y+1
    00241 812A      LDD	R18,Y+2
    00242 813B      LDD	R19,Y+3
    00243 01CE      MOVW	R24,R28
    00244 9604      ADIW	R24,4
    00245 939A      ST	-Y,R25
    00246 938A      ST	-Y,R24
    00247 940E 1D8E CALL	fpcmp1
    00249 F30C      BLT	0x022B
    0024A 9628      ADIW	R28,0x8
    0024B 9508      RET
(0354) }
(0355) 
(0356) void delay_1ms(void) 
(0357) { 
(0358)  unsigned int i; 
(0359)  for (i=0;i<1142;i++) 
_delay_1ms:
  i                    --> R16
    0024C 2700      CLR	R16
    0024D 2711      CLR	R17
    0024E C002      RJMP	0x0251
    0024F 5F0F      SUBI	R16,0xFF
    00250 4F1F      SBCI	R17,0xFF
    00251 3706      CPI	R16,0x76
    00252 E0E4      LDI	R30,4
    00253 071E      CPC	R17,R30
    00254 F3D0      BCS	0x024F
    00255 9508      RET
_delay_nms:
  i                    --> R20
  n                    --> R10
    00256 940E 1AD2 CALL	push_xgset300C
    00258 0158      MOVW	R10,R16
(0360)   { 
(0361)   } 
(0362) } 
(0363) 
(0364) void delay_nms(unsigned int n) 
(0365) { 
(0366)  unsigned int i; 
(0367)  for(i=0;i<n;i++) 
    00259 2744      CLR	R20
    0025A 2755      CLR	R21
    0025B C003      RJMP	0x025F
(0368)  delay_1ms(); 
    0025C DFEF      RCALL	_delay_1ms
    0025D 5F4F      SUBI	R20,0xFF
    0025E 4F5F      SBCI	R21,0xFF
    0025F 154A      CP	R20,R10
    00260 055B      CPC	R21,R11
    00261 F3D0      BCS	0x025C
    00262 940C 1AD7 JMP	pop_xgset300C
(0369) }
(0370) 
(0371) 
(0372) //*************************设置各端口************************
(0373) void port_init(void)
(0374) {
(0375)  PORTA = 0x00;//0000 0001
_port_init:
    00264 2422      CLR	R2
    00265 BA2B      OUT	0x1B,R2
(0376)  DDRA  = 0x00;//0000 0001 PA0口输出，高电平
    00266 BA2A      OUT	0x1A,R2
(0377) // PORTB = 0xFF;//0xF0;//1111 0000
(0378) // DDRB  = 0xFF;//0xF0;//1111 0000
(0379)  PORTC = 0x00; //m103 output only
    00267 BA25      OUT	0x15,R2
(0380)  DDRC  = 0x00;
    00268 BA24      OUT	0x14,R2
(0381) // PORTD = 0xFF;//0xD0;//1101 0000
(0382) // DDRD  = 0xFF;//0xD0;//1101 0000
(0383) // PORTE = 0xFE;//1111 1110
(0384) // DDRE  = 0xFE;//1111 1110
(0385)   PORTE = 0xFE;//灯2，PE2
    00269 EF8E      LDI	R24,0xFE
    0026A B983      OUT	0x03,R24
(0386)  DDRE  = 0xFE;
    0026B B982      OUT	0x02,R24
(0387) // PORTF = 0xFF;//0x00;
(0388) // DDRF  = 0xFF;//0x00;
(0389) // PORTG = 0x1F;//0x00;
(0390) // DDRG  = 0x1F;//0x00;
(0391) ///////////////
(0392) // PORTB = 0xF0;//1111 0000
(0393) // DDRB  = 0xF0;//1111 0000
(0394)  PORTB = 0xF4;//灯1，PB2，&&&&&&&&&&&&&&&&&&
    0026C EF84      LDI	R24,0xF4
    0026D BB88      OUT	0x18,R24
(0395)  DDRB  = 0xF4;
    0026E BB87      OUT	0x17,R24
(0396) // PORTD = 0xD0;//1101 0000
(0397) // DDRD  = 0xD0;//1101 0000
(0398)  PORTD=0xfc;//0xfc;//xxxx xx00
    0026F EF8C      LDI	R24,0xFC
    00270 BB82      OUT	0x12,R24
(0399)  DDRD=0xfc;//xxxx xx00
    00271 BB81      OUT	0x11,R24
(0400)  //PORTF = 0x00;
(0401)  //DDRF  = 0x00;
(0402)  PORTF = 0xFF;
    00272 EF8F      LDI	R24,0xFF
    00273 9380 0062 STS	0x62,R24
(0403)  DDRF  = 0x0F;
    00275 E08F      LDI	R24,0xF
    00276 9380 0061 STS	0x61,R24
(0404) 
(0405)  
(0406)  PORTG = 0x00;
    00278 9220 0065 STS	0x65,R2
(0407)  DDRG  = 0x00;
    0027A 9220 0064 STS	0x64,R2
    0027C 9508      RET
(0408) 
(0409) 
(0410) }
(0411) 
(0412) //*****************************TIMER3 初始化***************************
(0413) void timer3_init(void)
(0414) {
(0415)  TCCR3B= 0x00; //stop
_timer3_init:
    0027D 2422      CLR	R2
    0027E 9220 008A STS	0x8A,R2
(0416)  TCNT3H= 0x00 /*INVALID SETTING*/; //setup
    00280 9220 0089 STS	0x89,R2
(0417)  TCNT3L= 0x00 /*INVALID SETTING*/;
    00282 9220 0088 STS	0x88,R2
(0418)  OCR3AH= 0x00 /*INVALID SETTING*/;
    00284 9220 0087 STS	0x87,R2
(0419)  OCR3AL= 0x00;
    00286 9220 0086 STS	0x86,R2
(0420)  OCR3BH= 0x00 /*INVALID SETTING*/;
    00288 9220 0085 STS	0x85,R2
(0421)  OCR3BL= 0x00;
    0028A 9220 0084 STS	0x84,R2
(0422)  OCR3CH= 0x00 /*INVALID SETTING*/;
    0028C 9220 0083 STS	0x83,R2
(0423)  OCR3CL= 0x00;
    0028E 9220 0082 STS	0x82,R2
(0424)  TCCR3A= 0xFE;
    00290 EF8E      LDI	R24,0xFE
    00291 9380 008B STS	0x8B,R24
(0425)  TCCR3B= 0x1A; //start Timer用8分频,快速PWM模式
    00293 E18A      LDI	R24,0x1A
    00294 9380 008A STS	0x8A,R24
    00296 9508      RET
(0426) }
(0427) 
(0428) //*****************************TIMER1 初始化***************************
(0429) void timer1_init(void)
(0430) {
(0431)  TCCR1B= 0x00; //stop
_timer1_init:
    00297 2422      CLR	R2
    00298 BC2E      OUT	0x2E,R2
(0432)  TCNT1H= 0x00 /*INVALID SETTING*/; //setup
    00299 BC2D      OUT	0x2D,R2
(0433)  TCNT1L= 0x00 /*INVALID SETTING*/;
    0029A BC2C      OUT	0x2C,R2
(0434)  OCR1AH= 0x00 /*INVALID SETTING*/;
    0029B BC2B      OUT	0x2B,R2
(0435)  OCR1AL= 0x00;
    0029C BC2A      OUT	0x2A,R2
(0436)  OCR1BH= 0x00 /*INVALID SETTING*/;
    0029D BC29      OUT	0x29,R2
(0437)  OCR1BL= 0x00;
    0029E BC28      OUT	0x28,R2
(0438)  OCR1CH= 0x00 /*INVALID SETTING*/;
    0029F 9220 0079 STS	0x79,R2
(0439)  OCR1CL= 0x00;
    002A1 9220 0078 STS	0x78,R2
(0440)  TCCR1A= 0xFE;
    002A3 EF8E      LDI	R24,0xFE
    002A4 BD8F      OUT	0x2F,R24
(0441)  TCCR1B= 0x1A; //start Timer用8分频,快速PWM模式
    002A5 E18A      LDI	R24,0x1A
    002A6 BD8E      OUT	0x2E,R24
    002A7 9508      RET
(0442) }
(0443) 
(0444) 
(0445) 
(0446) 
(0447) void uart0_init(void)
(0448) {
(0449)  UCSR0B = 0x00; //disable while setting baud rate
_uart0_init:
    002A8 2422      CLR	R2
    002A9 B82A      OUT	0x0A,R2
(0450)  UCSR0A = 0x00;
    002AA B82B      OUT	0x0B,R2
(0451)  UCSR0C = 0x06;       //*接受和发送数据帧的数据位字符长度保留
    002AB E086      LDI	R24,6
    002AC 9380 0095 STS	0x95,R24
(0452)  
(0453)  UBRR0H = 0x00; //set baud rate hi
    002AE 9220 0090 STS	0x90,R2
(0454)  UBRR0L = 0x33; //set baud rate lo
    002B0 E383      LDI	R24,0x33
    002B1 B989      OUT	0x09,R24
(0455)   
(0456)  UCSR0A = 0x00; //enable
    002B2 B82B      OUT	0x0B,R2
(0457)  UCSR0B = 0x98;
    002B3 E988      LDI	R24,0x98
    002B4 B98A      OUT	0x0A,R24
    002B5 9508      RET
(0458) }
(0459) 
(0460) //*************************initialize all peripherals***************
(0461) void init_devices(void)
(0462) {
(0463)  //stop errant interrupts until set up
(0464)  CLI(); //disable all interrupts,屏蔽所有中断
_init_devices:
    002B6 94F8      BCLR	7
(0465)  XDIV  = 0x00; //xtal divider,系统时钟分频控制寄存器
    002B7 2422      CLR	R2
    002B8 BE2C      OUT	0x3C,R2
(0466)  XMCRA = 0x00; //external memory，外部扩展存储器控制寄存器A
    002B9 9220 006D STS	0x6D,R2
(0467)  port_init();//端口初始化
    002BB DFA8      RCALL	_port_init
(0468)  //timer3_init();//定时器3初始化
(0469)  //timer1_init();//定时器1初始化
(0470)  uart0_init();//串口通信中断
    002BC DFEB      RCALL	_uart0_init
(0471)  MCUCR = 0x00;//MCU控制寄存器，57页
    002BD 2422      CLR	R2
    002BE BE25      OUT	0x35,R2
(0472)  //EICRA = 0x03; //extended ext ints，外部中断控制寄存器A
(0473)  EICRA=0x00;
    002BF 9220 006A STS	0x6A,R2
(0474)  EICRB = 0x00; //extended ext ints，外部中断控制寄存器B
    002C1 BE2A      OUT	0x3A,R2
(0475)  //EIMSK = 0x01;//外部中断屏蔽寄存器
(0476)  EIMSK = 0x00;
    002C2 BE29      OUT	0x39,R2
(0477) // TIMSK = 0x00; //timer interrupt sources，T/C中断屏蔽寄存器
(0478)  TIMSK = 0x44;
    002C3 E484      LDI	R24,0x44
    002C4 BF87      OUT	0x37,R24
(0479)  ETIMSK = 0x04; //extended timer interrupt sources，扩展T/C中断屏蔽寄存器
    002C5 E084      LDI	R24,4
    002C6 9380 007D STS	0x7D,R24
(0480)  SEI(); //re-enable interrupts
    002C8 9478      BSET	7
    002C9 9508      RET
(0481) }
(0482) 
(0483) 
(0484) 
(0485)  
(0486) 
(0487) void senddata(unsigned char data)
(0488) {
(0489)    /* 等待发送缓冲器为空 */
(0490)    while (!( UCSR0A & (1<<UDRE0)))
_senddata:
  data                 --> R16
    002CA 9B5D      SBIS	0x0B,5
    002CB CFFE      RJMP	_senddata
(0491)    ;
(0492)    /* 将数据放入缓冲器，发送数据*/
(0493)      UDR0 = data;
    002CC B90C      OUT	0x0C,R16
    002CD 9508      RET
(0494) }
(0495) 
(0496) 
(0497) void uart_putchar(char c) //发送一个字节
(0498) {
(0499)    while( !( UCSR0A & (1<<UDRE0)))
_uart_putchar:
  c                    --> R16
    002CE 9B5D      SBIS	0x0B,5
    002CF CFFE      RJMP	_uart_putchar
(0500)       ;
(0501)    UDR0=c;
    002D0 B90C      OUT	0x0C,R16
    002D1 9508      RET
_uart_word:
  i                    --> R20
  String               --> R10
    002D2 940E 1AD2 CALL	push_xgset300C
    002D4 0158      MOVW	R10,R16
(0502) }
(0503) 
(0504) void uart_word(char String[])//发送一个字符串
(0505) {
    002D5 C007      RJMP	0x02DD
(0506)    int i;
(0507)    while(String[i]!='\0') 
(0508)    {
(0509)       uart_putchar(String[i]);
    002D6 01FA      MOVW	R30,R20
    002D7 0DEA      ADD	R30,R10
    002D8 1DFB      ADC	R31,R11
    002D9 8100      LD	R16,Z
    002DA DFF3      RCALL	_uart_putchar
(0510) 	  i++;
    002DB 5F4F      SUBI	R20,0xFF
    002DC 4F5F      SBCI	R21,0xFF
    002DD 01FA      MOVW	R30,R20
    002DE 0DEA      ADD	R30,R10
    002DF 1DFB      ADC	R31,R11
    002E0 8020      LD	R2,Z
    002E1 2022      TST	R2
    002E2 F799      BNE	0x02D6
    002E3 940C 1AD7 JMP	pop_xgset300C
_Sin:
  y                    --> Y,+8
  temp                 --> Y,+4
  x                    --> Y,+0
  Offset_degree        --> R10
  speed                --> R12
  instant              --> R14
    002E5 940E 1ACB CALL	push_xgset00FC
    002E7 2EC2      MOV	R12,R18
    002E8 2EE0      MOV	R14,R16
    002E9 972C      SBIW	R28,0xC
    002EA 88AA      LDD	R10,Y+18
    002EB 88BB      LDD	R11,Y+19
(0511)    }
(0512) }
(0513) 
(0514) 
(0515) //*********************sin计算***************************
(0516) double Sin(unsigned char instant, unsigned char speed, int Offset_degree)
(0517) {
(0518) 
(0519) 	double x,y;
(0520) 	double temp;
(0521)         if(speed == 0)
    002EC 20CC      TST	R12
    002ED F429      BNE	0x02F3
(0522)           return 0;
    002EE ED00      LDI	R16,0xD0
    002EF E010      LDI	R17,0
    002F0 940E 1A8C CALL	elpm32
    002F2 C19A      RJMP	0x048D
(0523)         else
(0524)         {
(0525)           x = PI *2.0 *  ((double)instant / (double)speed) - PI * (double)Offset_degree / 180.0;       
    002F3 EC08      LDI	R16,0xC8
    002F4 E010      LDI	R17,0
    002F5 940E 1A8C CALL	elpm32
    002F7 0118      MOVW	R2,R16
    002F8 0129      MOVW	R4,R18
    002F9 2D0E      MOV	R16,R14
    002FA 2711      CLR	R17
    002FB 940E 1BC3 CALL	int2fp
    002FD 0138      MOVW	R6,R16
    002FE 0149      MOVW	R8,R18
    002FF 2D0C      MOV	R16,R12
    00300 2711      CLR	R17
    00301 940E 1BC3 CALL	int2fp
    00303 933A      ST	-Y,R19
    00304 932A      ST	-Y,R18
    00305 931A      ST	-Y,R17
    00306 930A      ST	-Y,R16
    00307 0183      MOVW	R16,R6
    00308 0194      MOVW	R18,R8
    00309 940E 1C04 CALL	fpdiv2x
    0030B 0181      MOVW	R16,R2
    0030C 0192      MOVW	R18,R4
    0030D 940E 1D68 CALL	fpmule2
    0030F 0118      MOVW	R2,R16
    00310 0129      MOVW	R4,R18
    00311 EC04      LDI	R16,0xC4
    00312 E010      LDI	R17,0
    00313 940E 1A8C CALL	elpm32
    00315 0138      MOVW	R6,R16
    00316 0149      MOVW	R8,R18
    00317 0185      MOVW	R16,R10
    00318 940E 1BC3 CALL	int2fp
    0031A 933A      ST	-Y,R19
    0031B 932A      ST	-Y,R18
    0031C 931A      ST	-Y,R17
    0031D 930A      ST	-Y,R16
    0031E 0183      MOVW	R16,R6
    0031F 0194      MOVW	R18,R8
    00320 940E 1D68 CALL	fpmule2
    00322 0138      MOVW	R6,R16
    00323 0149      MOVW	R8,R18
    00324 EC00      LDI	R16,0xC0
    00325 E010      LDI	R17,0
    00326 940E 1A8C CALL	elpm32
    00328 933A      ST	-Y,R19
    00329 932A      ST	-Y,R18
    0032A 931A      ST	-Y,R17
    0032B 930A      ST	-Y,R16
    0032C 0183      MOVW	R16,R6
    0032D 0194      MOVW	R18,R8
    0032E 940E 1C04 CALL	fpdiv2x
    00330 0181      MOVW	R16,R2
    00331 0192      MOVW	R18,R4
    00332 940E 1B84 CALL	fpsub2
    00334 8308      ST	Y,R16
    00335 8319      STD	Y+1,R17
    00336 832A      STD	Y+2,R18
    00337 833B      STD	Y+3,R19
(0526) 		 //100115 驹?解决滞后角超过一定范围后，电机的抖动问题         
(0527)          if(x>(2.0*PI))
    00338 01CE      MOVW	R24,R28
    00339 EC08      LDI	R16,0xC8
    0033A E010      LDI	R17,0
    0033B 940E 1A8C CALL	elpm32
    0033D 939A      ST	-Y,R25
    0033E 938A      ST	-Y,R24
    0033F 940E 1D8E CALL	fpcmp1
    00341 F4AC      BGE	0x0357
(0528)             x=x-2.0*PI;
    00342 8028      LD	R2,Y
    00343 8039      LDD	R3,Y+1
    00344 804A      LDD	R4,Y+2
    00345 805B      LDD	R5,Y+3
    00346 EC08      LDI	R16,0xC8
    00347 E010      LDI	R17,0
    00348 940E 1A8C CALL	elpm32
    0034A 933A      ST	-Y,R19
    0034B 932A      ST	-Y,R18
    0034C 931A      ST	-Y,R17
    0034D 930A      ST	-Y,R16
    0034E 0181      MOVW	R16,R2
    0034F 0192      MOVW	R18,R4
    00350 940E 1B84 CALL	fpsub2
    00352 8308      ST	Y,R16
    00353 8319      STD	Y+1,R17
    00354 832A      STD	Y+2,R18
    00355 833B      STD	Y+3,R19
    00356 C025      RJMP	0x037C
(0529)         else if(x<0.0)
    00357 8028      LD	R2,Y
    00358 8039      LDD	R3,Y+1
    00359 804A      LDD	R4,Y+2
    0035A 805B      LDD	R5,Y+3
    0035B ED00      LDI	R16,0xD0
    0035C E010      LDI	R17,0
    0035D 940E 1A8C CALL	elpm32
    0035F 933A      ST	-Y,R19
    00360 932A      ST	-Y,R18
    00361 931A      ST	-Y,R17
    00362 930A      ST	-Y,R16
    00363 0181      MOVW	R16,R2
    00364 0192      MOVW	R18,R4
    00365 940E 1D99 CALL	fpcmp2
    00367 F4A4      BGE	0x037C
(0530)             x=x+2.0*PI;
    00368 8028      LD	R2,Y
    00369 8039      LDD	R3,Y+1
    0036A 804A      LDD	R4,Y+2
    0036B 805B      LDD	R5,Y+3
    0036C EC08      LDI	R16,0xC8
    0036D E010      LDI	R17,0
    0036E 940E 1A8C CALL	elpm32
    00370 933A      ST	-Y,R19
    00371 932A      ST	-Y,R18
    00372 931A      ST	-Y,R17
    00373 930A      ST	-Y,R16
    00374 0181      MOVW	R16,R2
    00375 0192      MOVW	R18,R4
    00376 940E 1B6F CALL	fpadd2
    00378 8308      ST	Y,R16
    00379 8319      STD	Y+1,R17
    0037A 832A      STD	Y+2,R18
    0037B 833B      STD	Y+3,R19
(0531) 
(0532) 		  if(x<=(PI/2.0))
    0037C 01CE      MOVW	R24,R28
    0037D EB0C      LDI	R16,0xBC
    0037E E010      LDI	R17,0
    0037F 940E 1A8C CALL	elpm32
    00381 939A      ST	-Y,R25
    00382 938A      ST	-Y,R24
    00383 940E 1D8E CALL	fpcmp1
    00385 F134      BLT	0x03AC
(0533) 		y=x-x*x*x/6.0;//sinx,正数
    00386 8028      LD	R2,Y
    00387 8039      LDD	R3,Y+1
    00388 804A      LDD	R4,Y+2
    00389 805B      LDD	R5,Y+3
    0038A 0181      MOVW	R16,R2
    0038B 0192      MOVW	R18,R4
    0038C 01CE      MOVW	R24,R28
    0038D 939A      ST	-Y,R25
    0038E 938A      ST	-Y,R24
    0038F 940E 1D5E CALL	fpmule1
    00391 01CE      MOVW	R24,R28
    00392 939A      ST	-Y,R25
    00393 938A      ST	-Y,R24
    00394 940E 1D5E CALL	fpmule1
    00396 0138      MOVW	R6,R16
    00397 0149      MOVW	R8,R18
    00398 EB08      LDI	R16,0xB8
    00399 E010      LDI	R17,0
    0039A 940E 1A8C CALL	elpm32
    0039C 933A      ST	-Y,R19
    0039D 932A      ST	-Y,R18
    0039E 931A      ST	-Y,R17
    0039F 930A      ST	-Y,R16
    003A0 0183      MOVW	R16,R6
    003A1 0194      MOVW	R18,R8
    003A2 940E 1C04 CALL	fpdiv2x
    003A4 0181      MOVW	R16,R2
    003A5 0192      MOVW	R18,R4
    003A6 940E 1B84 CALL	fpsub2
    003A8 8708      STD	Y+8,R16
    003A9 8719      STD	Y+9,R17
    003AA 872A      STD	Y+10,R18
    003AB 873B      STD	Y+11,R19
(0534) 
(0535)           if(x>(PI/2.0)&&x<=PI)
    003AC 01CE      MOVW	R24,R28
    003AD EB0C      LDI	R16,0xBC
    003AE E010      LDI	R17,0
    003AF 940E 1A8C CALL	elpm32
    003B1 939A      ST	-Y,R25
    003B2 938A      ST	-Y,R24
    003B3 940E 1D8E CALL	fpcmp1
    003B5 F00C      BLT	0x03B7
    003B6 C040      RJMP	0x03F7
    003B7 01CE      MOVW	R24,R28
    003B8 EC04      LDI	R16,0xC4
    003B9 E010      LDI	R17,0
    003BA 940E 1A8C CALL	elpm32
    003BC 939A      ST	-Y,R25
    003BD 938A      ST	-Y,R24
    003BE 940E 1D8E CALL	fpcmp1
    003C0 F40C      BGE	0x03C2
    003C1 C035      RJMP	0x03F7
(0536) 	   {
(0537) 		temp=PI-x;
    003C2 EC04      LDI	R16,0xC4
    003C3 E010      LDI	R17,0
    003C4 940E 1A8C CALL	elpm32
    003C6 01CE      MOVW	R24,R28
    003C7 939A      ST	-Y,R25
    003C8 938A      ST	-Y,R24
    003C9 940E 1B7A CALL	fpsub1
    003CB 830C      STD	Y+4,R16
    003CC 831D      STD	Y+5,R17
    003CD 832E      STD	Y+6,R18
    003CE 833F      STD	Y+7,R19
(0538) 		y=temp-temp*temp*temp/6.0;//正数
    003CF 802C      LDD	R2,Y+4
    003D0 803D      LDD	R3,Y+5
    003D1 804E      LDD	R4,Y+6
    003D2 805F      LDD	R5,Y+7
    003D3 0181      MOVW	R16,R2
    003D4 0192      MOVW	R18,R4
    003D5 01CE      MOVW	R24,R28
    003D6 9604      ADIW	R24,4
    003D7 939A      ST	-Y,R25
    003D8 938A      ST	-Y,R24
    003D9 940E 1D5E CALL	fpmule1
    003DB 01CE      MOVW	R24,R28
    003DC 9604      ADIW	R24,4
    003DD 939A      ST	-Y,R25
    003DE 938A      ST	-Y,R24
    003DF 940E 1D5E CALL	fpmule1
    003E1 0138      MOVW	R6,R16
    003E2 0149      MOVW	R8,R18
    003E3 EB08      LDI	R16,0xB8
    003E4 E010      LDI	R17,0
    003E5 940E 1A8C CALL	elpm32
    003E7 933A      ST	-Y,R19
    003E8 932A      ST	-Y,R18
    003E9 931A      ST	-Y,R17
    003EA 930A      ST	-Y,R16
    003EB 0183      MOVW	R16,R6
    003EC 0194      MOVW	R18,R8
    003ED 940E 1C04 CALL	fpdiv2x
    003EF 0181      MOVW	R16,R2
    003F0 0192      MOVW	R18,R4
    003F1 940E 1B84 CALL	fpsub2
    003F3 8708      STD	Y+8,R16
    003F4 8719      STD	Y+9,R17
    003F5 872A      STD	Y+10,R18
    003F6 873B      STD	Y+11,R19
(0539) 	   }
(0540) 
(0541)           if(x>PI&&x<=(PI*3.0/2.0))
    003F7 01CE      MOVW	R24,R28
    003F8 EC04      LDI	R16,0xC4
    003F9 E010      LDI	R17,0
    003FA 940E 1A8C CALL	elpm32
    003FC 939A      ST	-Y,R25
    003FD 938A      ST	-Y,R24
    003FE 940E 1D8E CALL	fpcmp1
    00400 F00C      BLT	0x0402
    00401 C047      RJMP	0x0449
    00402 01CE      MOVW	R24,R28
    00403 EB04      LDI	R16,0xB4
    00404 E010      LDI	R17,0
    00405 940E 1A8C CALL	elpm32
    00407 939A      ST	-Y,R25
    00408 938A      ST	-Y,R24
    00409 940E 1D8E CALL	fpcmp1
    0040B F40C      BGE	0x040D
    0040C C03C      RJMP	0x0449
(0542) 	   {
(0543) 		temp=x-PI;
    0040D 8028      LD	R2,Y
    0040E 8039      LDD	R3,Y+1
    0040F 804A      LDD	R4,Y+2
    00410 805B      LDD	R5,Y+3
    00411 EC04      LDI	R16,0xC4
    00412 E010      LDI	R17,0
    00413 940E 1A8C CALL	elpm32
    00415 933A      ST	-Y,R19
    00416 932A      ST	-Y,R18
    00417 931A      ST	-Y,R17
    00418 930A      ST	-Y,R16
    00419 0181      MOVW	R16,R2
    0041A 0192      MOVW	R18,R4
    0041B 940E 1B84 CALL	fpsub2
    0041D 830C      STD	Y+4,R16
    0041E 831D      STD	Y+5,R17
    0041F 832E      STD	Y+6,R18
    00420 833F      STD	Y+7,R19
(0544) 		y=temp*temp*temp/6.0-temp;//负数
    00421 810C      LDD	R16,Y+4
    00422 811D      LDD	R17,Y+5
    00423 812E      LDD	R18,Y+6
    00424 813F      LDD	R19,Y+7
    00425 01CE      MOVW	R24,R28
    00426 9604      ADIW	R24,4
    00427 939A      ST	-Y,R25
    00428 938A      ST	-Y,R24
    00429 940E 1D5E CALL	fpmule1
    0042B 01CE      MOVW	R24,R28
    0042C 9604      ADIW	R24,4
    0042D 939A      ST	-Y,R25
    0042E 938A      ST	-Y,R24
    0042F 940E 1D5E CALL	fpmule1
    00431 0118      MOVW	R2,R16
    00432 0129      MOVW	R4,R18
    00433 EB08      LDI	R16,0xB8
    00434 E010      LDI	R17,0
    00435 940E 1A8C CALL	elpm32
    00437 933A      ST	-Y,R19
    00438 932A      ST	-Y,R18
    00439 931A      ST	-Y,R17
    0043A 930A      ST	-Y,R16
    0043B 0181      MOVW	R16,R2
    0043C 0192      MOVW	R18,R4
    0043D 940E 1BEE CALL	fpdiv2
    0043F 01CE      MOVW	R24,R28
    00440 9604      ADIW	R24,4
    00441 939A      ST	-Y,R25
    00442 938A      ST	-Y,R24
    00443 940E 1B7A CALL	fpsub1
    00445 8708      STD	Y+8,R16
    00446 8719      STD	Y+9,R17
    00447 872A      STD	Y+10,R18
    00448 873B      STD	Y+11,R19
(0545) 	   }
(0546) 
(0547) 	  if(x>(PI*3.0/2.0))
    00449 01CE      MOVW	R24,R28
    0044A EB04      LDI	R16,0xB4
    0044B E010      LDI	R17,0
    0044C 940E 1A8C CALL	elpm32
    0044E 939A      ST	-Y,R25
    0044F 938A      ST	-Y,R24
    00450 940E 1D8E CALL	fpcmp1
    00452 F00C      BLT	0x0454
    00453 C035      RJMP	0x0489
(0548) 	   {
(0549) 	        temp=2.0*PI-x;
    00454 EC08      LDI	R16,0xC8
    00455 E010      LDI	R17,0
    00456 940E 1A8C CALL	elpm32
    00458 01CE      MOVW	R24,R28
    00459 939A      ST	-Y,R25
    0045A 938A      ST	-Y,R24
    0045B 940E 1B7A CALL	fpsub1
    0045D 830C      STD	Y+4,R16
    0045E 831D      STD	Y+5,R17
    0045F 832E      STD	Y+6,R18
    00460 833F      STD	Y+7,R19
(0550) 	        y=temp*temp*temp/6.0-temp;//负数
    00461 810C      LDD	R16,Y+4
    00462 811D      LDD	R17,Y+5
    00463 812E      LDD	R18,Y+6
    00464 813F      LDD	R19,Y+7
    00465 01CE      MOVW	R24,R28
    00466 9604      ADIW	R24,4
    00467 939A      ST	-Y,R25
    00468 938A      ST	-Y,R24
    00469 940E 1D5E CALL	fpmule1
    0046B 01CE      MOVW	R24,R28
    0046C 9604      ADIW	R24,4
    0046D 939A      ST	-Y,R25
    0046E 938A      ST	-Y,R24
    0046F 940E 1D5E CALL	fpmule1
    00471 0118      MOVW	R2,R16
    00472 0129      MOVW	R4,R18
    00473 EB08      LDI	R16,0xB8
    00474 E010      LDI	R17,0
    00475 940E 1A8C CALL	elpm32
    00477 933A      ST	-Y,R19
    00478 932A      ST	-Y,R18
    00479 931A      ST	-Y,R17
    0047A 930A      ST	-Y,R16
    0047B 0181      MOVW	R16,R2
    0047C 0192      MOVW	R18,R4
    0047D 940E 1BEE CALL	fpdiv2
    0047F 01CE      MOVW	R24,R28
    00480 9604      ADIW	R24,4
    00481 939A      ST	-Y,R25
    00482 938A      ST	-Y,R24
    00483 940E 1B7A CALL	fpsub1
    00485 8708      STD	Y+8,R16
    00486 8719      STD	Y+9,R17
    00487 872A      STD	Y+10,R18
    00488 873B      STD	Y+11,R19
(0551) 	   }
(0552) 
(0553) 	 return y;
    00489 8508      LDD	R16,Y+8
    0048A 8519      LDD	R17,Y+9
    0048B 852A      LDD	R18,Y+10
    0048C 853B      LDD	R19,Y+11
    0048D 962C      ADIW	R28,0xC
    0048E 940C 1AB5 JMP	pop_xgset00FC
_init_static_offset:
  i                    --> R20
    00490 934A      ST	-Y,R20
(0554) 
(0555)         }
(0556) }
(0557) 
(0558) //**********************************静态偏移转换为控制量*************************
(0559) void init_static_offset(void)//括号内添加void
(0560) {
(0561)   unsigned char i;
(0562) 
(0563)   for(i=0; i<Joint_Num; i++)
    00491 2744      CLR	R20
    00492 C022      RJMP	0x04B5
(0564)   {
(0565)        Static_Offset_value[i] =((int) ((Static_Offset_degree[i] * 10) * FLK)>>3)-1;//1度10us
    00493 E184      LDI	R24,0x14
    00494 E091      LDI	R25,1
    00495 2FE4      MOV	R30,R20
    00496 27FF      CLR	R31
    00497 0FE8      ADD	R30,R24
    00498 1FF9      ADC	R31,R25
    00499 8110      LD	R17,Z
    0049A E00A      LDI	R16,0xA
    0049B 0301      MULSU	R16,R17
    0049C 01C0      MOVW	R24,R0
    0049D 0F88      LSL	R24
    0049E 1F99      ROL	R25
    0049F 0F88      LSL	R24
    004A0 1F99      ROL	R25
    004A1 0F88      LSL	R24
    004A2 1F99      ROL	R25
    004A3 9595      ASR	R25
    004A4 9587      ROR	R24
    004A5 9595      ASR	R25
    004A6 9587      ROR	R24
    004A7 9595      ASR	R25
    004A8 9587      ROR	R24
    004A9 9701      SBIW	R24,1
    004AA ECE4      LDI	R30,0xC4
    004AB E0F3      LDI	R31,3
    004AC 2FA4      MOV	R26,R20
    004AD 27BB      CLR	R27
    004AE 0FAA      LSL	R26
    004AF 1FBB      ROL	R27
    004B0 0FAE      ADD	R26,R30
    004B1 1FBF      ADC	R27,R31
    004B2 938D      ST	X+,R24
    004B3 939C      ST	X,R25
    004B4 9543      INC	R20
    004B5 3043      CPI	R20,3
    004B6 F2E0      BCS	0x0493
    004B7 9149      LD	R20,Y+
    004B8 9508      RET
_init_dynamic_offset:
  i                    --> R20
    004B9 934A      ST	-Y,R20
(0566)   }
(0567) }
(0568) 
(0569) //**********************************动态偏移转换为控制量*************************
(0570) void init_dynamic_offset(void)//括号内添加void
(0571) {
(0572)   unsigned char i;
(0573)   
(0574)    for(i=0; i<Joint_Num; i++)
    004BA 2744      CLR	R20
    004BB C025      RJMP	0x04E1
(0575)    {
(0576)    Dynamic_Offset_value[i] = ((int) ((Dynamic_Offset_degree[i] * 10) * FLK)>>3)-1;
    004BC 2E24      MOV	R2,R20
    004BD 2433      CLR	R3
    004BE 0C22      LSL	R2
    004BF 1C33      ROL	R3
    004C0 EC8A      LDI	R24,0xCA
    004C1 E093      LDI	R25,3
    004C2 01F1      MOVW	R30,R2
    004C3 0FE8      ADD	R30,R24
    004C4 1FF9      ADC	R31,R25
    004C5 8120      LD	R18,Z
    004C6 8131      LDD	R19,Z+1
    004C7 E00A      LDI	R16,0xA
    004C8 E010      LDI	R17,0
    004C9 940E 1AA0 CALL	empy16s
    004CB 01C8      MOVW	R24,R16
    004CC 0F88      LSL	R24
    004CD 1F99      ROL	R25
    004CE 0F88      LSL	R24
    004CF 1F99      ROL	R25
    004D0 0F88      LSL	R24
    004D1 1F99      ROL	R25
    004D2 9595      ASR	R25
    004D3 9587      ROR	R24
    004D4 9595      ASR	R25
    004D5 9587      ROR	R24
    004D6 9595      ASR	R25
    004D7 9587      ROR	R24
    004D8 9701      SBIW	R24,1
    004D9 EDE3      LDI	R30,0xD3
    004DA E0F3      LDI	R31,3
    004DB 01D1      MOVW	R26,R2
    004DC 0FAE      ADD	R26,R30
    004DD 1FBF      ADC	R27,R31
    004DE 938D      ST	X+,R24
    004DF 939C      ST	X,R25
    004E0 9543      INC	R20
    004E1 3043      CPI	R20,3
    004E2 F2C8      BCS	0x04BC
    004E3 9149      LD	R20,Y+
    004E4 9508      RET
_calculate_data:
  i                    --> R10
    004E5 940E 1AEA CALL	push_xgsetF03C
    004E7 9722      SBIW	R28,2
(0577)    }
(0578) }
(0579) //***********************************计算最终控制量******************************
(0580) 
(0581) void calculate_data(void)   //算出每次溢出中断改动的OCRnX值//括号内添加void
(0582) {
(0583)   unsigned char i;
(0584)   if(d_change_t_v==1)//*方向改变时置1，将实时偏移角赋给last作为前一状态偏移角
    004E8 9180 030E LDS	R24,d_change_t_v
    004EA 3081      CPI	R24,1
    004EB F4E1      BNE	0x0508
(0585)   {
(0586)      d_change_t_v=0;
    004EC 2422      CLR	R2
    004ED 9220 030E STS	d_change_t_v,R2
(0587) 	 for(i=0;i<Joint_Num;i++)
    004EF 24AA      CLR	R10
    004F0 C014      RJMP	0x0505
(0588) 	 {
(0589) 	   Dynamic_Offset_value_last[i]=Dynamic_Offset_value_t[i];
    004F1 2C2A      MOV	R2,R10
    004F2 2433      CLR	R3
    004F3 0C22      LSL	R2
    004F4 1C33      ROL	R3
    004F5 0121      MOVW	R4,R2
    004F6 EE85      LDI	R24,0xE5
    004F7 E093      LDI	R25,3
    004F8 01F1      MOVW	R30,R2
    004F9 0FE8      ADD	R30,R24
    004FA 1FF9      ADC	R31,R25
    004FB 8020      LD	R2,Z
    004FC 8031      LDD	R3,Z+1
    004FD ED8F      LDI	R24,0xDF
    004FE E093      LDI	R25,3
    004FF 01F2      MOVW	R30,R4
    00500 0FE8      ADD	R30,R24
    00501 1FF9      ADC	R31,R25
    00502 8231      STD	Z+1,R3
    00503 8220      ST	Z,R2
    00504 94A3      INC	R10
    00505 2D8A      MOV	R24,R10
    00506 3083      CPI	R24,3
    00507 F348      BCS	0x04F1
(0590)      }
(0591)   }
(0592)   if((d_change_t==1)&&(t_dynamic>0)&&(t_dynamic<=(Speed_dynamic/2)))//过渡状态
    00508 9180 030D LDS	R24,d_change_t
    0050A 3081      CPI	R24,1
    0050B F009      BEQ	0x050D
    0050C C0C8      RJMP	0x05D5
    0050D 9020 0105 LDS	R2,t_dynamic
    0050F E080      LDI	R24,0
    00510 1582      CP	R24,R2
    00511 F008      BCS	0x0513
    00512 C0C2      RJMP	0x05D5
    00513 E022      LDI	R18,2
    00514 E030      LDI	R19,0
    00515 9100 0106 LDS	R16,Speed_dynamic
    00517 2711      CLR	R17
    00518 940E 1A3E CALL	div16s
    0051A 2433      CLR	R3
    0051B 1502      CP	R16,R2
    0051C 0513      CPC	R17,R3
    0051D F40C      BGE	0x051F
    0051E C0B6      RJMP	0x05D5
(0593)    {
(0594)       for(i=0;i<Joint_Num;i++)
    0051F 24AA      CLR	R10
    00520 C045      RJMP	0x0566
(0595) 	  {
(0596) 	    Dynamic_Offset_value_per[i]=(Dynamic_Offset_value[i]-Dynamic_Offset_value_last[i])/(Speed_dynamic/2);
    00521 2CCA      MOV	R12,R10
    00522 24DD      CLR	R13
    00523 0CCC      LSL	R12
    00524 1CDD      ROL	R13
    00525 ED8F      LDI	R24,0xDF
    00526 E093      LDI	R25,3
    00527 01F6      MOVW	R30,R12
    00528 0FE8      ADD	R30,R24
    00529 1FF9      ADC	R31,R25
    0052A 8020      LD	R2,Z
    0052B 8031      LDD	R3,Z+1
    0052C ED83      LDI	R24,0xD3
    0052D E093      LDI	R25,3
    0052E 01F6      MOVW	R30,R12
    0052F 0FE8      ADD	R30,R24
    00530 1FF9      ADC	R31,R25
    00531 8040      LD	R4,Z
    00532 8051      LDD	R5,Z+1
    00533 1842      SUB	R4,R2
    00534 0853      SBC	R5,R3
    00535 E022      LDI	R18,2
    00536 E030      LDI	R19,0
    00537 9100 0106 LDS	R16,Speed_dynamic
    00539 2711      CLR	R17
    0053A 940E 1A3E CALL	div16s
    0053C 0198      MOVW	R18,R16
    0053D 0182      MOVW	R16,R4
    0053E 940E 1A3E CALL	div16s
    00540 ED89      LDI	R24,0xD9
    00541 E093      LDI	R25,3
    00542 01F6      MOVW	R30,R12
    00543 0FE8      ADD	R30,R24
    00544 1FF9      ADC	R31,R25
    00545 8311      STD	Z+1,R17
    00546 8300      ST	Z,R16
(0597) 	    Dynamic_Offset_value_t[i]=Dynamic_Offset_value_last[i]+(Dynamic_Offset_value_per[i])*t_dynamic;
    00547 2CCA      MOV	R12,R10
    00548 24DD      CLR	R13
    00549 0CCC      LSL	R12
    0054A 1CDD      ROL	R13
    0054B 01F6      MOVW	R30,R12
    0054C 0FE8      ADD	R30,R24
    0054D 1FF9      ADC	R31,R25
    0054E 8100      LD	R16,Z
    0054F 8111      LDD	R17,Z+1
    00550 9120 0105 LDS	R18,t_dynamic
    00552 2733      CLR	R19
    00553 940E 1AA0 CALL	empy16s
    00555 ED8F      LDI	R24,0xDF
    00556 E093      LDI	R25,3
    00557 01F6      MOVW	R30,R12
    00558 0FE8      ADD	R30,R24
    00559 1FF9      ADC	R31,R25
    0055A 8020      LD	R2,Z
    0055B 8031      LDD	R3,Z+1
    0055C 0E20      ADD	R2,R16
    0055D 1E31      ADC	R3,R17
    0055E EE85      LDI	R24,0xE5
    0055F E093      LDI	R25,3
    00560 01F6      MOVW	R30,R12
    00561 0FE8      ADD	R30,R24
    00562 1FF9      ADC	R31,R25
    00563 8231      STD	Z+1,R3
    00564 8220      ST	Z,R2
    00565 94A3      INC	R10
    00566 2D8A      MOV	R24,R10
    00567 3083      CPI	R24,3
    00568 F408      BCC	0x056A
    00569 CFB7      RJMP	0x0521
(0598) 	  }
(0599)       for(i=0; i< Joint_Num; i++)
    0056A 24AA      CLR	R10
    0056B C064      RJMP	0x05D0
(0600)        Joint_Angle_value[i] =MiddlePosition_value + Static_Offset_value[i]+Dynamic_Offset_value_t[i]+  ((int) (Amplitude_degree[i] * Sin( Instant, Speed, Neighbouring_Offset_degree[i]) *10*FLK)>>3)-1;
    0056C EE8B      LDI	R24,0xEB
    0056D E093      LDI	R25,3
    0056E 2DEA      MOV	R30,R10
    0056F 27FF      CLR	R31
    00570 0FE8      ADD	R30,R24
    00571 1FF9      ADC	R31,R25
    00572 8020      LD	R2,Z
    00573 2433      CLR	R3
    00574 8239      STD	Y+1,R3
    00575 8228      ST	Y,R2
    00576 9120 0100 LDS	R18,Speed
    00578 9100 0101 LDS	R16,Instant
    0057A DD6A      RCALL	_Sin
    0057B 0118      MOVW	R2,R16
    0057C 0129      MOVW	R4,R18
    0057D 2CCA      MOV	R12,R10
    0057E 24DD      CLR	R13
    0057F 0CCC      LSL	R12
    00580 1CDD      ROL	R13
    00581 EB00      LDI	R16,0xB0
    00582 E010      LDI	R17,0
    00583 940E 1A8C CALL	elpm32
    00585 0138      MOVW	R6,R16
    00586 0149      MOVW	R8,R18
    00587 EA0C      LDI	R16,0xAC
    00588 E010      LDI	R17,0
    00589 940E 1A8C CALL	elpm32
    0058B 01A8      MOVW	R20,R16
    0058C 01B9      MOVW	R22,R18
    0058D EE8E      LDI	R24,0xEE
    0058E E093      LDI	R25,3
    0058F 2DEA      MOV	R30,R10
    00590 27FF      CLR	R31
    00591 0FE8      ADD	R30,R24
    00592 1FF9      ADC	R31,R25
    00593 8100      LD	R16,Z
    00594 2711      CLR	R17
    00595 940E 1BC3 CALL	int2fp
    00597 925A      ST	-Y,R5
    00598 924A      ST	-Y,R4
    00599 923A      ST	-Y,R3
    0059A 922A      ST	-Y,R2
    0059B 940E 1D73 CALL	fpmule2x
    0059D 018A      MOVW	R16,R20
    0059E 019B      MOVW	R18,R22
    0059F 940E 1D73 CALL	fpmule2x
    005A1 0183      MOVW	R16,R6
    005A2 0194      MOVW	R18,R8
    005A3 940E 1D68 CALL	fpmule2
    005A5 940E 1B8F CALL	fpint
    005A7 0118      MOVW	R2,R16
    005A8 9435      ASR	R3
    005A9 9427      ROR	R2
    005AA 9435      ASR	R3
    005AB 9427      ROR	R2
    005AC 9435      ASR	R3
    005AD 9427      ROR	R2
    005AE EC84      LDI	R24,0xC4
    005AF E093      LDI	R25,3
    005B0 01F6      MOVW	R30,R12
    005B1 0FE8      ADD	R30,R24
    005B2 1FF9      ADC	R31,R25
    005B3 8040      LD	R4,Z
    005B4 8051      LDD	R5,Z+1
    005B5 9060 0428 LDS	R6,MiddlePosition_value
    005B7 9070 0429 LDS	R7,MiddlePosition_value+1
    005B9 0C64      ADD	R6,R4
    005BA 1C75      ADC	R7,R5
    005BB EE85      LDI	R24,0xE5
    005BC E093      LDI	R25,3
    005BD 01F6      MOVW	R30,R12
    005BE 0FE8      ADD	R30,R24
    005BF 1FF9      ADC	R31,R25
    005C0 8040      LD	R4,Z
    005C1 8051      LDD	R5,Z+1
    005C2 0C64      ADD	R6,R4
    005C3 1C75      ADC	R7,R5
    005C4 01C3      MOVW	R24,R6
    005C5 0D82      ADD	R24,R2
    005C6 1D93      ADC	R25,R3
    005C7 9701      SBIW	R24,1
    005C8 EBEE      LDI	R30,0xBE
    005C9 E0F3      LDI	R31,3
    005CA 01D6      MOVW	R26,R12
    005CB 0FAE      ADD	R26,R30
    005CC 1FBF      ADC	R27,R31
    005CD 938D      ST	X+,R24
    005CE 939C      ST	X,R25
    005CF 94A3      INC	R10
    005D0 2D8A      MOV	R24,R10
    005D1 3083      CPI	R24,3
    005D2 F408      BCC	0x05D4
    005D3 CF98      RJMP	0x056C
(0601)     }
    005D4 C06D      RJMP	0x0642
(0602)    else//稳定状态
(0603)    {
(0604)       d_change_t=0;
    005D5 2422      CLR	R2
    005D6 9220 030D STS	d_change_t,R2
(0605)       for(i=0; i< Joint_Num; i++)
    005D8 24AA      CLR	R10
    005D9 C064      RJMP	0x063E
(0606)         Joint_Angle_value[i] =MiddlePosition_value + Static_Offset_value[i]+Dynamic_Offset_value[i]+  ((int) (Amplitude_degree[i] * Sin( Instant, Speed, Neighbouring_Offset_degree[i]) *10*FLK)>>3)-1;
    005DA EE8B      LDI	R24,0xEB
    005DB E093      LDI	R25,3
    005DC 2DEA      MOV	R30,R10
    005DD 27FF      CLR	R31
    005DE 0FE8      ADD	R30,R24
    005DF 1FF9      ADC	R31,R25
    005E0 8020      LD	R2,Z
    005E1 2433      CLR	R3
    005E2 8239      STD	Y+1,R3
    005E3 8228      ST	Y,R2
    005E4 9120 0100 LDS	R18,Speed
    005E6 9100 0101 LDS	R16,Instant
    005E8 DCFC      RCALL	_Sin
    005E9 0118      MOVW	R2,R16
    005EA 0129      MOVW	R4,R18
    005EB 2CCA      MOV	R12,R10
    005EC 24DD      CLR	R13
    005ED 0CCC      LSL	R12
    005EE 1CDD      ROL	R13
    005EF EB00      LDI	R16,0xB0
    005F0 E010      LDI	R17,0
    005F1 940E 1A8C CALL	elpm32
    005F3 0138      MOVW	R6,R16
    005F4 0149      MOVW	R8,R18
    005F5 EA0C      LDI	R16,0xAC
    005F6 E010      LDI	R17,0
    005F7 940E 1A8C CALL	elpm32
    005F9 01A8      MOVW	R20,R16
    005FA 01B9      MOVW	R22,R18
    005FB EE8E      LDI	R24,0xEE
    005FC E093      LDI	R25,3
    005FD 2DEA      MOV	R30,R10
    005FE 27FF      CLR	R31
    005FF 0FE8      ADD	R30,R24
    00600 1FF9      ADC	R31,R25
    00601 8100      LD	R16,Z
    00602 2711      CLR	R17
    00603 940E 1BC3 CALL	int2fp
    00605 925A      ST	-Y,R5
    00606 924A      ST	-Y,R4
    00607 923A      ST	-Y,R3
    00608 922A      ST	-Y,R2
    00609 940E 1D73 CALL	fpmule2x
    0060B 018A      MOVW	R16,R20
    0060C 019B      MOVW	R18,R22
    0060D 940E 1D73 CALL	fpmule2x
    0060F 0183      MOVW	R16,R6
    00610 0194      MOVW	R18,R8
    00611 940E 1D68 CALL	fpmule2
    00613 940E 1B8F CALL	fpint
    00615 0118      MOVW	R2,R16
    00616 9435      ASR	R3
    00617 9427      ROR	R2
    00618 9435      ASR	R3
    00619 9427      ROR	R2
    0061A 9435      ASR	R3
    0061B 9427      ROR	R2
    0061C EC84      LDI	R24,0xC4
    0061D E093      LDI	R25,3
    0061E 01F6      MOVW	R30,R12
    0061F 0FE8      ADD	R30,R24
    00620 1FF9      ADC	R31,R25
    00621 8040      LD	R4,Z
    00622 8051      LDD	R5,Z+1
    00623 9060 0428 LDS	R6,MiddlePosition_value
    00625 9070 0429 LDS	R7,MiddlePosition_value+1
    00627 0C64      ADD	R6,R4
    00628 1C75      ADC	R7,R5
    00629 ED83      LDI	R24,0xD3
    0062A E093      LDI	R25,3
    0062B 01F6      MOVW	R30,R12
    0062C 0FE8      ADD	R30,R24
    0062D 1FF9      ADC	R31,R25
    0062E 8040      LD	R4,Z
    0062F 8051      LDD	R5,Z+1
    00630 0C64      ADD	R6,R4
    00631 1C75      ADC	R7,R5
    00632 01C3      MOVW	R24,R6
    00633 0D82      ADD	R24,R2
    00634 1D93      ADC	R25,R3
    00635 9701      SBIW	R24,1
    00636 EBEE      LDI	R30,0xBE
    00637 E0F3      LDI	R31,3
    00638 01D6      MOVW	R26,R12
    00639 0FAE      ADD	R26,R30
    0063A 1FBF      ADC	R27,R31
    0063B 938D      ST	X+,R24
    0063C 939C      ST	X,R25
    0063D 94A3      INC	R10
    0063E 2D8A      MOV	R24,R10
    0063F 3083      CPI	R24,3
    00640 F408      BCC	0x0642
    00641 CF98      RJMP	0x05DA
(0607)    }  
    00642 9622      ADIW	R28,2
    00643 940C 1AF3 JMP	pop_xgsetF03C
(0608) }  //最终溢出中断写入寄存器的值
(0609) 
(0610) //*如何换算的，作用是什么？
(0611) 
(0612) //***********************************各时间量转换为控制量************************
(0613) void init_data(void)    // void init_data() 改为void init_data(void) wsg20120907
(0614) {
(0615)   PWM_Period_value=((int)(PWM_Period_ms*1000*FLK)>>3)-1; //pwm周期 20ms换算成计数器值
_init_data:
    00645 E18F      LDI	R24,0x1F
    00646 E49E      LDI	R25,0x4E
    00647 9390 0427 STS	PWM_Period_value+1,R25
    00649 9380 0426 STS	PWM_Period_value,R24
(0616)   MiddlePosition_value=((int)(PWM_Duty_Middle_us*FLK )>>3)-1; //1500us 中间位置换成计数值
    0064B ED8B      LDI	R24,0xDB
    0064C E095      LDI	R25,5
    0064D 9390 0429 STS	MiddlePosition_value+1,R25
    0064F 9380 0428 STS	MiddlePosition_value,R24
(0617)   LeftLimit_value=((int)(PWM_Duty_LeftLimit_us*FLK)>>3)-1; //900us 左极限位置计数器值，60度  1度10us
    00651 E883      LDI	R24,0x83
    00652 E093      LDI	R25,3
    00653 9390 042D STS	LeftLimit_value+1,R25
    00655 9380 042C STS	LeftLimit_value,R24
(0618)   RightLimit_value=((int)(PWM_Duty_RightLimit_us*FLK)>>3)-1; //2100us 右极限位置计数器值，60度
    00657 E383      LDI	R24,0x33
    00658 E098      LDI	R25,0x8
    00659 9390 042B STS	RightLimit_value+1,R25
    0065B 9380 042A STS	RightLimit_value,R24
    0065D 9508      RET
_char2int:
  a_int                --> R20
  a_flag               --> R18
  a_char               --> R16
    0065E 934A      ST	-Y,R20
    0065F 935A      ST	-Y,R21
(0619) }
(0620) 	
(0621) //********************将unsigned char型数转化为int型数**************************
(0622) //flag=1时转为负数，左转；flag=0时转为正数，右转
(0623) int char2int(unsigned char a_char,unsigned char a_flag)
(0624) {
(0625)   int a_int;
(0626)   if(a_flag==0)
    00660 2322      TST	R18
    00661 F411      BNE	0x0664
(0627)   {
(0628)      a_int=a_char;
    00662 2F40      MOV	R20,R16
    00663 2755      CLR	R21
(0629)   }
(0630)   if(a_flag==1)
    00664 3021      CPI	R18,1
    00665 F431      BNE	0x066C
(0631)   {
(0632)      a_int=a_char;
    00666 2F40      MOV	R20,R16
    00667 2755      CLR	R21
(0633) 	 a_int=-a_int;
    00668 9540      COM	R20
    00669 9550      COM	R21
    0066A 5F4F      SUBI	R20,0xFF
    0066B 4F5F      SBCI	R21,0xFF
(0634)   }
(0635) return a_int;
    0066C 018A      MOVW	R16,R20
    0066D 9159      LD	R21,Y+
    0066E 9149      LD	R20,Y+
    0066F 9508      RET
_one2two:
  data_b               --> R10
  data_a               --> R18
  data_init            --> R16
    00670 92AA      ST	-Y,R10
    00671 92BA      ST	-Y,R11
    00672 80AA      LDD	R10,Y+2
    00673 80BB      LDD	R11,Y+3
(0636) }
(0637) 
(0638) 
(0639) 
(0640) //*********************一个16位数组，拆为2个8位数组****************************
(0641) //将长度为16位的数组data_init[16]拆成2个长度为8的数组
(0642) //分别为data_a[8],data_b[8]
(0643) //unsigned char型
(0644) void one2two(unsigned char *data_init,unsigned char *data_a,unsigned char *data_b)
(0645) {
(0646)   for(s=0;s<=7;s++)
    00674 2422      CLR	R2
    00675 9220 0109 STS	s,R2
    00677 C011      RJMP	0x0689
(0647)    {
(0648)    data_a[s]=data_init[s];
    00678 9030 0109 LDS	R3,s
    0067A 2DE3      MOV	R30,R3
    0067B 27FF      CLR	R31
    0067C 0FE0      ADD	R30,R16
    0067D 1FF1      ADC	R31,R17
    0067E 8020      LD	R2,Z
    0067F 2DE3      MOV	R30,R3
    00680 27FF      CLR	R31
    00681 0FE2      ADD	R30,R18
    00682 1FF3      ADC	R31,R19
    00683 8220      ST	Z,R2
    00684 9180 0109 LDS	R24,s
    00686 5F8F      SUBI	R24,0xFF
    00687 9380 0109 STS	s,R24
    00689 E087      LDI	R24,7
    0068A 9020 0109 LDS	R2,s
    0068C 1582      CP	R24,R2
    0068D F750      BCC	0x0678
(0649)    }
(0650)   for(s=8;s<=15;s++)
    0068E E088      LDI	R24,0x8
    0068F 9380 0109 STS	s,R24
    00691 C012      RJMP	0x06A4
(0651)    {
(0652)    data_b[s-8]=data_init[s];
    00692 9030 0109 LDS	R3,s
    00694 2DE3      MOV	R30,R3
    00695 27FF      CLR	R31
    00696 0FE0      ADD	R30,R16
    00697 1FF1      ADC	R31,R17
    00698 8020      LD	R2,Z
    00699 2DE3      MOV	R30,R3
    0069A 27FF      CLR	R31
    0069B 9738      SBIW	R30,0x8
    0069C 0DEA      ADD	R30,R10
    0069D 1DFB      ADC	R31,R11
    0069E 8220      ST	Z,R2
    0069F 9180 0109 LDS	R24,s
    006A1 5F8F      SUBI	R24,0xFF
    006A2 9380 0109 STS	s,R24
    006A4 E08F      LDI	R24,0xF
    006A5 9020 0109 LDS	R2,s
    006A7 1582      CP	R24,R2
    006A8 F748      BCC	0x0692
    006A9 90B9      LD	R11,Y+
    006AA 90A9      LD	R10,Y+
    006AB 9508      RET
_two2one:
  data_bb              --> R10
  data_aa              --> R18
  data_inits           --> R16
    006AC 92AA      ST	-Y,R10
    006AD 92BA      ST	-Y,R11
    006AE 80AA      LDD	R10,Y+2
    006AF 80BB      LDD	R11,Y+3
(0653)    }
(0654) }
(0655) 
(0656) //*******************将2个8位数组依顺序组成一个16位数组************************
(0657) //将2个长度为8的数组data_aa[8],data_bb[8]
(0658) //顺次组成一个长度为16位的数组data_inits[16]
(0659) //unsigned char型
(0660) void two2one(unsigned char *data_inits,unsigned char *data_aa,unsigned char *data_bb)
(0661) {
(0662)   for(s=0;s<=7;s++)
    006B0 2422      CLR	R2
    006B1 9220 0109 STS	s,R2
    006B3 C011      RJMP	0x06C5
(0663)    {
(0664)    data_inits[s]=data_aa[s];//*把data_aa数值顺次赋值给data_inits
    006B4 9030 0109 LDS	R3,s
    006B6 2DE3      MOV	R30,R3
    006B7 27FF      CLR	R31
    006B8 0FE2      ADD	R30,R18
    006B9 1FF3      ADC	R31,R19
    006BA 8020      LD	R2,Z
    006BB 2DE3      MOV	R30,R3
    006BC 27FF      CLR	R31
    006BD 0FE0      ADD	R30,R16
    006BE 1FF1      ADC	R31,R17
    006BF 8220      ST	Z,R2
    006C0 9180 0109 LDS	R24,s
    006C2 5F8F      SUBI	R24,0xFF
    006C3 9380 0109 STS	s,R24
    006C5 E087      LDI	R24,7
    006C6 9020 0109 LDS	R2,s
    006C8 1582      CP	R24,R2
    006C9 F750      BCC	0x06B4
(0665)    }
(0666)   for(s=0;s<=7;s++)
    006CA 2422      CLR	R2
    006CB 9220 0109 STS	s,R2
    006CD C011      RJMP	0x06DF
(0667)    {
(0668)    data_inits[s+8]=data_bb[s];//*把data_bb数值顺次赋值给data_bb的高八位
    006CE 9030 0109 LDS	R3,s
    006D0 2DE3      MOV	R30,R3
    006D1 27FF      CLR	R31
    006D2 0DEA      ADD	R30,R10
    006D3 1DFB      ADC	R31,R11
    006D4 8020      LD	R2,Z
    006D5 2DE3      MOV	R30,R3
    006D6 27FF      CLR	R31
    006D7 0FE0      ADD	R30,R16
    006D8 1FF1      ADC	R31,R17
    006D9 8620      STD	Z+8,R2
    006DA 9180 0109 LDS	R24,s
    006DC 5F8F      SUBI	R24,0xFF
    006DD 9380 0109 STS	s,R24
    006DF E087      LDI	R24,7
    006E0 9020 0109 LDS	R2,s
    006E2 1582      CP	R24,R2
    006E3 F750      BCC	0x06CE
    006E4 90B9      LD	R11,Y+
    006E5 90A9      LD	R10,Y+
    006E6 9508      RET
_one2three:
  data_c               --> R10
  data_b               --> R12
  data_a               --> R18
  data_init            --> R16
    006E7 940E 1ACD CALL	push_xgset003C
    006E9 80CC      LDD	R12,Y+4
    006EA 80DD      LDD	R13,Y+5
    006EB 80AE      LDD	R10,Y+6
    006EC 80BF      LDD	R11,Y+7
(0669)    }
(0670) }
(0671) 
(0672) //*********************一个24位数组，拆为3个8位数组****************************
(0673) //将长度为32位的数组data_init[24]拆成3个长度为8的数组
(0674) //分别为data_a[8],data_b[8],data_c[8]
(0675) //unsigned char型
(0676) void one2three(unsigned char *data_init,unsigned char *data_a,unsigned char *data_b,unsigned char *data_c)
(0677) {
(0678)   for(s=0;s<=7;s++)
    006ED 2422      CLR	R2
    006EE 9220 0109 STS	s,R2
    006F0 C011      RJMP	0x0702
(0679)    {
(0680)    data_a[s]=data_init[s];//*把data_init[]的前八位形成一个新的数组data_a[]
    006F1 9030 0109 LDS	R3,s
    006F3 2DE3      MOV	R30,R3
    006F4 27FF      CLR	R31
    006F5 0FE0      ADD	R30,R16
    006F6 1FF1      ADC	R31,R17
    006F7 8020      LD	R2,Z
    006F8 2DE3      MOV	R30,R3
    006F9 27FF      CLR	R31
    006FA 0FE2      ADD	R30,R18
    006FB 1FF3      ADC	R31,R19
    006FC 8220      ST	Z,R2
    006FD 9180 0109 LDS	R24,s
    006FF 5F8F      SUBI	R24,0xFF
    00700 9380 0109 STS	s,R24
    00702 E087      LDI	R24,7
    00703 9020 0109 LDS	R2,s
    00705 1582      CP	R24,R2
    00706 F750      BCC	0x06F1
(0681)    }
(0682)   for(s=8;s<=15;s++)
    00707 E088      LDI	R24,0x8
    00708 9380 0109 STS	s,R24
    0070A C012      RJMP	0x071D
(0683)    {
(0684)    data_b[s-8]=data_init[s];//*把data_init[]第九位到第十六位形成一个新的数组data_b[]
    0070B 9030 0109 LDS	R3,s
    0070D 2DE3      MOV	R30,R3
    0070E 27FF      CLR	R31
    0070F 0FE0      ADD	R30,R16
    00710 1FF1      ADC	R31,R17
    00711 8020      LD	R2,Z
    00712 2DE3      MOV	R30,R3
    00713 27FF      CLR	R31
    00714 9738      SBIW	R30,0x8
    00715 0DEC      ADD	R30,R12
    00716 1DFD      ADC	R31,R13
    00717 8220      ST	Z,R2
    00718 9180 0109 LDS	R24,s
    0071A 5F8F      SUBI	R24,0xFF
    0071B 9380 0109 STS	s,R24
    0071D E08F      LDI	R24,0xF
    0071E 9020 0109 LDS	R2,s
    00720 1582      CP	R24,R2
    00721 F748      BCC	0x070B
(0685)    }
(0686)   for(s=16;s<=23;s++)
    00722 E180      LDI	R24,0x10
    00723 9380 0109 STS	s,R24
    00725 C012      RJMP	0x0738
(0687)    {
(0688)    data_c[s-16]=data_init[s];//*把data_init[]第十七位到到第二十四位形成一个新的数组data_c[]
    00726 90C0 0109 LDS	R12,s
    00728 2DEC      MOV	R30,R12
    00729 27FF      CLR	R31
    0072A 0FE0      ADD	R30,R16
    0072B 1FF1      ADC	R31,R17
    0072C 8020      LD	R2,Z
    0072D 2DEC      MOV	R30,R12
    0072E 27FF      CLR	R31
    0072F 9770      SBIW	R30,0x10
    00730 0DEA      ADD	R30,R10
    00731 1DFB      ADC	R31,R11
    00732 8220      ST	Z,R2
    00733 9180 0109 LDS	R24,s
    00735 5F8F      SUBI	R24,0xFF
    00736 9380 0109 STS	s,R24
    00738 E187      LDI	R24,0x17
    00739 9020 0109 LDS	R2,s
    0073B 1582      CP	R24,R2
    0073C F748      BCC	0x0726
    0073D 940C 1AB0 JMP	pop_xgset003C
_three2one:
  data_cc              --> R10
  data_bb              --> R12
  data_aa              --> R18
  data_inits           --> R16
    0073F 940E 1ACD CALL	push_xgset003C
    00741 80CC      LDD	R12,Y+4
    00742 80DD      LDD	R13,Y+5
    00743 80AE      LDD	R10,Y+6
    00744 80BF      LDD	R11,Y+7
(0689)    }
(0690) }
(0691) 
(0692) //*******************将3个8位数组依顺序组成一个24位数组************************
(0693) //将3个长度为24的数组data_aa[8],data_bb[8],data_cc[8]
(0694) //顺次组成一个长度为32位的数组data_inits[32]
(0695) //unsigned char型
(0696) void three2one(unsigned char *data_inits,unsigned char *data_aa,unsigned char *data_bb,unsigned char *data_cc)
(0697) {
(0698)   for(s=0;s<=7;s++)
    00745 2422      CLR	R2
    00746 9220 0109 STS	s,R2
    00748 C011      RJMP	0x075A
(0699)    {
(0700)    data_inits[s]=data_aa[s];
    00749 9030 0109 LDS	R3,s
    0074B 2DE3      MOV	R30,R3
    0074C 27FF      CLR	R31
    0074D 0FE2      ADD	R30,R18
    0074E 1FF3      ADC	R31,R19
    0074F 8020      LD	R2,Z
    00750 2DE3      MOV	R30,R3
    00751 27FF      CLR	R31
    00752 0FE0      ADD	R30,R16
    00753 1FF1      ADC	R31,R17
    00754 8220      ST	Z,R2
    00755 9180 0109 LDS	R24,s
    00757 5F8F      SUBI	R24,0xFF
    00758 9380 0109 STS	s,R24
    0075A E087      LDI	R24,7
    0075B 9020 0109 LDS	R2,s
    0075D 1582      CP	R24,R2
    0075E F750      BCC	0x0749
(0701)    }
(0702)   for(s=0;s<=7;s++)
    0075F 2422      CLR	R2
    00760 9220 0109 STS	s,R2
    00762 C011      RJMP	0x0774
(0703)    {
(0704)    data_inits[s+8]=data_bb[s];
    00763 9030 0109 LDS	R3,s
    00765 2DE3      MOV	R30,R3
    00766 27FF      CLR	R31
    00767 0DEC      ADD	R30,R12
    00768 1DFD      ADC	R31,R13
    00769 8020      LD	R2,Z
    0076A 2DE3      MOV	R30,R3
    0076B 27FF      CLR	R31
    0076C 0FE0      ADD	R30,R16
    0076D 1FF1      ADC	R31,R17
    0076E 8620      STD	Z+8,R2
    0076F 9180 0109 LDS	R24,s
    00771 5F8F      SUBI	R24,0xFF
    00772 9380 0109 STS	s,R24
    00774 E087      LDI	R24,7
    00775 9020 0109 LDS	R2,s
    00777 1582      CP	R24,R2
    00778 F750      BCC	0x0763
(0705)    }
(0706)   for(s=0;s<=7;s++)
    00779 2422      CLR	R2
    0077A 9220 0109 STS	s,R2
    0077C C011      RJMP	0x078E
(0707)    {
(0708)    data_inits[s+16]=data_cc[s];
    0077D 90C0 0109 LDS	R12,s
    0077F 2DEC      MOV	R30,R12
    00780 27FF      CLR	R31
    00781 0DEA      ADD	R30,R10
    00782 1DFB      ADC	R31,R11
    00783 8020      LD	R2,Z
    00784 2DEC      MOV	R30,R12
    00785 27FF      CLR	R31
    00786 0FE0      ADD	R30,R16
    00787 1FF1      ADC	R31,R17
    00788 8A20      STD	Z+16,R2
    00789 9180 0109 LDS	R24,s
    0078B 5F8F      SUBI	R24,0xFF
    0078C 9380 0109 STS	s,R24
    0078E E087      LDI	R24,7
    0078F 9020 0109 LDS	R2,s
    00791 1582      CP	R24,R2
    00792 F750      BCC	0x077D
    00793 940C 1AB0 JMP	pop_xgset003C
_one2six:
  data_f               --> R10
  data_e               --> R12
  data_d               --> R14
  data_c               --> R20
  data_b               --> R22
  data_a               --> R18
  data_init            --> R16
    00795 940E 1AC7 CALL	push_xgsetF0FC
    00797 856A      LDD	R22,Y+10
    00798 857B      LDD	R23,Y+11
    00799 854C      LDD	R20,Y+12
    0079A 855D      LDD	R21,Y+13
    0079B 84EE      LDD	R14,Y+14
    0079C 84FF      LDD	R15,Y+15
    0079D 88C8      LDD	R12,Y+16
    0079E 88D9      LDD	R13,Y+17
    0079F 88AA      LDD	R10,Y+18
    007A0 88BB      LDD	R11,Y+19
(0709)    }
(0710) }
(0711) 
(0712) 
(0713) //*********************一个48位数组，拆为6个8位数组****************************
(0714) //将长度为48位的数组data_init[48]拆成6个长度为8的数组
(0715) //分别为data_a[8],data_b[8],data_c[8],data_d[8],data_e[8],data_f[8]
(0716) //unsigned char型
(0717) void one2six(unsigned char *data_init,unsigned char *data_a,unsigned char *data_b,unsigned char *data_c,unsigned char *data_d,unsigned char *data_e,unsigned char *data_f)
(0718) {
(0719)   for(s=0;s<=7;s++)
    007A1 2422      CLR	R2
    007A2 9220 0109 STS	s,R2
    007A4 C011      RJMP	0x07B6
(0720)    {
(0721)    data_a[s]=data_init[s];
    007A5 9030 0109 LDS	R3,s
    007A7 2DE3      MOV	R30,R3
    007A8 27FF      CLR	R31
    007A9 0FE0      ADD	R30,R16
    007AA 1FF1      ADC	R31,R17
    007AB 8020      LD	R2,Z
    007AC 2DE3      MOV	R30,R3
    007AD 27FF      CLR	R31
    007AE 0FE2      ADD	R30,R18
    007AF 1FF3      ADC	R31,R19
    007B0 8220      ST	Z,R2
    007B1 9180 0109 LDS	R24,s
    007B3 5F8F      SUBI	R24,0xFF
    007B4 9380 0109 STS	s,R24
    007B6 E087      LDI	R24,7
    007B7 9020 0109 LDS	R2,s
    007B9 1582      CP	R24,R2
    007BA F750      BCC	0x07A5
(0722)    }
(0723)   for(s=8;s<=15;s++)
    007BB E088      LDI	R24,0x8
    007BC 9380 0109 STS	s,R24
    007BE C012      RJMP	0x07D1
(0724)    {
(0725)    data_b[s-8]=data_init[s];
    007BF 9030 0109 LDS	R3,s
    007C1 2DE3      MOV	R30,R3
    007C2 27FF      CLR	R31
    007C3 0FE0      ADD	R30,R16
    007C4 1FF1      ADC	R31,R17
    007C5 8020      LD	R2,Z
    007C6 2DE3      MOV	R30,R3
    007C7 27FF      CLR	R31
    007C8 9738      SBIW	R30,0x8
    007C9 0FE6      ADD	R30,R22
    007CA 1FF7      ADC	R31,R23
    007CB 8220      ST	Z,R2
    007CC 9180 0109 LDS	R24,s
    007CE 5F8F      SUBI	R24,0xFF
    007CF 9380 0109 STS	s,R24
    007D1 E08F      LDI	R24,0xF
    007D2 9020 0109 LDS	R2,s
    007D4 1582      CP	R24,R2
    007D5 F748      BCC	0x07BF
(0726)    }
(0727)   for(s=16;s<=23;s++)
    007D6 E180      LDI	R24,0x10
    007D7 9380 0109 STS	s,R24
    007D9 C012      RJMP	0x07EC
(0728)    {
(0729)    data_c[s-16]=data_init[s];
    007DA 9160 0109 LDS	R22,s
    007DC 2FE6      MOV	R30,R22
    007DD 27FF      CLR	R31
    007DE 0FE0      ADD	R30,R16
    007DF 1FF1      ADC	R31,R17
    007E0 8020      LD	R2,Z
    007E1 2FE6      MOV	R30,R22
    007E2 27FF      CLR	R31
    007E3 9770      SBIW	R30,0x10
    007E4 0FE4      ADD	R30,R20
    007E5 1FF5      ADC	R31,R21
    007E6 8220      ST	Z,R2
    007E7 9180 0109 LDS	R24,s
    007E9 5F8F      SUBI	R24,0xFF
    007EA 9380 0109 STS	s,R24
    007EC E187      LDI	R24,0x17
    007ED 9020 0109 LDS	R2,s
    007EF 1582      CP	R24,R2
    007F0 F748      BCC	0x07DA
(0730)    }
(0731)   for(s=24;s<=31;s++)
    007F1 E188      LDI	R24,0x18
    007F2 9380 0109 STS	s,R24
    007F4 C012      RJMP	0x0807
(0732)    {
(0733)    data_d[s-24]=data_init[s];
    007F5 9140 0109 LDS	R20,s
    007F7 2FE4      MOV	R30,R20
    007F8 27FF      CLR	R31
    007F9 0FE0      ADD	R30,R16
    007FA 1FF1      ADC	R31,R17
    007FB 8020      LD	R2,Z
    007FC 2FE4      MOV	R30,R20
    007FD 27FF      CLR	R31
    007FE 9778      SBIW	R30,0x18
    007FF 0DEE      ADD	R30,R14
    00800 1DFF      ADC	R31,R15
    00801 8220      ST	Z,R2
    00802 9180 0109 LDS	R24,s
    00804 5F8F      SUBI	R24,0xFF
    00805 9380 0109 STS	s,R24
    00807 E18F      LDI	R24,0x1F
    00808 9020 0109 LDS	R2,s
    0080A 1582      CP	R24,R2
    0080B F748      BCC	0x07F5
(0734)    }
(0735)   for(s=32;s<=39;s++)
    0080C E280      LDI	R24,0x20
    0080D 9380 0109 STS	s,R24
    0080F C012      RJMP	0x0822
(0736)    {
(0737)    data_e[s-32]=data_init[s];
    00810 90E0 0109 LDS	R14,s
    00812 2DEE      MOV	R30,R14
    00813 27FF      CLR	R31
    00814 0FE0      ADD	R30,R16
    00815 1FF1      ADC	R31,R17
    00816 8020      LD	R2,Z
    00817 2DEE      MOV	R30,R14
    00818 27FF      CLR	R31
    00819 97B0      SBIW	R30,0x20
    0081A 0DEC      ADD	R30,R12
    0081B 1DFD      ADC	R31,R13
    0081C 8220      ST	Z,R2
    0081D 9180 0109 LDS	R24,s
    0081F 5F8F      SUBI	R24,0xFF
    00820 9380 0109 STS	s,R24
    00822 E287      LDI	R24,0x27
    00823 9020 0109 LDS	R2,s
    00825 1582      CP	R24,R2
    00826 F748      BCC	0x0810
(0738)    }
(0739)   for(s=40;s<=47;s++)
    00827 E288      LDI	R24,0x28
    00828 9380 0109 STS	s,R24
    0082A C012      RJMP	0x083D
(0740)    {
(0741)    data_f[s-40]=data_init[s];
    0082B 90C0 0109 LDS	R12,s
    0082D 2DEC      MOV	R30,R12
    0082E 27FF      CLR	R31
    0082F 0FE0      ADD	R30,R16
    00830 1FF1      ADC	R31,R17
    00831 8020      LD	R2,Z
    00832 2DEC      MOV	R30,R12
    00833 27FF      CLR	R31
    00834 97B8      SBIW	R30,0x28
    00835 0DEA      ADD	R30,R10
    00836 1DFB      ADC	R31,R11
    00837 8220      ST	Z,R2
    00838 9180 0109 LDS	R24,s
    0083A 5F8F      SUBI	R24,0xFF
    0083B 9380 0109 STS	s,R24
    0083D E28F      LDI	R24,0x2F
    0083E 9020 0109 LDS	R2,s
    00840 1582      CP	R24,R2
    00841 F748      BCC	0x082B
    00842 940C 1ABC JMP	pop_xgsetF0FC
_six2one:
  data_ff              --> R10
  data_ee              --> R12
  data_dd              --> R14
  data_cc              --> R20
  data_bb              --> R22
  data_aa              --> R18
  data_inits           --> R16
    00844 940E 1AC7 CALL	push_xgsetF0FC
    00846 856A      LDD	R22,Y+10
    00847 857B      LDD	R23,Y+11
    00848 854C      LDD	R20,Y+12
    00849 855D      LDD	R21,Y+13
    0084A 84EE      LDD	R14,Y+14
    0084B 84FF      LDD	R15,Y+15
    0084C 88C8      LDD	R12,Y+16
    0084D 88D9      LDD	R13,Y+17
    0084E 88AA      LDD	R10,Y+18
    0084F 88BB      LDD	R11,Y+19
(0742)    }
(0743) }
(0744) 
(0745) //*******************将6个8位数组依顺序组成一个48位数组************************
(0746) //将6个长度为8的数组data_aa[8],data_bb[8],data_cc[8],data_dd[8]
(0747) //顺次组成一个长度为48位的数组data_inits[48]
(0748) //unsigned char型
(0749) void six2one(unsigned char *data_inits,unsigned char *data_aa,unsigned char *data_bb,unsigned char *data_cc,unsigned char *data_dd,unsigned char *data_ee,unsigned char *data_ff)
(0750) {
(0751)   for(s=0;s<=7;s++)
    00850 2422      CLR	R2
    00851 9220 0109 STS	s,R2
    00853 C011      RJMP	0x0865
(0752)    {
(0753)    data_inits[s]=data_aa[s];
    00854 9030 0109 LDS	R3,s
    00856 2DE3      MOV	R30,R3
    00857 27FF      CLR	R31
    00858 0FE2      ADD	R30,R18
    00859 1FF3      ADC	R31,R19
    0085A 8020      LD	R2,Z
    0085B 2DE3      MOV	R30,R3
    0085C 27FF      CLR	R31
    0085D 0FE0      ADD	R30,R16
    0085E 1FF1      ADC	R31,R17
    0085F 8220      ST	Z,R2
    00860 9180 0109 LDS	R24,s
    00862 5F8F      SUBI	R24,0xFF
    00863 9380 0109 STS	s,R24
    00865 E087      LDI	R24,7
    00866 9020 0109 LDS	R2,s
    00868 1582      CP	R24,R2
    00869 F750      BCC	0x0854
(0754)    }
(0755)   for(s=0;s<=7;s++)
    0086A 2422      CLR	R2
    0086B 9220 0109 STS	s,R2
    0086D C011      RJMP	0x087F
(0756)    {
(0757)    data_inits[s+8]=data_bb[s];
    0086E 9030 0109 LDS	R3,s
    00870 2DE3      MOV	R30,R3
    00871 27FF      CLR	R31
    00872 0FE6      ADD	R30,R22
    00873 1FF7      ADC	R31,R23
    00874 8020      LD	R2,Z
    00875 2DE3      MOV	R30,R3
    00876 27FF      CLR	R31
    00877 0FE0      ADD	R30,R16
    00878 1FF1      ADC	R31,R17
    00879 8620      STD	Z+8,R2
    0087A 9180 0109 LDS	R24,s
    0087C 5F8F      SUBI	R24,0xFF
    0087D 9380 0109 STS	s,R24
    0087F E087      LDI	R24,7
    00880 9020 0109 LDS	R2,s
    00882 1582      CP	R24,R2
    00883 F750      BCC	0x086E
(0758)    }
(0759)   for(s=0;s<=7;s++)
    00884 2422      CLR	R2
    00885 9220 0109 STS	s,R2
    00887 C011      RJMP	0x0899
(0760)    {
(0761)    data_inits[s+16]=data_cc[s];
    00888 9160 0109 LDS	R22,s
    0088A 2FE6      MOV	R30,R22
    0088B 27FF      CLR	R31
    0088C 0FE4      ADD	R30,R20
    0088D 1FF5      ADC	R31,R21
    0088E 8020      LD	R2,Z
    0088F 2FE6      MOV	R30,R22
    00890 27FF      CLR	R31
    00891 0FE0      ADD	R30,R16
    00892 1FF1      ADC	R31,R17
    00893 8A20      STD	Z+16,R2
    00894 9180 0109 LDS	R24,s
    00896 5F8F      SUBI	R24,0xFF
    00897 9380 0109 STS	s,R24
    00899 E087      LDI	R24,7
    0089A 9020 0109 LDS	R2,s
    0089C 1582      CP	R24,R2
    0089D F750      BCC	0x0888
(0762)    }
(0763)   for(s=0;s<=7;s++)
    0089E 2422      CLR	R2
    0089F 9220 0109 STS	s,R2
    008A1 C011      RJMP	0x08B3
(0764)    {
(0765)    data_inits[s+24]=data_dd[s];
    008A2 9140 0109 LDS	R20,s
    008A4 2FE4      MOV	R30,R20
    008A5 27FF      CLR	R31
    008A6 0DEE      ADD	R30,R14
    008A7 1DFF      ADC	R31,R15
    008A8 8020      LD	R2,Z
    008A9 2FE4      MOV	R30,R20
    008AA 27FF      CLR	R31
    008AB 0FE0      ADD	R30,R16
    008AC 1FF1      ADC	R31,R17
    008AD 8E20      STD	Z+24,R2
    008AE 9180 0109 LDS	R24,s
    008B0 5F8F      SUBI	R24,0xFF
    008B1 9380 0109 STS	s,R24
    008B3 E087      LDI	R24,7
    008B4 9020 0109 LDS	R2,s
    008B6 1582      CP	R24,R2
    008B7 F750      BCC	0x08A2
(0766)    }
(0767)   for(s=0;s<=7;s++)
    008B8 2422      CLR	R2
    008B9 9220 0109 STS	s,R2
    008BB C011      RJMP	0x08CD
(0768)    {
(0769)    data_inits[s+32]=data_ee[s];
    008BC 90E0 0109 LDS	R14,s
    008BE 2DEE      MOV	R30,R14
    008BF 27FF      CLR	R31
    008C0 0DEC      ADD	R30,R12
    008C1 1DFD      ADC	R31,R13
    008C2 8020      LD	R2,Z
    008C3 2DEE      MOV	R30,R14
    008C4 27FF      CLR	R31
    008C5 0FE0      ADD	R30,R16
    008C6 1FF1      ADC	R31,R17
    008C7 A220      STD	Z+32,R2
    008C8 9180 0109 LDS	R24,s
    008CA 5F8F      SUBI	R24,0xFF
    008CB 9380 0109 STS	s,R24
    008CD E087      LDI	R24,7
    008CE 9020 0109 LDS	R2,s
    008D0 1582      CP	R24,R2
    008D1 F750      BCC	0x08BC
(0770)    }
(0771)   for(s=0;s<=7;s++)
    008D2 2422      CLR	R2
    008D3 9220 0109 STS	s,R2
    008D5 C011      RJMP	0x08E7
(0772)    {
(0773)    data_inits[s+40]=data_ff[s];
    008D6 90C0 0109 LDS	R12,s
    008D8 2DEC      MOV	R30,R12
    008D9 27FF      CLR	R31
    008DA 0DEA      ADD	R30,R10
    008DB 1DFB      ADC	R31,R11
    008DC 8020      LD	R2,Z
    008DD 2DEC      MOV	R30,R12
    008DE 27FF      CLR	R31
    008DF 0FE0      ADD	R30,R16
    008E0 1FF1      ADC	R31,R17
    008E1 A620      STD	Z+40,R2
    008E2 9180 0109 LDS	R24,s
    008E4 5F8F      SUBI	R24,0xFF
    008E5 9380 0109 STS	s,R24
    008E7 E087      LDI	R24,7
    008E8 9020 0109 LDS	R2,s
    008EA 1582      CP	R24,R2
    008EB F750      BCC	0x08D6
    008EC 940C 1ABC JMP	pop_xgsetF0FC
_change_dd:
  dd_c                 --> R10
  d_c                  --> R16
    008EE 92AA      ST	-Y,R10
(0774)    }
(0775) }
(0776) 
(0777) 
(0778) 
(0779) // d_tem 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15 //7前左，后右
(0780) //dd_tem 0  1  2  3  4  5  6  7  6  5  4   3   2   1   0   0 //加负号左
(0781) //********************幅度档d_tem转化为左右统一的dd_tem****************
(0782) //flag_c=1时，左转d_c小于7，加负号，flag_c=0，右转d_c大于等于7
(0783) unsigned char change_dd(unsigned char d_c)
(0784) {
(0785)    unsigned char dd_c;
(0786)    if((d_c>=0)&&(d_c<=7))
    008EF 3000      CPI	R16,0
    008F0 F020      BCS	0x08F5
    008F1 E087      LDI	R24,7
    008F2 1780      CP	R24,R16
    008F3 F008      BCS	0x08F5
(0787)    {
(0788)      dd_c=d_c;
    008F4 2EA0      MOV	R10,R16
(0789)    }
(0790)    if((d_c>=7)&&(d_c<=14))
    008F5 3007      CPI	R16,7
    008F6 F040      BCS	0x08FF
    008F7 E08E      LDI	R24,0xE
    008F8 1780      CP	R24,R16
    008F9 F028      BCS	0x08FF
(0791)    {
(0792)      dd_c=7-(d_c-7);//14-d_c
    008FA 2F80      MOV	R24,R16
    008FB 5087      SUBI	R24,7
    008FC E097      LDI	R25,7
    008FD 2EA9      MOV	R10,R25
    008FE 1AA8      SUB	R10,R24
(0793)    }
(0794)    if(d_c==15)
    008FF 300F      CPI	R16,0xF
    00900 F409      BNE	0x0902
(0795)    {
(0796)      dd_c=0;
    00901 24AA      CLR	R10
(0797)    }
(0798) return dd_c;
    00902 2D0A      MOV	R16,R10
    00903 90A9      LD	R10,Y+
    00904 9508      RET
_change_flag:
  flag_c               --> R20
  d_c                  --> R16
    00905 934A      ST	-Y,R20
(0799) }
(0800) unsigned char change_flag(unsigned char d_c)
(0801) {
(0802)    unsigned char flag_c;
(0803)    if(d_c<=6)
    00906 E086      LDI	R24,6
    00907 1780      CP	R24,R16
    00908 F010      BCS	0x090B
(0804)    {
(0805)    flag_c=1;
    00909 E041      LDI	R20,1
(0806)    }
    0090A C001      RJMP	0x090C
(0807)    else
(0808)    {
(0809)    flag_c=0;
    0090B 2744      CLR	R20
(0810)    }
(0811)    return flag_c;
    0090C 2F04      MOV	R16,R20
    0090D 9149      LD	R20,Y+
    0090E 9508      RET
_i2c_write:
  i                    --> R10
  data_l               --> R22
  data_tem             --> R12
  data_i2c             --> R20
  i2c_address          --> R14
    0090F 940E 1AC7 CALL	push_xgsetF0FC
    00911 01A9      MOVW	R20,R18
    00912 2EE0      MOV	R14,R16
    00913 84CA      LDD	R12,Y+10
    00914 84DB      LDD	R13,Y+11
    00915 856C      LDD	R22,Y+12
(0812) }
(0813) 
(0814) 
(0815) //********************************读写i2c****************************************
(0816) //写i2c
(0817) //将长度为data_l的data_tem数组写入地址为i2c_address的data_i2c数组
(0818) //unsigend char型
(0819) void i2c_write(unsigned char i2c_address,unsigned char *data_i2c,unsigned char *data_tem,unsigned char data_l)
(0820) {
(0821)       int i=0;
(0822) 	  data_i2c[0]=SLA_W;
    00916 EA80      LDI	R24,0xA0
    00917 01FA      MOVW	R30,R20
    00918 8380      ST	Z,R24
(0823) 	  data_i2c[1]=i2c_address;
    00919 82E1      STD	Z+1,R14
(0824) 	  for(i=0;i<=data_l-1;i++)
    0091A 24AA      CLR	R10
    0091B 24BB      CLR	R11
    0091C C00B      RJMP	0x0928
(0825) 	  {
(0826) 	     data_i2c[i+2]=data_tem[i];
    0091D 01F5      MOVW	R30,R10
    0091E 0DEC      ADD	R30,R12
    0091F 1DFD      ADC	R31,R13
    00920 8020      LD	R2,Z
    00921 01F5      MOVW	R30,R10
    00922 0FE4      ADD	R30,R20
    00923 1FF5      ADC	R31,R21
    00924 8222      STD	Z+2,R2
    00925 01C5      MOVW	R24,R10
    00926 9601      ADIW	R24,1
    00927 015C      MOVW	R10,R24
    00928 2F86      MOV	R24,R22
    00929 2799      CLR	R25
    0092A 9701      SBIW	R24,1
    0092B 158A      CP	R24,R10
    0092C 059B      CPC	R25,R11
    0092D F77C      BGE	0x091D
(0827) 	  }
(0828) 	  TWI_Start_Transceiver_With_Data(data_i2c,data_l+2);
    0092E 2F26      MOV	R18,R22
    0092F 5F2E      SUBI	R18,0xFE
    00930 018A      MOVW	R16,R20
    00931 940E 1902 CALL	_TWI_Start_Transceiver_With_Data
    00933 940C 1ABC JMP	pop_xgsetF0FC
_i2c_read:
  i                    --> R20
  data_l               --> R10
  data_tem             --> R12
  data_i2c             --> R22
  i2c_address          --> R14
    00935 940E 1AC7 CALL	push_xgsetF0FC
    00937 01B9      MOVW	R22,R18
    00938 2EE0      MOV	R14,R16
    00939 84CA      LDD	R12,Y+10
    0093A 84DB      LDD	R13,Y+11
    0093B 84AC      LDD	R10,Y+12
(0829) }
(0830) 
(0831) //读i2c
(0832) //将长度为data_l的地址为i2c_address的data_i2c数组读出到data_tem
(0833) //unsigned char型
(0834) void i2c_read(unsigned char i2c_address,unsigned char *data_i2c,unsigned char *data_tem,unsigned char data_l)
(0835) {
(0836)       int i=0;
(0837) 	  data_i2c[0]=SLA_W;
    0093C EA80      LDI	R24,0xA0
    0093D 01FB      MOVW	R30,R22
    0093E 8380      ST	Z,R24
(0838) 	  data_i2c[1]=i2c_address;
    0093F 82E1      STD	Z+1,R14
(0839) 	  TWI_Start_Transceiver_With_Data(data_i2c,2);
    00940 E022      LDI	R18,2
    00941 018F      MOVW	R16,R30
    00942 940E 1902 CALL	_TWI_Start_Transceiver_With_Data
(0840) 	  data_i2c[0]=SLA_R;
    00944 EA81      LDI	R24,0xA1
    00945 01FB      MOVW	R30,R22
    00946 8380      ST	Z,R24
(0841) 	  TWI_Start_Transceiver_With_Data(data_i2c,data_l+1);
    00947 2D2A      MOV	R18,R10
    00948 5F2F      SUBI	R18,0xFF
    00949 018F      MOVW	R16,R30
    0094A 940E 1902 CALL	_TWI_Start_Transceiver_With_Data
(0842) 	  TWI_Get_Data_From_Transceiver(data_i2c,data_l+1);
    0094C 2D2A      MOV	R18,R10
    0094D 5F2F      SUBI	R18,0xFF
    0094E 018B      MOVW	R16,R22
    0094F 940E 193A CALL	_TWI_Get_Data_From_Transceiver
(0843) 	  for(i=0;i<=data_l-1;i++)
    00951 2744      CLR	R20
    00952 2755      CLR	R21
    00953 C00A      RJMP	0x095E
(0844) 	  {
(0845) 	     data_tem[i]=data_i2c[i+1];
    00954 01FA      MOVW	R30,R20
    00955 0FE6      ADD	R30,R22
    00956 1FF7      ADC	R31,R23
    00957 8021      LDD	R2,Z+1
    00958 01FA      MOVW	R30,R20
    00959 0DEC      ADD	R30,R12
    0095A 1DFD      ADC	R31,R13
    0095B 8220      ST	Z,R2
    0095C 5F4F      SUBI	R20,0xFF
    0095D 4F5F      SBCI	R21,0xFF
    0095E 2D8A      MOV	R24,R10
    0095F 2799      CLR	R25
    00960 9701      SBIW	R24,1
    00961 1784      CP	R24,R20
    00962 0795      CPC	R25,R21
    00963 F784      BGE	0x0954
    00964 940C 1ABC JMP	pop_xgsetF0FC
_i2c_init:
  i                    --> R20
    00966 934A      ST	-Y,R20
    00967 935A      ST	-Y,R21
    00968 972A      SBIW	R28,0xA
(0846) 	  }			    	
(0847) }
(0848) 
(0849) 
(0850) //***********************第一次使用i2c，数据初始化*******************************
(0851) void i2c_init(void)
(0852) {	
(0853)       int i;
(0854) 	  senddata(0xab);
    00969 EA0B      LDI	R16,0xAB
    0096A D95F      RCALL	_senddata
(0855) 	  switch(redata_i2c&0x0f)
    0096B 9140 0423 LDS	R20,redata_i2c
    0096D 2755      CLR	R21
    0096E 704F      ANDI	R20,0xF
    0096F 7050      ANDI	R21,0
    00970 3041      CPI	R20,1
    00971 E0E0      LDI	R30,0
    00972 075E      CPC	R21,R30
    00973 F409      BNE	0x0975
    00974 C038      RJMP	0x09AD
    00975 3042      CPI	R20,2
    00976 E0E0      LDI	R30,0
    00977 075E      CPC	R21,R30
    00978 F409      BNE	0x097A
    00979 C03E      RJMP	0x09B8
    0097A 3043      CPI	R20,3
    0097B E0E0      LDI	R30,0
    0097C 075E      CPC	R21,R30
    0097D F409      BNE	0x097F
    0097E C044      RJMP	0x09C3
    0097F 3044      CPI	R20,4
    00980 E0E0      LDI	R30,0
    00981 075E      CPC	R21,R30
    00982 F409      BNE	0x0984
    00983 C04A      RJMP	0x09CE
    00984 3045      CPI	R20,5
    00985 E0E0      LDI	R30,0
    00986 075E      CPC	R21,R30
    00987 F409      BNE	0x0989
    00988 C066      RJMP	0x09EF
    00989 3046      CPI	R20,6
    0098A E0E0      LDI	R30,0
    0098B 075E      CPC	R21,R30
    0098C F409      BNE	0x098E
    0098D C06C      RJMP	0x09FA
    0098E 3047      CPI	R20,7
    0098F E0E0      LDI	R30,0
    00990 075E      CPC	R21,R30
    00991 F409      BNE	0x0993
    00992 C098      RJMP	0x0A2B
    00993 3048      CPI	R20,0x8
    00994 E0E0      LDI	R30,0
    00995 075E      CPC	R21,R30
    00996 F409      BNE	0x0998
    00997 C0AB      RJMP	0x0A43
    00998 3049      CPI	R20,0x9
    00999 E0E0      LDI	R30,0
    0099A 075E      CPC	R21,R30
    0099B F409      BNE	0x099D
    0099C C0B1      RJMP	0x0A4E
    0099D 304A      CPI	R20,0xA
    0099E E0E0      LDI	R30,0
    0099F 075E      CPC	R21,R30
    009A0 F409      BNE	0x09A2
    009A1 C0B7      RJMP	0x0A59
    009A2 304B      CPI	R20,0xB
    009A3 E0E0      LDI	R30,0
    009A4 075E      CPC	R21,R30
    009A5 F409      BNE	0x09A7
    009A6 C0CA      RJMP	0x0A71
    009A7 304C      CPI	R20,0xC
    009A8 E0E0      LDI	R30,0
    009A9 075E      CPC	R21,R30
    009AA F409      BNE	0x09AC
    009AB C0DE      RJMP	0x0A8A
    009AC C20E      RJMP	0x0BBB
(0856) 	  {
(0857) 	    case 0x01://FISHID 设为0x01;
(0858) 		          i2c_write(ADD_i,FISHID_I2C,FISHID_init,1); 
    009AD E081      LDI	R24,1
    009AE 838A      STD	Y+2,R24
    009AF E08B      LDI	R24,0xB
    009B0 E091      LDI	R25,1
    009B1 8399      STD	Y+1,R25
    009B2 8388      ST	Y,R24
    009B3 E02C      LDI	R18,0xC
    009B4 E031      LDI	R19,1
    009B5 E100      LDI	R16,0x10
    009B6 DF58      RCALL	_i2c_write
(0859) 				  break;
    009B7 C203      RJMP	0x0BBB
(0860) 		case 0x02://频率设为频率1
(0861) 		          i2c_write(ADD_f,freqs_I2C,freqs_init,1);
    009B8 E081      LDI	R24,1
    009B9 838A      STD	Y+2,R24
    009BA E180      LDI	R24,0x10
    009BB E091      LDI	R25,1
    009BC 8399      STD	Y+1,R25
    009BD 8388      ST	Y,R24
    009BE E121      LDI	R18,0x11
    009BF E031      LDI	R19,1
    009C0 E200      LDI	R16,0x20
    009C1 DF4D      RCALL	_i2c_write
(0862) 				  break;
    009C2 C1F8      RJMP	0x0BBB
(0863) 	    case 0x03://调直数据
(0864) 		          i2c_write(ADD_t,degree_I2C,Static_Offset_degree_init,3);
    009C3 E083      LDI	R24,3
    009C4 838A      STD	Y+2,R24
    009C5 E187      LDI	R24,0x17
    009C6 E091      LDI	R25,1
    009C7 8399      STD	Y+1,R25
    009C8 8388      ST	Y,R24
    009C9 E12A      LDI	R18,0x1A
    009CA E031      LDI	R19,1
    009CB E300      LDI	R16,0x30
    009CC DF42      RCALL	_i2c_write
(0865) 				  break;
    009CD C1ED      RJMP	0x0BBB
(0866) 		case 0x04://Speed_tem[16]速度，s_tem
(0867) 		          one2two(Speed_tem_init,Speed_tem_init1,Speed_tem_init2);
    009CE E489      LDI	R24,0x49
    009CF E091      LDI	R25,1
    009D0 8399      STD	Y+1,R25
    009D1 8388      ST	Y,R24
    009D2 E421      LDI	R18,0x41
    009D3 E031      LDI	R19,1
    009D4 E10F      LDI	R16,0x1F
    009D5 E011      LDI	R17,1
    009D6 DC99      RCALL	_one2two
(0868) 		          i2c_write(ADD_s1,Speed_tem_I2C1,Speed_tem_init1,8);
    009D7 E088      LDI	R24,0x8
    009D8 838A      STD	Y+2,R24
    009D9 E481      LDI	R24,0x41
    009DA E091      LDI	R25,1
    009DB 8399      STD	Y+1,R25
    009DC 8388      ST	Y,R24
    009DD E721      LDI	R18,0x71
    009DE E031      LDI	R19,1
    009DF E400      LDI	R16,0x40
    009E0 DF2E      RCALL	_i2c_write
(0869) 				  delay_nms(200);
    009E1 EC08      LDI	R16,0xC8
    009E2 E010      LDI	R17,0
    009E3 D872      RCALL	_delay_nms
(0870) 		          i2c_write(ADD_s2,Speed_tem_I2C2,Speed_tem_init2,8);
    009E4 E088      LDI	R24,0x8
    009E5 838A      STD	Y+2,R24
    009E6 E489      LDI	R24,0x49
    009E7 E091      LDI	R25,1
    009E8 8399      STD	Y+1,R25
    009E9 8388      ST	Y,R24
    009EA E72B      LDI	R18,0x7B
    009EB E031      LDI	R19,1
    009EC E408      LDI	R16,0x48
    009ED DF21      RCALL	_i2c_write
(0871) 				  break;
    009EE C1CC      RJMP	0x0BBB
(0872) 	    case 0x05://Neighbouring_Offset_degree[3]滞后角
(0873) 			      i2c_write(ADD_d,Neighbouring_Offset_degree_I2C,Neighbouring_Offset_degree_init,3);	         
    009EF E083      LDI	R24,3
    009F0 838A      STD	Y+2,R24
    009F1 E885      LDI	R24,0x85
    009F2 E091      LDI	R25,1
    009F3 8399      STD	Y+1,R25
    009F4 8388      ST	Y,R24
    009F5 E828      LDI	R18,0x88
    009F6 E031      LDI	R19,1
    009F7 E500      LDI	R16,0x50
    009F8 DF16      RCALL	_i2c_write
(0874) 				  break;
    009F9 C1C1      RJMP	0x0BBB
(0875) 	    case 0x06://Amplitude_degree_tem[16][3]摆幅,s_tem
(0876) 		          one2six(Amplitude_degree_tem_init,Amplitude_degree_tem_init1,Amplitude_degree_tem_init2,Amplitude_degree_tem_init3,Amplitude_degree_tem_init4,Amplitude_degree_tem_init5,Amplitude_degree_tem_init6);
    009FA EE85      LDI	R24,0xE5
    009FB E091      LDI	R25,1
    009FC 8799      STD	Y+9,R25
    009FD 8788      STD	Y+8,R24
    009FE ED8D      LDI	R24,0xDD
    009FF E091      LDI	R25,1
    00A00 839F      STD	Y+7,R25
    00A01 838E      STD	Y+6,R24
    00A02 ED85      LDI	R24,0xD5
    00A03 E091      LDI	R25,1
    00A04 839D      STD	Y+5,R25
    00A05 838C      STD	Y+4,R24
    00A06 EC8D      LDI	R24,0xCD
    00A07 E091      LDI	R25,1
    00A08 839B      STD	Y+3,R25
    00A09 838A      STD	Y+2,R24
    00A0A EC85      LDI	R24,0xC5
    00A0B E091      LDI	R25,1
    00A0C 8399      STD	Y+1,R25
    00A0D 8388      ST	Y,R24
    00A0E EB2D      LDI	R18,0xBD
    00A0F E031      LDI	R19,1
    00A10 E80D      LDI	R16,0x8D
    00A11 E011      LDI	R17,1
    00A12 DD82      RCALL	_one2six
(0877) 				  i2c_write(ADD_1,Amplitude_degree_tem_I2C1,Amplitude_degree_tem_init1,8);//+++++++
    00A13 E088      LDI	R24,0x8
    00A14 838A      STD	Y+2,R24
    00A15 EB8D      LDI	R24,0xBD
    00A16 E091      LDI	R25,1
    00A17 8399      STD	Y+1,R25
    00A18 8388      ST	Y,R24
    00A19 E42D      LDI	R18,0x4D
    00A1A E032      LDI	R19,2
    00A1B E600      LDI	R16,0x60
    00A1C DEF2      RCALL	_i2c_write
(0878) 				  delay_nms(200);
    00A1D EC08      LDI	R16,0xC8
    00A1E E010      LDI	R17,0
    00A1F D836      RCALL	_delay_nms
(0879) 				  i2c_write(ADD_2,Amplitude_degree_tem_I2C2,Amplitude_degree_tem_init2,8);//+++++++
    00A20 E088      LDI	R24,0x8
    00A21 838A      STD	Y+2,R24
    00A22 EC85      LDI	R24,0xC5
    00A23 E091      LDI	R25,1
    00A24 8399      STD	Y+1,R25
    00A25 8388      ST	Y,R24
    00A26 E527      LDI	R18,0x57
    00A27 E032      LDI	R19,2
    00A28 E608      LDI	R16,0x68
    00A29 DEE5      RCALL	_i2c_write
(0880)      			  break;
    00A2A C190      RJMP	0x0BBB
(0881) 		case 0x07:
(0882) 				  i2c_write(ADD_3,Amplitude_degree_tem_I2C3,Amplitude_degree_tem_init3,8);//+++++++
    00A2B E088      LDI	R24,0x8
    00A2C 838A      STD	Y+2,R24
    00A2D EC8D      LDI	R24,0xCD
    00A2E E091      LDI	R25,1
    00A2F 8399      STD	Y+1,R25
    00A30 8388      ST	Y,R24
    00A31 E621      LDI	R18,0x61
    00A32 E032      LDI	R19,2
    00A33 E700      LDI	R16,0x70
    00A34 DEDA      RCALL	_i2c_write
(0883) 				  delay_nms(200);
    00A35 EC08      LDI	R16,0xC8
    00A36 E010      LDI	R17,0
    00A37 D81E      RCALL	_delay_nms
(0884) 				  i2c_write(ADD_4,Amplitude_degree_tem_I2C4,Amplitude_degree_tem_init4,8);
    00A38 E088      LDI	R24,0x8
    00A39 838A      STD	Y+2,R24
    00A3A ED85      LDI	R24,0xD5
    00A3B E091      LDI	R25,1
    00A3C 8399      STD	Y+1,R25
    00A3D 8388      ST	Y,R24
    00A3E E62B      LDI	R18,0x6B
    00A3F E032      LDI	R19,2
    00A40 E708      LDI	R16,0x78
    00A41 DECD      RCALL	_i2c_write
(0885) 				  break;
    00A42 C178      RJMP	0x0BBB
(0886) 		case 0x08:
(0887) 				  i2c_write(ADD_5,Amplitude_degree_tem_I2C5,Amplitude_degree_tem_init5,8);
    00A43 E088      LDI	R24,0x8
    00A44 838A      STD	Y+2,R24
    00A45 ED8D      LDI	R24,0xDD
    00A46 E091      LDI	R25,1
    00A47 8399      STD	Y+1,R25
    00A48 8388      ST	Y,R24
    00A49 E725      LDI	R18,0x75
    00A4A E032      LDI	R19,2
    00A4B E800      LDI	R16,0x80
    00A4C DEC2      RCALL	_i2c_write
(0888) 				  break;
    00A4D C16D      RJMP	0x0BBB
(0889) 		case 0x09:
(0890) 				  i2c_write(ADD_6,Amplitude_degree_tem_I2C6,Amplitude_degree_tem_init6,8);				  
    00A4E E088      LDI	R24,0x8
    00A4F 838A      STD	Y+2,R24
    00A50 EE85      LDI	R24,0xE5
    00A51 E091      LDI	R25,1
    00A52 8399      STD	Y+1,R25
    00A53 8388      ST	Y,R24
    00A54 E72F      LDI	R18,0x7F
    00A55 E032      LDI	R19,2
    00A56 E808      LDI	R16,0x88
    00A57 DEB7      RCALL	_i2c_write
(0891)                   break;
    00A58 C162      RJMP	0x0BBB
(0892) 	    case 0x0A://Dynamic_Offset_degree_origin[8][3]转弯偏移角,d_tem
(0893) 		          one2three(Dynamic_Offset_degree_origin_init,Dynamic_Offset_degree_origin_init1,Dynamic_Offset_degree_origin_init2,Dynamic_Offset_degree_origin_init3);
    00A59 EB81      LDI	R24,0xB1
    00A5A E092      LDI	R25,2
    00A5B 839B      STD	Y+3,R25
    00A5C 838A      STD	Y+2,R24
    00A5D EA89      LDI	R24,0xA9
    00A5E E092      LDI	R25,2
    00A5F 8399      STD	Y+1,R25
    00A60 8388      ST	Y,R24
    00A61 EA21      LDI	R18,0xA1
    00A62 E032      LDI	R19,2
    00A63 E809      LDI	R16,0x89
    00A64 E012      LDI	R17,2
    00A65 DC81      RCALL	_one2three
(0894) 				  i2c_write(ADD_10,Dynamic_Offset_degree_origin_I2C1,Dynamic_Offset_degree_origin_init1,8);//+++++++
    00A66 E088      LDI	R24,0x8
    00A67 838A      STD	Y+2,R24
    00A68 EA81      LDI	R24,0xA1
    00A69 E092      LDI	R25,2
    00A6A 8399      STD	Y+1,R25
    00A6B 8388      ST	Y,R24
    00A6C EE29      LDI	R18,0xE9
    00A6D E032      LDI	R19,2
    00A6E E900      LDI	R16,0x90
    00A6F DE9F      RCALL	_i2c_write
(0895)      			  break;
    00A70 C14A      RJMP	0x0BBB
(0896) 		case 0x0B:
(0897) 				  i2c_write(ADD_20,Dynamic_Offset_degree_origin_I2C2,Dynamic_Offset_degree_origin_init2,8);//+++++++
    00A71 E088      LDI	R24,0x8
    00A72 838A      STD	Y+2,R24
    00A73 EA89      LDI	R24,0xA9
    00A74 E092      LDI	R25,2
    00A75 8399      STD	Y+1,R25
    00A76 8388      ST	Y,R24
    00A77 EF23      LDI	R18,0xF3
    00A78 E032      LDI	R19,2
    00A79 E908      LDI	R16,0x98
    00A7A DE94      RCALL	_i2c_write
(0898) 				  delay_nms(200);
    00A7B EC08      LDI	R16,0xC8
    00A7C E010      LDI	R17,0
    00A7D 940E 0256 CALL	_delay_nms
(0899) 				  i2c_write(ADD_30,Dynamic_Offset_degree_origin_I2C3,Dynamic_Offset_degree_origin_init3,8);
    00A7F E088      LDI	R24,0x8
    00A80 838A      STD	Y+2,R24
    00A81 EB81      LDI	R24,0xB1
    00A82 E092      LDI	R25,2
    00A83 8399      STD	Y+1,R25
    00A84 8388      ST	Y,R24
    00A85 EF2D      LDI	R18,0xFD
    00A86 E032      LDI	R19,2
    00A87 EA00      LDI	R16,0xA0
    00A88 DE86      RCALL	_i2c_write
(0900) 				  break;
    00A89 C131      RJMP	0x0BBB
(0901) 	    case 0x0C:
(0902) 				  delay_nms(200);
    00A8A EC08      LDI	R16,0xC8
    00A8B E010      LDI	R17,0
    00A8C 940E 0256 CALL	_delay_nms
(0903) 		         //读i2c数据
(0904) 				 i2c_read(ADD_i,FISHID_I2C,FISHID,1);
    00A8E E081      LDI	R24,1
    00A8F 838A      STD	Y+2,R24
    00A90 E08A      LDI	R24,0xA
    00A91 E091      LDI	R25,1
    00A92 8399      STD	Y+1,R25
    00A93 8388      ST	Y,R24
    00A94 E02C      LDI	R18,0xC
    00A95 E031      LDI	R19,1
    00A96 E100      LDI	R16,0x10
    00A97 DE9D      RCALL	_i2c_read
(0905)      			 i2c_read(ADD_f,freqs_I2C,freqs,1);
    00A98 E081      LDI	R24,1
    00A99 838A      STD	Y+2,R24
    00A9A E08F      LDI	R24,0xF
    00A9B E091      LDI	R25,1
    00A9C 8399      STD	Y+1,R25
    00A9D 8388      ST	Y,R24
    00A9E E121      LDI	R18,0x11
    00A9F E031      LDI	R19,1
    00AA0 E200      LDI	R16,0x20
    00AA1 DE93      RCALL	_i2c_read
(0906) 	 			 //PORTD=freq[freqs[0]];
(0907) 	 			 i2c_read(ADD_t,degree_I2C,Static_Offset_degree,3);
    00AA2 E083      LDI	R24,3
    00AA3 838A      STD	Y+2,R24
    00AA4 E184      LDI	R24,0x14
    00AA5 E091      LDI	R25,1
    00AA6 8399      STD	Y+1,R25
    00AA7 8388      ST	Y,R24
    00AA8 E12A      LDI	R18,0x1A
    00AA9 E031      LDI	R19,1
    00AAA E300      LDI	R16,0x30
    00AAB DE89      RCALL	_i2c_read
(0908) 	 			 i2c_read(ADD_s1,Speed_tem_I2C1,Speed_tem_z1,8);
    00AAC E088      LDI	R24,0x8
    00AAD 838A      STD	Y+2,R24
    00AAE E681      LDI	R24,0x61
    00AAF E091      LDI	R25,1
    00AB0 8399      STD	Y+1,R25
    00AB1 8388      ST	Y,R24
    00AB2 E721      LDI	R18,0x71
    00AB3 E031      LDI	R19,1
    00AB4 E400      LDI	R16,0x40
    00AB5 DE7F      RCALL	_i2c_read
(0909) 	 			 i2c_read(ADD_s2,Speed_tem_I2C2,Speed_tem_z2,8);
    00AB6 E088      LDI	R24,0x8
    00AB7 838A      STD	Y+2,R24
    00AB8 E689      LDI	R24,0x69
    00AB9 E091      LDI	R25,1
    00ABA 8399      STD	Y+1,R25
    00ABB 8388      ST	Y,R24
    00ABC E72B      LDI	R18,0x7B
    00ABD E031      LDI	R19,1
    00ABE E408      LDI	R16,0x48
    00ABF DE75      RCALL	_i2c_read
(0910) 				 two2one(Speed_tem_z,Speed_tem_z1,Speed_tem_z2);
    00AC0 E689      LDI	R24,0x69
    00AC1 E091      LDI	R25,1
    00AC2 8399      STD	Y+1,R25
    00AC3 8388      ST	Y,R24
    00AC4 E621      LDI	R18,0x61
    00AC5 E031      LDI	R19,1
    00AC6 E501      LDI	R16,0x51
    00AC7 E011      LDI	R17,1
    00AC8 DBE3      RCALL	_two2one
(0911) 				 for(i=0;i<=15;i++)
    00AC9 2744      CLR	R20
    00ACA 2755      CLR	R21
(0912) 				 {
(0913)                      Speed_tem[i]=Speed_tem_z[i];
    00ACB E581      LDI	R24,0x51
    00ACC E091      LDI	R25,1
    00ACD 01FA      MOVW	R30,R20
    00ACE 0FE8      ADD	R30,R24
    00ACF 1FF9      ADC	R31,R25
    00AD0 8020      LD	R2,Z
    00AD1 E386      LDI	R24,0x36
    00AD2 E093      LDI	R25,3
    00AD3 01FA      MOVW	R30,R20
    00AD4 0FE8      ADD	R30,R24
    00AD5 1FF9      ADC	R31,R25
    00AD6 8220      ST	Z,R2
    00AD7 5F4F      SUBI	R20,0xFF
    00AD8 4F5F      SBCI	R21,0xFF
    00AD9 E08F      LDI	R24,0xF
    00ADA E090      LDI	R25,0
    00ADB 1784      CP	R24,R20
    00ADC 0795      CPC	R25,R21
    00ADD F76C      BGE	0x0ACB
(0914) 				 }
(0915) 	 			 i2c_read(ADD_d,Neighbouring_Offset_degree_I2C,Neighbouring_Offset_degree,3);
    00ADE E083      LDI	R24,3
    00ADF 838A      STD	Y+2,R24
    00AE0 EE8B      LDI	R24,0xEB
    00AE1 E093      LDI	R25,3
    00AE2 8399      STD	Y+1,R25
    00AE3 8388      ST	Y,R24
    00AE4 E828      LDI	R18,0x88
    00AE5 E031      LDI	R19,1
    00AE6 E500      LDI	R16,0x50
    00AE7 DE4D      RCALL	_i2c_read
(0916) 	 			 i2c_read(ADD_1,Amplitude_degree_tem_I2C1,Amplitude_degree_tem_z1,8);
    00AE8 E088      LDI	R24,0x8
    00AE9 838A      STD	Y+2,R24
    00AEA E18D      LDI	R24,0x1D
    00AEB E092      LDI	R25,2
    00AEC 8399      STD	Y+1,R25
    00AED 8388      ST	Y,R24
    00AEE E42D      LDI	R18,0x4D
    00AEF E032      LDI	R19,2
    00AF0 E600      LDI	R16,0x60
    00AF1 DE43      RCALL	_i2c_read
(0917) 	 			 i2c_read(ADD_2,Amplitude_degree_tem_I2C2,Amplitude_degree_tem_z2,8);
    00AF2 E088      LDI	R24,0x8
    00AF3 838A      STD	Y+2,R24
    00AF4 E285      LDI	R24,0x25
    00AF5 E092      LDI	R25,2
    00AF6 8399      STD	Y+1,R25
    00AF7 8388      ST	Y,R24
    00AF8 E527      LDI	R18,0x57
    00AF9 E032      LDI	R19,2
    00AFA E608      LDI	R16,0x68
    00AFB DE39      RCALL	_i2c_read
(0918) 	 			 i2c_read(ADD_3,Amplitude_degree_tem_I2C3,Amplitude_degree_tem_z3,8);
    00AFC E088      LDI	R24,0x8
    00AFD 838A      STD	Y+2,R24
    00AFE E28D      LDI	R24,0x2D
    00AFF E092      LDI	R25,2
    00B00 8399      STD	Y+1,R25
    00B01 8388      ST	Y,R24
    00B02 E621      LDI	R18,0x61
    00B03 E032      LDI	R19,2
    00B04 E700      LDI	R16,0x70
    00B05 DE2F      RCALL	_i2c_read
(0919) 	 			 i2c_read(ADD_4,Amplitude_degree_tem_I2C4,Amplitude_degree_tem_z4,8);
    00B06 E088      LDI	R24,0x8
    00B07 838A      STD	Y+2,R24
    00B08 E385      LDI	R24,0x35
    00B09 E092      LDI	R25,2
    00B0A 8399      STD	Y+1,R25
    00B0B 8388      ST	Y,R24
    00B0C E62B      LDI	R18,0x6B
    00B0D E032      LDI	R19,2
    00B0E E708      LDI	R16,0x78
    00B0F DE25      RCALL	_i2c_read
(0920) 	 			 i2c_read(ADD_5,Amplitude_degree_tem_I2C5,Amplitude_degree_tem_z5,8);
    00B10 E088      LDI	R24,0x8
    00B11 838A      STD	Y+2,R24
    00B12 E38D      LDI	R24,0x3D
    00B13 E092      LDI	R25,2
    00B14 8399      STD	Y+1,R25
    00B15 8388      ST	Y,R24
    00B16 E725      LDI	R18,0x75
    00B17 E032      LDI	R19,2
    00B18 E800      LDI	R16,0x80
    00B19 DE1B      RCALL	_i2c_read
(0921) 	 			 i2c_read(ADD_6,Amplitude_degree_tem_I2C6,Amplitude_degree_tem_z6,8);
    00B1A E088      LDI	R24,0x8
    00B1B 838A      STD	Y+2,R24
    00B1C E485      LDI	R24,0x45
    00B1D E092      LDI	R25,2
    00B1E 8399      STD	Y+1,R25
    00B1F 8388      ST	Y,R24
    00B20 E72F      LDI	R18,0x7F
    00B21 E032      LDI	R19,2
    00B22 E808      LDI	R16,0x88
    00B23 DE11      RCALL	_i2c_read
(0922) 	 			 six2one(Amplitude_degree_tem_z,Amplitude_degree_tem_z1,Amplitude_degree_tem_z2,Amplitude_degree_tem_z3,Amplitude_degree_tem_z4,Amplitude_degree_tem_z5,Amplitude_degree_tem_z6);  
    00B24 E485      LDI	R24,0x45
    00B25 E092      LDI	R25,2
    00B26 8799      STD	Y+9,R25
    00B27 8788      STD	Y+8,R24
    00B28 E38D      LDI	R24,0x3D
    00B29 E092      LDI	R25,2
    00B2A 839F      STD	Y+7,R25
    00B2B 838E      STD	Y+6,R24
    00B2C E385      LDI	R24,0x35
    00B2D E092      LDI	R25,2
    00B2E 839D      STD	Y+5,R25
    00B2F 838C      STD	Y+4,R24
    00B30 E28D      LDI	R24,0x2D
    00B31 E092      LDI	R25,2
    00B32 839B      STD	Y+3,R25
    00B33 838A      STD	Y+2,R24
    00B34 E285      LDI	R24,0x25
    00B35 E092      LDI	R25,2
    00B36 8399      STD	Y+1,R25
    00B37 8388      ST	Y,R24
    00B38 E12D      LDI	R18,0x1D
    00B39 E032      LDI	R19,2
    00B3A EE0D      LDI	R16,0xED
    00B3B E011      LDI	R17,1
    00B3C DD07      RCALL	_six2one
(0923) 	 			   for(i=0;i<=47;i++)
    00B3D 2744      CLR	R20
    00B3E 2755      CLR	R21
(0924) 	   			   {
(0925) 	   			     Amplitude_degree_tem[i/3][i%3]=Amplitude_degree_tem_z[i];
    00B3F E023      LDI	R18,3
    00B40 E030      LDI	R19,0
    00B41 018A      MOVW	R16,R20
    00B42 940E 1A3E CALL	div16s
    00B44 E083      LDI	R24,3
    00B45 E090      LDI	R25,0
    00B46 0198      MOVW	R18,R16
    00B47 018C      MOVW	R16,R24
    00B48 940E 1AA0 CALL	empy16s
    00B4A EF81      LDI	R24,0xF1
    00B4B E093      LDI	R25,3
    00B4C 0118      MOVW	R2,R16
    00B4D 0E28      ADD	R2,R24
    00B4E 1E39      ADC	R3,R25
    00B4F E023      LDI	R18,3
    00B50 E030      LDI	R19,0
    00B51 018A      MOVW	R16,R20
    00B52 940E 1A3A CALL	mod16s
    00B54 01F8      MOVW	R30,R16
    00B55 0DE2      ADD	R30,R2
    00B56 1DF3      ADC	R31,R3
    00B57 EE8D      LDI	R24,0xED
    00B58 E091      LDI	R25,1
    00B59 01DA      MOVW	R26,R20
    00B5A 0FA8      ADD	R26,R24
    00B5B 1FB9      ADC	R27,R25
    00B5C 902C      LD	R2,X
    00B5D 8220      ST	Z,R2
    00B5E 5F4F      SUBI	R20,0xFF
    00B5F 4F5F      SBCI	R21,0xFF
    00B60 E28F      LDI	R24,0x2F
    00B61 E090      LDI	R25,0
    00B62 1784      CP	R24,R20
    00B63 0795      CPC	R25,R21
    00B64 F6D4      BGE	0x0B3F
(0926) 	   			   }	
(0927) 	 			 i2c_read(ADD_10,Dynamic_Offset_degree_origin_I2C1,Dynamic_Offset_degree_origin_z1,8);
    00B65 E088      LDI	R24,0x8
    00B66 838A      STD	Y+2,R24
    00B67 ED81      LDI	R24,0xD1
    00B68 E092      LDI	R25,2
    00B69 8399      STD	Y+1,R25
    00B6A 8388      ST	Y,R24
    00B6B EE29      LDI	R18,0xE9
    00B6C E032      LDI	R19,2
    00B6D E900      LDI	R16,0x90
    00B6E DDC6      RCALL	_i2c_read
(0928) 	 			 i2c_read(ADD_20,Dynamic_Offset_degree_origin_I2C2,Dynamic_Offset_degree_origin_z2,8);
    00B6F E088      LDI	R24,0x8
    00B70 838A      STD	Y+2,R24
    00B71 ED89      LDI	R24,0xD9
    00B72 E092      LDI	R25,2
    00B73 8399      STD	Y+1,R25
    00B74 8388      ST	Y,R24
    00B75 EF23      LDI	R18,0xF3
    00B76 E032      LDI	R19,2
    00B77 E908      LDI	R16,0x98
    00B78 DDBC      RCALL	_i2c_read
(0929) 	 			 i2c_read(ADD_30,Dynamic_Offset_degree_origin_I2C3,Dynamic_Offset_degree_origin_z3,8);
    00B79 E088      LDI	R24,0x8
    00B7A 838A      STD	Y+2,R24
    00B7B EE81      LDI	R24,0xE1
    00B7C E092      LDI	R25,2
    00B7D 8399      STD	Y+1,R25
    00B7E 8388      ST	Y,R24
    00B7F EF2D      LDI	R18,0xFD
    00B80 E032      LDI	R19,2
    00B81 EA00      LDI	R16,0xA0
    00B82 DDB2      RCALL	_i2c_read
(0930) 	 			 three2one(Dynamic_Offset_degree_origin_z,Dynamic_Offset_degree_origin_z1,Dynamic_Offset_degree_origin_z2,Dynamic_Offset_degree_origin_z3);  
    00B83 EE81      LDI	R24,0xE1
    00B84 E092      LDI	R25,2
    00B85 839B      STD	Y+3,R25
    00B86 838A      STD	Y+2,R24
    00B87 ED89      LDI	R24,0xD9
    00B88 E092      LDI	R25,2
    00B89 8399      STD	Y+1,R25
    00B8A 8388      ST	Y,R24
    00B8B ED21      LDI	R18,0xD1
    00B8C E032      LDI	R19,2
    00B8D EB09      LDI	R16,0xB9
    00B8E E012      LDI	R17,2
    00B8F DBAF      RCALL	_three2one
(0931) 	  			   for(i=0;i<=23;i++)
    00B90 2744      CLR	R20
    00B91 2755      CLR	R21
(0932) 	   			   {
(0933) 	     		     Dynamic_Offset_degree_origin[i/3][i%3]=Dynamic_Offset_degree_origin_z[i];
    00B92 E023      LDI	R18,3
    00B93 E030      LDI	R19,0
    00B94 018A      MOVW	R16,R20
    00B95 940E 1A3E CALL	div16s
    00B97 E083      LDI	R24,3
    00B98 E090      LDI	R25,0
    00B99 0198      MOVW	R18,R16
    00B9A 018C      MOVW	R16,R24
    00B9B 940E 1AA0 CALL	empy16s
    00B9D E486      LDI	R24,0x46
    00B9E E093      LDI	R25,3
    00B9F 0118      MOVW	R2,R16
    00BA0 0E28      ADD	R2,R24
    00BA1 1E39      ADC	R3,R25
    00BA2 E023      LDI	R18,3
    00BA3 E030      LDI	R19,0
    00BA4 018A      MOVW	R16,R20
    00BA5 940E 1A3A CALL	mod16s
    00BA7 01F8      MOVW	R30,R16
    00BA8 0DE2      ADD	R30,R2
    00BA9 1DF3      ADC	R31,R3
    00BAA EB89      LDI	R24,0xB9
    00BAB E092      LDI	R25,2
    00BAC 01DA      MOVW	R26,R20
    00BAD 0FA8      ADD	R26,R24
    00BAE 1FB9      ADC	R27,R25
    00BAF 902C      LD	R2,X
    00BB0 8220      ST	Z,R2
    00BB1 5F4F      SUBI	R20,0xFF
    00BB2 4F5F      SBCI	R21,0xFF
    00BB3 E187      LDI	R24,0x17
    00BB4 E090      LDI	R25,0
    00BB5 1784      CP	R24,R20
    00BB6 0795      CPC	R25,R21
    00BB7 F6D4      BGE	0x0B92
(0934) 	  			   }	
(0935) 				senddata(0xcc);
    00BB8 EC0C      LDI	R16,0xCC
    00BB9 940E 02CA CALL	_senddata
(0936) 		    	 break;
    00BBB 962A      ADIW	R28,0xA
    00BBC 9159      LD	R21,Y+
    00BBD 9149      LD	R20,Y+
    00BBE 9508      RET
_uart0_rx_isr:
    00BBF 920A      ST	-Y,R0
    00BC0 921A      ST	-Y,R1
    00BC1 922A      ST	-Y,R2
    00BC2 923A      ST	-Y,R3
    00BC3 924A      ST	-Y,R4
    00BC4 925A      ST	-Y,R5
    00BC5 926A      ST	-Y,R6
    00BC6 927A      ST	-Y,R7
    00BC7 928A      ST	-Y,R8
    00BC8 929A      ST	-Y,R9
    00BC9 930A      ST	-Y,R16
    00BCA 931A      ST	-Y,R17
    00BCB 932A      ST	-Y,R18
    00BCC 933A      ST	-Y,R19
    00BCD 938A      ST	-Y,R24
    00BCE 939A      ST	-Y,R25
    00BCF 93AA      ST	-Y,R26
    00BD0 93BA      ST	-Y,R27
    00BD1 93EA      ST	-Y,R30
    00BD2 93FA      ST	-Y,R31
    00BD3 B60F      IN	R0,0x3F
    00BD4 920A      ST	-Y,R0
    00BD5 940E 1AD2 CALL	push_xgset300C
(0937) 	  }
(0938) }
(0939) 
(0940) 
(0941) //***********************************串口中断*****************************
(0942) #pragma interrupt_handler uart0_rx_isr:19
(0943) void uart0_rx_isr(void) 
(0944) {
(0945)        redata=UDR0;
    00BD7 B02C      IN	R2,0x0C
    00BD8 9220 0425 STS	redata,R2
(0946) 	   if(1)//?//判断寄存器的值，是否存在
(0947) 	   {
(0948) 		 if(isSrlStart)//若已经发送开始位，判断地址码是否匹配
    00BDA 9020 0307 LDS	R2,isSrlStart
    00BDC 2022      TST	R2
    00BDD F409      BNE	0x0BDF
    00BDE C415      RJMP	0x0FF4
(0949) 		 {
(0950) 		   if(addr)//若地址码已经匹配，准备接收命令
    00BDF 9020 0309 LDS	R2,addr
    00BE1 2022      TST	R2
    00BE2 F409      BNE	0x0BE4
    00BE3 C401      RJMP	0x0FE5
(0951) 		   {
(0952) 			   if(isInstruction==1|y_changing)//已经接受过命令了，那么判断是否是结束位
    00BE4 9180 0317 LDS	R24,isInstruction
    00BE6 3081      CPI	R24,1
    00BE7 F419      BNE	0x0BEB
    00BE8 E041      LDI	R20,1
    00BE9 E050      LDI	R21,0
    00BEA C002      RJMP	0x0BED
    00BEB 2744      CLR	R20
    00BEC 2755      CLR	R21
    00BED 9020 0324 LDS	R2,y_changing
    00BEF 2433      CLR	R3
    00BF0 012A      MOVW	R4,R20
    00BF1 2842      OR	R4,R2
    00BF2 2853      OR	R5,R3
    00BF3 2044      TST	R4
    00BF4 F411      BNE	0x0BF7
    00BF5 2055      TST	R5
    00BF6 F091      BEQ	0x0C09
(0953) 			   {
(0954) 				   if(redata==0xfc)
    00BF7 9180 0425 LDS	R24,redata
    00BF9 3F8C      CPI	R24,0xFC
    00BFA F431      BNE	0x0C01
(0955) 				   { 
(0956) 					   e_change=1;//
    00BFB E081      LDI	R24,1
    00BFC 9380 0314 STS	e_change,R24
(0957) 					   is_uart=1;//退出自动模式，进入手动控制模式
    00BFE 9380 0319 STS	is_uart,R24
(0958) 				   }
    00C00 C45A      RJMP	0x105B
(0959) 				   else//接收到的不是结束位，那么这条指令无效，重新接收下一次命令
(0960) 				   {
(0961) 			  	      isSrlStart=0;
    00C01 2422      CLR	R2
    00C02 9220 0307 STS	isSrlStart,R2
(0962) 					  addr=0;
    00C04 9220 0309 STS	addr,R2
(0963) 					  isInstruction=0;
    00C06 9220 0317 STS	isInstruction,R2
(0964) 				   }
(0965) 			   }
    00C08 C452      RJMP	0x105B
(0966) 			   else//没有接受过命令，则接受命令
(0967) 			   {
(0968) 				   switch(redata&0xf0)
    00C09 9140 0425 LDS	R20,redata
    00C0B 2755      CLR	R21
    00C0C 7F40      ANDI	R20,0xF0
    00C0D 7050      ANDI	R21,0
    00C0E 3640      CPI	R20,0x60
    00C0F E0E0      LDI	R30,0
    00C10 075E      CPC	R21,R30
    00C11 F409      BNE	0x0C13
    00C12 C193      RJMP	0x0DA6
    00C13 E680      LDI	R24,0x60
    00C14 E090      LDI	R25,0
    00C15 1784      CP	R24,R20
    00C16 0795      CPC	R25,R21
    00C17 F40C      BGE	0x0C19
    00C18 C02F      RJMP	0x0C48
    00C19 3240      CPI	R20,0x20
    00C1A E0E0      LDI	R30,0
    00C1B 075E      CPC	R21,R30
    00C1C F409      BNE	0x0C1E
    00C1D C09C      RJMP	0x0CBA
    00C1E E280      LDI	R24,0x20
    00C1F E090      LDI	R25,0
    00C20 1784      CP	R24,R20
    00C21 0795      CPC	R25,R21
    00C22 F07C      BLT	0x0C32
    00C23 3040      CPI	R20,0
    00C24 0745      CPC	R20,R21
    00C25 F409      BNE	0x0C27
    00C26 C075      RJMP	0x0C9C
    00C27 3040      CPI	R20,0
    00C28 E0E0      LDI	R30,0
    00C29 075E      CPC	R21,R30
    00C2A F40C      BGE	0x0C2C
    00C2B C3B3      RJMP	0x0FDF
    00C2C 3140      CPI	R20,0x10
    00C2D E0E0      LDI	R30,0
    00C2E 075E      CPC	R21,R30
    00C2F F409      BNE	0x0C31
    00C30 C07A      RJMP	0x0CAB
    00C31 C3AD      RJMP	0x0FDF
    00C32 3440      CPI	R20,0x40
    00C33 E0E0      LDI	R30,0
    00C34 075E      CPC	R21,R30
    00C35 F409      BNE	0x0C37
    00C36 C095      RJMP	0x0CCC
    00C37 E480      LDI	R24,0x40
    00C38 E090      LDI	R25,0
    00C39 1784      CP	R24,R20
    00C3A 0795      CPC	R25,R21
    00C3B F034      BLT	0x0C42
    00C3C 3340      CPI	R20,0x30
    00C3D E0E0      LDI	R30,0
    00C3E 075E      CPC	R21,R30
    00C3F F409      BNE	0x0C41
    00C40 C0AF      RJMP	0x0CF0
    00C41 C39D      RJMP	0x0FDF
    00C42 3540      CPI	R20,0x50
    00C43 E0E0      LDI	R30,0
    00C44 075E      CPC	R21,R30
    00C45 F409      BNE	0x0C47
    00C46 C10A      RJMP	0x0D51
    00C47 C397      RJMP	0x0FDF
    00C48 3C40      CPI	R20,0xC0
    00C49 E0E0      LDI	R30,0
    00C4A 075E      CPC	R21,R30
    00C4B F409      BNE	0x0C4D
    00C4C C2AB      RJMP	0x0EF8
    00C4D EC80      LDI	R24,0xC0
    00C4E E090      LDI	R25,0
    00C4F 1784      CP	R24,R20
    00C50 0795      CPC	R25,R21
    00C51 F084      BLT	0x0C62
    00C52 3740      CPI	R20,0x70
    00C53 E0E0      LDI	R30,0
    00C54 075E      CPC	R21,R30
    00C55 F409      BNE	0x0C57
    00C56 C084      RJMP	0x0CDB
    00C57 3740      CPI	R20,0x70
    00C58 E0E0      LDI	R30,0
    00C59 075E      CPC	R21,R30
    00C5A F40C      BGE	0x0C5C
    00C5B C383      RJMP	0x0FDF
    00C5C 3B40      CPI	R20,0xB0
    00C5D E0E0      LDI	R30,0
    00C5E 075E      CPC	R21,R30
    00C5F F409      BNE	0x0C61
    00C60 C151      RJMP	0x0DB2
    00C61 C37D      RJMP	0x0FDF
    00C62 3E40      CPI	R20,0xE0
    00C63 E0E0      LDI	R30,0
    00C64 075E      CPC	R21,R30
    00C65 F119      BEQ	0x0C89
    00C66 EE80      LDI	R24,0xE0
    00C67 E090      LDI	R25,0
    00C68 1784      CP	R24,R20
    00C69 0795      CPC	R25,R21
    00C6A F02C      BLT	0x0C70
    00C6B 3D40      CPI	R20,0xD0
    00C6C E0E0      LDI	R30,0
    00C6D 075E      CPC	R21,R30
    00C6E F039      BEQ	0x0C76
    00C6F C36F      RJMP	0x0FDF
    00C70 3F40      CPI	R20,0xF0
    00C71 E0E0      LDI	R30,0
    00C72 075E      CPC	R21,R30
    00C73 F409      BNE	0x0C75
    00C74 C35F      RJMP	0x0FD4
    00C75 C369      RJMP	0x0FDF
(0969) 				   {
(0970) 				   case 0xD0://速度
(0971) 					   redata_fan=redata;
    00C76 9020 0425 LDS	R2,redata
    00C78 9220 0102 STS	redata_fan,R2
(0972) 					   s_change=1;
    00C7A E081      LDI	R24,1
    00C7B 9380 030B STS	s_change,R24
(0973) 					   m_change=0;
    00C7D 2422      CLR	R2
    00C7E 9220 031A STS	m_change,R2
(0974) 					   y_change=0;
    00C80 9220 0323 STS	y_change,R2
(0975) 					   isInstruction=1;
    00C82 9380 0317 STS	isInstruction,R24
(0976) 					   redata_tem=redata;
    00C84 9020 0425 LDS	R2,redata
    00C86 9220 0424 STS	redata_tem,R2
(0977) 					   break;
    00C88 C3D2      RJMP	0x105B
(0978) 				   case 0xE0://方向
(0979) 			            redata_fan=redata;
    00C89 9020 0425 LDS	R2,redata
    00C8B 9220 0102 STS	redata_fan,R2
(0980) 						d_change=1;
    00C8D E081      LDI	R24,1
    00C8E 9380 030C STS	d_change,R24
(0981) 						//d_change_t=1;
(0982) 						//d_change_t_v=1;
(0983) 						m_change=0;
    00C90 2422      CLR	R2
    00C91 9220 031A STS	m_change,R2
(0984) 						y_change=0;
    00C93 9220 0323 STS	y_change,R2
(0985) 						isInstruction=1;
    00C95 9380 0317 STS	isInstruction,R24
(0986) 						redata_tem=redata;
    00C97 9020 0425 LDS	R2,redata
    00C99 9220 0424 STS	redata_tem,R2
(0987) 						break;
    00C9B C3BF      RJMP	0x105B
(0988) 				   case 0x00://调直
(0989) 			            t_change=1;
    00C9C E081      LDI	R24,1
    00C9D 9380 030F STS	t_change,R24
(0990) 						m_change=0;
    00C9F 2422      CLR	R2
    00CA0 9220 031A STS	m_change,R2
(0991) 						y_change=0;
    00CA2 9220 0323 STS	y_change,R2
(0992) 						isInstruction=1;
    00CA4 9380 0317 STS	isInstruction,R24
(0993) 						redata_tem=redata;
    00CA6 9020 0425 LDS	R2,redata
    00CA8 9220 0424 STS	redata_tem,R2
(0994) 						break;
    00CAA C3B0      RJMP	0x105B
(0995) 				   case 0x10://调直是否保存
(0996) 			            ts_change=1;
    00CAB E081      LDI	R24,1
    00CAC 9380 0310 STS	ts_change,R24
(0997) 						m_change=0;
    00CAE 2422      CLR	R2
    00CAF 9220 031A STS	m_change,R2
(0998) 						y_change=0;
    00CB1 9220 0323 STS	y_change,R2
(0999) 						isInstruction=1;
    00CB3 9380 0317 STS	isInstruction,R24
(1000) 						redata_tem=redata;
    00CB5 9020 0425 LDS	R2,redata
    00CB7 9220 0424 STS	redata_tem,R2
(1001) 						break;
    00CB9 C3A1      RJMP	0x105B
(1002) 				   case 0x20://更改鱼id
(1003) 			            id_change++;
    00CBA 9180 0313 LDS	R24,id_change
    00CBC 5F8F      SUBI	R24,0xFF
    00CBD 9380 0313 STS	id_change,R24
(1004) 						m_change=0;
    00CBF 2422      CLR	R2
    00CC0 9220 031A STS	m_change,R2
(1005) 						y_change=0;
    00CC2 9220 0323 STS	y_change,R2
(1006) 						isInstruction=1;
    00CC4 E081      LDI	R24,1
    00CC5 9380 0317 STS	isInstruction,R24
(1007) 						redata_tem=redata;
    00CC7 9020 0425 LDS	R2,redata
    00CC9 9220 0424 STS	redata_tem,R2
(1008) 						break;
    00CCB C38F      RJMP	0x105B
(1009) 				   case 0x40://更改频率
(1010) 			            f_change=1;
    00CCC E081      LDI	R24,1
    00CCD 9380 0312 STS	f_change,R24
(1011) 						m_change=0;
    00CCF 2422      CLR	R2
    00CD0 9220 031A STS	m_change,R2
(1012) 						y_change=0;
    00CD2 9220 0323 STS	y_change,R2
(1013) 						isInstruction=1;
    00CD4 9380 0317 STS	isInstruction,R24
(1014) 						redata_tem=redata;
    00CD6 9020 0425 LDS	R2,redata
    00CD8 9220 0424 STS	redata_tem,R2
(1015) 						//PORTD=0xf4;						
(1016) 						break;
    00CDA C380      RJMP	0x105B
(1017) 				   case 0x70:///更改模态
(1018) 			            m_change=1;
    00CDB E081      LDI	R24,1
    00CDC 9380 031A STS	m_change,R24
(1019) 						y_change=0;
    00CDE 2422      CLR	R2
    00CDF 9220 0323 STS	y_change,R2
(1020) 						m_cishu=0;
    00CE1 9220 031B STS	m_cishu,R2
(1021) 						mm_cishu=0;
    00CE3 9220 031C STS	mm_cishu,R2
(1022) 						mmm_cishu=m_time-1;
    00CE5 E08F      LDI	R24,0xF
    00CE6 9380 031D STS	mmm_cishu,R24
(1023) 						isInstruction=1;
    00CE8 E081      LDI	R24,1
    00CE9 9380 0317 STS	isInstruction,R24
(1024) 						m_tem=redata;
    00CEB 9020 0425 LDS	R2,redata
    00CED 9220 032D STS	m_tem,R2
(1025) 						break;
    00CEF C36B      RJMP	0x105B
(1026) 				   case 0x30://原始的转弯模式
(1027) 			            y_change=1;
    00CF0 E081      LDI	R24,1
    00CF1 9380 0323 STS	y_change,R24
(1028)                         y_changing=1;
    00CF3 9380 0324 STS	y_changing,R24
(1029) 						m_change=0;
    00CF5 2422      CLR	R2
    00CF6 9220 031A STS	m_change,R2
(1030) 						y_cishu=0;
    00CF8 9220 0326 STS	y_cishu,R2
(1031) 						yy_cishu=0;
    00CFA 9220 0327 STS	yy_cishu,R2
(1032) 						yyy_cishu=y_time-1;
    00CFC 9380 0328 STS	yyy_cishu,R24
(1033) 						cishu_y=0;
    00CFE 9220 0329 STS	cishu_y,R2
(1034) 						y_tem=redata;
    00D00 9020 0425 LDS	R2,redata
    00D02 9220 032A STS	y_tem,R2
(1035) 						switch(y_tem)//转弯档不同，保持的时间不同，弯越大，时间越长。
    00D04 2D42      MOV	R20,R2
    00D05 2755      CLR	R21
    00D06 3040      CPI	R20,0
    00D07 E0E0      LDI	R30,0
    00D08 075E      CPC	R21,R30
    00D09 F40C      BGE	0x0D0B
    00D0A C03E      RJMP	0x0D49
    00D0B E08F      LDI	R24,0xF
    00D0C E090      LDI	R25,0
    00D0D 1784      CP	R24,R20
    00D0E 0795      CPC	R25,R21
    00D0F F40C      BGE	0x0D11
    00D10 C038      RJMP	0x0D49
    00D11 E88C      LDI	R24,0x8C
    00D12 E090      LDI	R25,0
    00D13 01FA      MOVW	R30,R20
    00D14 0FEE      LSL	R30
    00D15 1FFF      ROL	R31
    00D16 0FE8      ADD	R30,R24
    00D17 1FF9      ADC	R31,R25
    00D18 9027      ELPM	R2,Z+
    00D19 9036      ELPM	R3,Z
    00D1A 01F1      MOVW	R30,R2
    00D1B 9409      IJMP
(1036) 						{
(1037) 						case 0:
(1038) 							yy_time=0xff;
    00D1C EF8F      LDI	R24,0xFF
    00D1D 9380 0325 STS	yy_time,R24
(1039) 						case 1:
(1040) 							yy_time=0xf0;
    00D1F EF80      LDI	R24,0xF0
    00D20 9380 0325 STS	yy_time,R24
(1041) 						case 2:
(1042) 							yy_time=0xe0;
    00D22 EE80      LDI	R24,0xE0
    00D23 9380 0325 STS	yy_time,R24
(1043) 						case 3:
(1044) 							yy_time=0xd0;
    00D25 ED80      LDI	R24,0xD0
    00D26 9380 0325 STS	yy_time,R24
(1045) 						case 4:
(1046) 							yy_time=0xc0;
    00D28 EC80      LDI	R24,0xC0
    00D29 9380 0325 STS	yy_time,R24
(1047) 						case 5:
(1048) 							yy_time=0xb0;
    00D2B EB80      LDI	R24,0xB0
    00D2C 9380 0325 STS	yy_time,R24
(1049) 						case 6:
(1050) 							yy_time=0xa0;
    00D2E EA80      LDI	R24,0xA0
    00D2F 9380 0325 STS	yy_time,R24
(1051) 						case 15:
(1052) 							yy_time=0xff;
    00D31 EF8F      LDI	R24,0xFF
    00D32 9380 0325 STS	yy_time,R24
(1053) 						case 14:
(1054) 							yy_time=0xff;
    00D34 EF8F      LDI	R24,0xFF
    00D35 9380 0325 STS	yy_time,R24
(1055) 						case 13:
(1056) 							yy_time=0xf0;
    00D37 EF80      LDI	R24,0xF0
    00D38 9380 0325 STS	yy_time,R24
(1057) 						case 12:
(1058) 							yy_time=0xe0;
    00D3A EE80      LDI	R24,0xE0
    00D3B 9380 0325 STS	yy_time,R24
(1059) 						case 11:
(1060) 							yy_time=0xd0;
    00D3D ED80      LDI	R24,0xD0
    00D3E 9380 0325 STS	yy_time,R24
(1061) 						case 10:
(1062) 							yy_time=0xc0;
    00D40 EC80      LDI	R24,0xC0
    00D41 9380 0325 STS	yy_time,R24
(1063) 						case 9:
(1064) 							yy_time=0xb0;
    00D43 EB80      LDI	R24,0xB0
    00D44 9380 0325 STS	yy_time,R24
(1065) 						case 7:
(1066) 							y_change=0;
    00D46 2422      CLR	R2
    00D47 9220 0323 STS	y_change,R2
(1067) 						}
(1068) 						y_speed=Speed;					
    00D49 9020 0100 LDS	R2,Speed
    00D4B 9220 032B STS	y_speed,R2
(1069) 						isInstruction=1;
    00D4D E081      LDI	R24,1
    00D4E 9380 0317 STS	isInstruction,R24
(1070) 						break;
    00D50 C30A      RJMP	0x105B
(1071) /*			       case 0xb0://更改幅度
(1072) 			            a_change=1;
(1073) 						m_change=0;
(1074) 						y_change=0;
(1075) 						redata_tem=redata;
(1076) 						break;
(1077) */
(1078) 	/////////----测试指令--BEGIN----//////////////
(1079) 
(1080) 			       case 0x50:
(1081) 						isInstruction=1;
    00D51 E081      LDI	R24,1
    00D52 9380 0317 STS	isInstruction,R24
(1082) 			  	   		if(redata==0x55)//返回速度幅度值
    00D54 9180 0425 LDS	R24,redata
    00D56 3585      CPI	R24,0x55
    00D57 F009      BEQ	0x0D59
    00D58 C302      RJMP	0x105B
(1083) 						{
(1084) 			  			 senddata(0x11);//起始标志位
    00D59 E101      LDI	R16,0x11
    00D5A 940E 02CA CALL	_senddata
(1085) 			  			 senddata(FISHID[0]);//鱼的id号， 
    00D5C 9100 010A LDS	R16,FISHID
    00D5E 940E 02CA CALL	_senddata
(1086) 			  			 senddata(freqs[0]+1);//频率档，1-4
    00D60 9100 010F LDS	R16,freqs
    00D62 5F0F      SUBI	R16,0xFF
    00D63 940E 02CA CALL	_senddata
(1087) 			  			 senddata(Static_Offset_degree[0]);//第一关节调直数据
    00D65 9100 0114 LDS	R16,Static_Offset_degree
    00D67 940E 02CA CALL	_senddata
(1088) 			  			 senddata(Static_Offset_degree[1]);//第二关节调直数据
    00D69 9100 0115 LDS	R16,Static_Offset_degree+1
    00D6B 940E 02CA CALL	_senddata
(1089) 			  			 senddata(Static_Offset_degree[2]);//第三关节调直数据
    00D6D 9100 0116 LDS	R16,Static_Offset_degree+2
    00D6F 940E 02CA CALL	_senddata
(1090) 			  			 senddata(s_tem);//速度档，对应速度、幅度
    00D71 9100 032C LDS	R16,s_tem
    00D73 940E 02CA CALL	_senddata
(1091) 			  			 senddata(Speed);//速度值
    00D75 9100 0100 LDS	R16,Speed
    00D77 940E 02CA CALL	_senddata
(1092) 			  			 senddata(Amplitude_degree[0]);//第一关节摆幅
    00D79 9100 03EE LDS	R16,Amplitude_degree
    00D7B 940E 02CA CALL	_senddata
(1093) 			  			 senddata(Amplitude_degree[1]);//第二关节摆幅
    00D7D 9100 03EF LDS	R16,Amplitude_degree+1
    00D7F 940E 02CA CALL	_senddata
(1094) 			  			 senddata(Amplitude_degree[2]);//第三关节摆幅
    00D81 9100 03F0 LDS	R16,Amplitude_degree+2
    00D83 940E 02CA CALL	_senddata
(1095) 			  			 senddata(d_tem);//方向档，对应转弯偏移角度
    00D85 9100 032E LDS	R16,d_tem
    00D87 940E 02CA CALL	_senddata
(1096) 			  			 senddata(flag);//左转还是右转
    00D89 9100 0330 LDS	R16,flag
    00D8B 940E 02CA CALL	_senddata
(1097) 			  			 senddata(Dynamic_Offset_degree_char[0]);//第一关节转弯偏移角度
    00D8D 9100 03D0 LDS	R16,Dynamic_Offset_degree_char
    00D8F 940E 02CA CALL	_senddata
(1098) 			  			 senddata(Dynamic_Offset_degree_char[1]);//第二关节转弯偏移角度
    00D91 9100 03D1 LDS	R16,Dynamic_Offset_degree_char+1
    00D93 940E 02CA CALL	_senddata
(1099) 			  			 senddata(Dynamic_Offset_degree_char[2]);//第三关节转弯偏移角度
    00D95 9100 03D2 LDS	R16,Dynamic_Offset_degree_char+2
    00D97 940E 02CA CALL	_senddata
(1100) 			  			 senddata(Neighbouring_Offset_degree[0]);//0
    00D99 9100 03EB LDS	R16,Neighbouring_Offset_degree
    00D9B 940E 02CA CALL	_senddata
(1101) 			  			 senddata(Neighbouring_Offset_degree[1]);//第二关节滞后角
    00D9D 9100 03EC LDS	R16,Neighbouring_Offset_degree+1
    00D9F 940E 02CA CALL	_senddata
(1102) 			  			 senddata(Neighbouring_Offset_degree[2]);//第三关节滞后角
    00DA1 9100 03ED LDS	R16,Neighbouring_Offset_degree+2
    00DA3 940E 02CA CALL	_senddata
(1103) 						}//if(redata==0x55)	
(1104) 						break;
    00DA5 C2B5      RJMP	0x105B
(1105) 				   case 0x60:
(1106) 						isInstruction=1;
    00DA6 E081      LDI	R24,1
    00DA7 9380 0317 STS	isInstruction,R24
(1107) 			            if(redata==0x66)//将调整的参数保存到I2C
    00DA9 9180 0425 LDS	R24,redata
    00DAB 3686      CPI	R24,0x66
    00DAC F009      BEQ	0x0DAE
    00DAD C2AD      RJMP	0x105B
(1108) 						{
(1109) 			  			 i2c_canshu=1;
    00DAE E081      LDI	R24,1
    00DAF 9380 0331 STS	i2c_canshu,R24
(1110) 						}//if(redata==0x66)	
(1111) 						break;
    00DB1 C2A9      RJMP	0x105B
(1112) 				   
(1113) 				   case 0xb0:
(1114) 						isInstruction=1;
    00DB2 E081      LDI	R24,1
    00DB3 9380 0317 STS	isInstruction,R24
(1115) 			            if(redata==0xb1)//改speed
    00DB5 9180 0425 LDS	R24,redata
    00DB7 3B81      CPI	R24,0xB1
    00DB8 F479      BNE	0x0DC8
(1116) 			            {
(1117) 			            Speed--;
    00DB9 9180 0100 LDS	R24,Speed
    00DBB 5081      SUBI	R24,1
    00DBC 9380 0100 STS	Speed,R24
(1118) 			  			Speed_tem_z[s_tem]=Speed;
    00DBE E581      LDI	R24,0x51
    00DBF E091      LDI	R25,1
    00DC0 91E0 032C LDS	R30,s_tem
    00DC2 27FF      CLR	R31
    00DC3 0FE8      ADD	R30,R24
    00DC4 1FF9      ADC	R31,R25
    00DC5 9020 0100 LDS	R2,Speed
    00DC7 8220      ST	Z,R2
(1119) 						}//if(redata==0xb1)
(1120) 						
(1121) 						if(redata==0xb2)
    00DC8 9180 0425 LDS	R24,redata
    00DCA 3B82      CPI	R24,0xB2
    00DCB F479      BNE	0x0DDB
(1122) 						{
(1123) 			 			Speed++;
    00DCC 9180 0100 LDS	R24,Speed
    00DCE 5F8F      SUBI	R24,0xFF
    00DCF 9380 0100 STS	Speed,R24
(1124) 			 		    Speed_tem_z[s_tem]=Speed;
    00DD1 E581      LDI	R24,0x51
    00DD2 E091      LDI	R25,1
    00DD3 91E0 032C LDS	R30,s_tem
    00DD5 27FF      CLR	R31
    00DD6 0FE8      ADD	R30,R24
    00DD7 1FF9      ADC	R31,R25
    00DD8 9020 0100 LDS	R2,Speed
    00DDA 8220      ST	Z,R2
(1125) 						}//if(redata==0xb2)
(1126) 						
(1127) 						if(redata==0xb3)//第一关节偏移角，减1
    00DDB 9180 0425 LDS	R24,redata
    00DDD 3B83      CPI	R24,0xB3
    00DDE F561      BNE	0x0E0B
(1128) 						{
(1129) 			  			dd_tem=change_dd(d_tem);
    00DDF 9100 032E LDS	R16,d_tem
    00DE1 DB0C      RCALL	_change_dd
    00DE2 9300 032F STS	dd_tem,R16
(1130) 			  			flag=change_flag(d_tem);
    00DE4 9100 032E LDS	R16,d_tem
    00DE6 DB1E      RCALL	_change_flag
    00DE7 9300 0330 STS	flag,R16
(1131) 			  			 if(Dynamic_Offset_degree_char[0]==0)
    00DE9 9020 03D0 LDS	R2,Dynamic_Offset_degree_char
    00DEB 2022      TST	R2
    00DEC F409      BNE	0x0DEE
(1132) 			  			 {
(1133) 						 }
    00DED C005      RJMP	0x0DF3
(1134) 			  			 else
(1135) 			 			 {
(1136) 			  			 Dynamic_Offset_degree_char[0]--;
    00DEE 9180 03D0 LDS	R24,Dynamic_Offset_degree_char
    00DF0 5081      SUBI	R24,1
    00DF1 9380 03D0 STS	Dynamic_Offset_degree_char,R24
(1137) 			  			 }
(1138) 			  			Dynamic_Offset_degree[0]=char2int(Dynamic_Offset_degree_char[0],flag);
    00DF3 9120 0330 LDS	R18,flag
    00DF5 9100 03D0 LDS	R16,Dynamic_Offset_degree_char
    00DF7 D866      RCALL	_char2int
    00DF8 0158      MOVW	R10,R16
    00DF9 92B0 03CB STS	Dynamic_Offset_degree+1,R11
    00DFB 92A0 03CA STS	Dynamic_Offset_degree,R10
(1139) 			  			init_dynamic_offset();			  
    00DFD 940E 04B9 CALL	_init_dynamic_offset
(1140) 			  			Dynamic_Offset_degree_origin[dd_tem][0]=Dynamic_Offset_degree_char[0];
    00DFF 9110 032F LDS	R17,dd_tem
    00E01 E003      LDI	R16,3
    00E02 0301      MULSU	R16,R17
    00E03 E486      LDI	R24,0x46
    00E04 E093      LDI	R25,3
    00E05 01F0      MOVW	R30,R0
    00E06 0FE8      ADD	R30,R24
    00E07 1FF9      ADC	R31,R25
    00E08 9020 03D0 LDS	R2,Dynamic_Offset_degree_char
    00E0A 8220      ST	Z,R2
(1141) 					    }//if(redata==0xb3)
(1142) 			
(1143) 						if(redata==0xb4)//第一关节偏移角，加1
    00E0B 9180 0425 LDS	R24,redata
    00E0D 3B84      CPI	R24,0xB4
    00E0E F539      BNE	0x0E36
(1144) 						{
(1145) 			 			 dd_tem=change_dd(d_tem);
    00E0F 9100 032E LDS	R16,d_tem
    00E11 DADC      RCALL	_change_dd
    00E12 2EA0      MOV	R10,R16
    00E13 92A0 032F STS	dd_tem,R10
(1146) 			 			 flag=change_flag(d_tem);
    00E15 9100 032E LDS	R16,d_tem
    00E17 DAED      RCALL	_change_flag
    00E18 2EA0      MOV	R10,R16
    00E19 92A0 0330 STS	flag,R10
(1147) 			  			 Dynamic_Offset_degree_char[0]++;
    00E1B 9180 03D0 LDS	R24,Dynamic_Offset_degree_char
    00E1D 5F8F      SUBI	R24,0xFF
    00E1E 9380 03D0 STS	Dynamic_Offset_degree_char,R24
(1148) 			  			 Dynamic_Offset_degree[0]=char2int(Dynamic_Offset_degree_char[0],flag);
    00E20 2D2A      MOV	R18,R10
    00E21 2F08      MOV	R16,R24
    00E22 D83B      RCALL	_char2int
    00E23 0158      MOVW	R10,R16
    00E24 92B0 03CB STS	Dynamic_Offset_degree+1,R11
    00E26 92A0 03CA STS	Dynamic_Offset_degree,R10
(1149) 			  			 init_dynamic_offset();			  
    00E28 940E 04B9 CALL	_init_dynamic_offset
(1150) 			  			 Dynamic_Offset_degree_origin[dd_tem][0]=Dynamic_Offset_degree_char[0];
    00E2A 9110 032F LDS	R17,dd_tem
    00E2C E003      LDI	R16,3
    00E2D 0301      MULSU	R16,R17
    00E2E E486      LDI	R24,0x46
    00E2F E093      LDI	R25,3
    00E30 01F0      MOVW	R30,R0
    00E31 0FE8      ADD	R30,R24
    00E32 1FF9      ADC	R31,R25
    00E33 9020 03D0 LDS	R2,Dynamic_Offset_degree_char
    00E35 8220      ST	Z,R2
(1151) 						}//if(redata==0xb4)
(1152) 			
(1153) 						if(redata==0xb5)//第二关节偏移角，减1
    00E36 9180 0425 LDS	R24,redata
    00E38 3B85      CPI	R24,0xB5
    00E39 F571      BNE	0x0E68
(1154) 						{
(1155) 			  			 dd_tem=change_dd(d_tem);
    00E3A 9100 032E LDS	R16,d_tem
    00E3C DAB1      RCALL	_change_dd
    00E3D 2EA0      MOV	R10,R16
    00E3E 92A0 032F STS	dd_tem,R10
(1156) 			  			 flag=change_flag(d_tem);
    00E40 9100 032E LDS	R16,d_tem
    00E42 DAC2      RCALL	_change_flag
    00E43 2EA0      MOV	R10,R16
    00E44 92A0 0330 STS	flag,R10
(1157) 			  			 if(Dynamic_Offset_degree_char[1]==0)
    00E46 9020 03D1 LDS	R2,Dynamic_Offset_degree_char+1
    00E48 2022      TST	R2
    00E49 F409      BNE	0x0E4B
(1158) 			  			 {
(1159) 						 }
    00E4A C005      RJMP	0x0E50
(1160) 			  			 else
(1161) 			  			 {
(1162) 			  			 Dynamic_Offset_degree_char[1]--;
    00E4B 9180 03D1 LDS	R24,Dynamic_Offset_degree_char+1
    00E4D 5081      SUBI	R24,1
    00E4E 9380 03D1 STS	Dynamic_Offset_degree_char+1,R24
(1163) 			  			 }
(1164) 			  			Dynamic_Offset_degree[1]=char2int(Dynamic_Offset_degree_char[1],flag);
    00E50 9120 0330 LDS	R18,flag
    00E52 9100 03D1 LDS	R16,Dynamic_Offset_degree_char+1
    00E54 D809      RCALL	_char2int
    00E55 0158      MOVW	R10,R16
    00E56 92B0 03CD STS	Dynamic_Offset_degree+3,R11
    00E58 92A0 03CC STS	Dynamic_Offset_degree+2,R10
(1165) 			  			init_dynamic_offset();			  
    00E5A 940E 04B9 CALL	_init_dynamic_offset
(1166) 			  			Dynamic_Offset_degree_origin[dd_tem][1]=Dynamic_Offset_degree_char[1];
    00E5C 9110 032F LDS	R17,dd_tem
    00E5E E003      LDI	R16,3
    00E5F 0301      MULSU	R16,R17
    00E60 E487      LDI	R24,0x47
    00E61 E093      LDI	R25,3
    00E62 01F0      MOVW	R30,R0
    00E63 0FE8      ADD	R30,R24
    00E64 1FF9      ADC	R31,R25
    00E65 9020 03D1 LDS	R2,Dynamic_Offset_degree_char+1
    00E67 8220      ST	Z,R2
(1167) 					   }//if(redata==0xb5)
(1168) 			
(1169) 					   if(redata==0xb6)//第二关节偏移角，加1
    00E68 9180 0425 LDS	R24,redata
    00E6A 3B86      CPI	R24,0xB6
    00E6B F541      BNE	0x0E94
(1170) 					   {
(1171) 			  		    dd_tem=change_dd(d_tem);
    00E6C 9100 032E LDS	R16,d_tem
    00E6E DA7F      RCALL	_change_dd
    00E6F 2EA0      MOV	R10,R16
    00E70 92A0 032F STS	dd_tem,R10
(1172) 			  			flag=change_flag(d_tem);
    00E72 9100 032E LDS	R16,d_tem
    00E74 DA90      RCALL	_change_flag
    00E75 2EA0      MOV	R10,R16
    00E76 92A0 0330 STS	flag,R10
(1173) 			  			Dynamic_Offset_degree_char[1]++;
    00E78 9180 03D1 LDS	R24,Dynamic_Offset_degree_char+1
    00E7A 5F8F      SUBI	R24,0xFF
    00E7B 9380 03D1 STS	Dynamic_Offset_degree_char+1,R24
(1174) 			  			Dynamic_Offset_degree[1]=char2int(Dynamic_Offset_degree_char[1],flag);
    00E7D 2D2A      MOV	R18,R10
    00E7E 2F08      MOV	R16,R24
    00E7F 940E 065E CALL	_char2int
    00E81 0158      MOVW	R10,R16
    00E82 92B0 03CD STS	Dynamic_Offset_degree+3,R11
    00E84 92A0 03CC STS	Dynamic_Offset_degree+2,R10
(1175) 			  			init_dynamic_offset();			  
    00E86 940E 04B9 CALL	_init_dynamic_offset
(1176) 			  			Dynamic_Offset_degree_origin[dd_tem][1]=Dynamic_Offset_degree_char[1];
    00E88 9110 032F LDS	R17,dd_tem
    00E8A E003      LDI	R16,3
    00E8B 0301      MULSU	R16,R17
    00E8C E487      LDI	R24,0x47
    00E8D E093      LDI	R25,3
    00E8E 01F0      MOVW	R30,R0
    00E8F 0FE8      ADD	R30,R24
    00E90 1FF9      ADC	R31,R25
    00E91 9020 03D1 LDS	R2,Dynamic_Offset_degree_char+1
    00E93 8220      ST	Z,R2
(1177) 					   }//if(redata==0xb6)
(1178) 			
(1179) 					   if(redata==0xb7)//第三关节偏移角，减1
    00E94 9180 0425 LDS	R24,redata
    00E96 3B87      CPI	R24,0xB7
    00E97 F579      BNE	0x0EC7
(1180) 					   {
(1181) 			  		    dd_tem=change_dd(d_tem);
    00E98 9100 032E LDS	R16,d_tem
    00E9A DA53      RCALL	_change_dd
    00E9B 2EA0      MOV	R10,R16
    00E9C 92A0 032F STS	dd_tem,R10
(1182) 			  			flag=change_flag(d_tem);
    00E9E 9100 032E LDS	R16,d_tem
    00EA0 DA64      RCALL	_change_flag
    00EA1 2EA0      MOV	R10,R16
    00EA2 92A0 0330 STS	flag,R10
(1183) 			  			if(Dynamic_Offset_degree_char[1]==0)
    00EA4 9020 03D1 LDS	R2,Dynamic_Offset_degree_char+1
    00EA6 2022      TST	R2
    00EA7 F409      BNE	0x0EA9
(1184) 			  			{
(1185) 						}
    00EA8 C005      RJMP	0x0EAE
(1186) 			  			else
(1187) 			  			{
(1188) 			  			 Dynamic_Offset_degree_char[1]--;
    00EA9 9180 03D1 LDS	R24,Dynamic_Offset_degree_char+1
    00EAB 5081      SUBI	R24,1
    00EAC 9380 03D1 STS	Dynamic_Offset_degree_char+1,R24
(1189) 			  			}
(1190) 			  		   Dynamic_Offset_degree[2]=char2int(Dynamic_Offset_degree_char[2],flag);
    00EAE 9120 0330 LDS	R18,flag
    00EB0 9100 03D2 LDS	R16,Dynamic_Offset_degree_char+2
    00EB2 940E 065E CALL	_char2int
    00EB4 0158      MOVW	R10,R16
    00EB5 92B0 03CF STS	Dynamic_Offset_degree+5,R11
    00EB7 92A0 03CE STS	Dynamic_Offset_degree+4,R10
(1191) 			  		   init_dynamic_offset();			  
    00EB9 940E 04B9 CALL	_init_dynamic_offset
(1192) 			  		   Dynamic_Offset_degree_origin[dd_tem][2]=Dynamic_Offset_degree_char[2];
    00EBB 9110 032F LDS	R17,dd_tem
    00EBD E003      LDI	R16,3
    00EBE 0301      MULSU	R16,R17
    00EBF E488      LDI	R24,0x48
    00EC0 E093      LDI	R25,3
    00EC1 01F0      MOVW	R30,R0
    00EC2 0FE8      ADD	R30,R24
    00EC3 1FF9      ADC	R31,R25
    00EC4 9020 03D2 LDS	R2,Dynamic_Offset_degree_char+2
    00EC6 8220      ST	Z,R2
(1193) 					   }//if(redata==0xb7)
(1194) 			
(1195) 					   if(redata==0xb8)//第三关节偏移角，加1
    00EC7 9180 0425 LDS	R24,redata
    00EC9 3B88      CPI	R24,0xB8
    00ECA F541      BNE	0x0EF3
(1196) 					   {
(1197) 			  		   dd_tem=change_dd(d_tem);
    00ECB 9100 032E LDS	R16,d_tem
    00ECD DA20      RCALL	_change_dd
    00ECE 2EA0      MOV	R10,R16
    00ECF 92A0 032F STS	dd_tem,R10
(1198) 			  		   flag=change_flag(d_tem);
    00ED1 9100 032E LDS	R16,d_tem
    00ED3 DA31      RCALL	_change_flag
    00ED4 2EA0      MOV	R10,R16
    00ED5 92A0 0330 STS	flag,R10
(1199) 			  		   Dynamic_Offset_degree_char[2]++;
    00ED7 9180 03D2 LDS	R24,Dynamic_Offset_degree_char+2
    00ED9 5F8F      SUBI	R24,0xFF
    00EDA 9380 03D2 STS	Dynamic_Offset_degree_char+2,R24
(1200) 			  		   Dynamic_Offset_degree[2]=char2int(Dynamic_Offset_degree_char[2],flag);
    00EDC 2D2A      MOV	R18,R10
    00EDD 2F08      MOV	R16,R24
    00EDE 940E 065E CALL	_char2int
    00EE0 0158      MOVW	R10,R16
    00EE1 92B0 03CF STS	Dynamic_Offset_degree+5,R11
    00EE3 92A0 03CE STS	Dynamic_Offset_degree+4,R10
(1201) 			  		   init_dynamic_offset();			  
    00EE5 940E 04B9 CALL	_init_dynamic_offset
(1202) 			  		   Dynamic_Offset_degree_origin[dd_tem][2]=Dynamic_Offset_degree_char[2];
    00EE7 9110 032F LDS	R17,dd_tem
    00EE9 E003      LDI	R16,3
    00EEA 0301      MULSU	R16,R17
    00EEB E488      LDI	R24,0x48
    00EEC E093      LDI	R25,3
    00EED 01F0      MOVW	R30,R0
    00EEE 0FE8      ADD	R30,R24
    00EEF 1FF9      ADC	R31,R25
    00EF0 9020 03D2 LDS	R2,Dynamic_Offset_degree_char+2
    00EF2 8220      ST	Z,R2
(1203) 					   }//if(redata==0xb8)								
(1204) 					   senddata(redata); 
    00EF3 9100 0425 LDS	R16,redata
    00EF5 940E 02CA CALL	_senddata
(1205) 					   break;
    00EF7 C163      RJMP	0x105B
(1206) 			  
(1207) 
(1208) 				   case 0xc0:
(1209) 						isInstruction=1;
    00EF8 E081      LDI	R24,1
    00EF9 9380 0317 STS	isInstruction,R24
(1210) 			           if(redata==0xc1)//改第一关节摆动幅度
    00EFB 9180 0425 LDS	R24,redata
    00EFD 3C81      CPI	R24,0xC1
    00EFE F4B1      BNE	0x0F15
(1211) 					   {
(1212) 			  		     if(Amplitude_degree[0]==0)
    00EFF 9020 03EE LDS	R2,Amplitude_degree
    00F01 2022      TST	R2
    00F02 F409      BNE	0x0F04
(1213) 			  			 {
(1214) 			  			 }
    00F03 C005      RJMP	0x0F09
(1215) 			  			 else
(1216) 			  			 {
(1217) 			  			 Amplitude_degree[0]--;
    00F04 9180 03EE LDS	R24,Amplitude_degree
    00F06 5081      SUBI	R24,1
    00F07 9380 03EE STS	Amplitude_degree,R24
(1218) 			  			 }
(1219) 			  		   Amplitude_degree_tem[s_tem][0]=Amplitude_degree[0];//存为当前速度档的摆幅值
    00F09 9110 032C LDS	R17,s_tem
    00F0B E003      LDI	R16,3
    00F0C 0301      MULSU	R16,R17
    00F0D EF81      LDI	R24,0xF1
    00F0E E093      LDI	R25,3
    00F0F 01F0      MOVW	R30,R0
    00F10 0FE8      ADD	R30,R24
    00F11 1FF9      ADC	R31,R25
    00F12 9020 03EE LDS	R2,Amplitude_degree
    00F14 8220      ST	Z,R2
(1220) 					   }//if(redata==0xc1)
(1221) 					   
(1222) 					   if(redata==0xc2)
    00F15 9180 0425 LDS	R24,redata
    00F17 3C82      CPI	R24,0xC2
    00F18 F4B1      BNE	0x0F2F
(1223) 					   {
(1224) 			  		   	 if(Amplitude_degree[0]==90)
    00F19 9180 03EE LDS	R24,Amplitude_degree
    00F1B 358A      CPI	R24,0x5A
    00F1C F409      BNE	0x0F1E
(1225) 			 			 {
(1226) 			  			 }
    00F1D C005      RJMP	0x0F23
(1227) 			  			 else
(1228) 			  			 {
(1229) 			  			 Amplitude_degree[0]++;
    00F1E 9180 03EE LDS	R24,Amplitude_degree
    00F20 5F8F      SUBI	R24,0xFF
    00F21 9380 03EE STS	Amplitude_degree,R24
(1230) 			  			 }
(1231) 			  		  Amplitude_degree_tem[s_tem][0]=Amplitude_degree[0];
    00F23 9110 032C LDS	R17,s_tem
    00F25 E003      LDI	R16,3
    00F26 0301      MULSU	R16,R17
    00F27 EF81      LDI	R24,0xF1
    00F28 E093      LDI	R25,3
    00F29 01F0      MOVW	R30,R0
    00F2A 0FE8      ADD	R30,R24
    00F2B 1FF9      ADC	R31,R25
    00F2C 9020 03EE LDS	R2,Amplitude_degree
    00F2E 8220      ST	Z,R2
(1232) 					  }//if(redata==0xc2)	
(1233) 					  
(1234) 					  if(redata==0xc3)//改第二关节摆动幅度
    00F2F 9180 0425 LDS	R24,redata
    00F31 3C83      CPI	R24,0xC3
    00F32 F4B1      BNE	0x0F49
(1235) 					  {
(1236) 			 		   if(Amplitude_degree[1]==0)
    00F33 9020 03EF LDS	R2,Amplitude_degree+1
    00F35 2022      TST	R2
    00F36 F409      BNE	0x0F38
(1237) 			     	   {
(1238) 			 		   }
    00F37 C005      RJMP	0x0F3D
(1239) 			 		   else
(1240) 			           {
(1241) 			  		   Amplitude_degree[1]--;
    00F38 9180 03EF LDS	R24,Amplitude_degree+1
    00F3A 5081      SUBI	R24,1
    00F3B 9380 03EF STS	Amplitude_degree+1,R24
(1242) 			  		   }
(1243) 			  		  Amplitude_degree_tem[s_tem][1]=Amplitude_degree[1];
    00F3D 9110 032C LDS	R17,s_tem
    00F3F E003      LDI	R16,3
    00F40 0301      MULSU	R16,R17
    00F41 EF82      LDI	R24,0xF2
    00F42 E093      LDI	R25,3
    00F43 01F0      MOVW	R30,R0
    00F44 0FE8      ADD	R30,R24
    00F45 1FF9      ADC	R31,R25
    00F46 9020 03EF LDS	R2,Amplitude_degree+1
    00F48 8220      ST	Z,R2
(1244) 					  }//if(redata==0xc3)
(1245) 					  
(1246) 					  if(redata==0xc4)
    00F49 9180 0425 LDS	R24,redata
    00F4B 3C84      CPI	R24,0xC4
    00F4C F4B1      BNE	0x0F63
(1247) 					  {
(1248) 			  		   if(Amplitude_degree[1]==90)//90=0x5A
    00F4D 9180 03EF LDS	R24,Amplitude_degree+1
    00F4F 358A      CPI	R24,0x5A
    00F50 F409      BNE	0x0F52
(1249) 			  		   {
(1250) 			  		   }
    00F51 C005      RJMP	0x0F57
(1251) 			  		   else
(1252) 			  		   {
(1253) 			  		   Amplitude_degree[1]++;
    00F52 9180 03EF LDS	R24,Amplitude_degree+1
    00F54 5F8F      SUBI	R24,0xFF
    00F55 9380 03EF STS	Amplitude_degree+1,R24
(1254) 			  		   }
(1255) 			          Amplitude_degree_tem[s_tem][1]=Amplitude_degree[1];
    00F57 9110 032C LDS	R17,s_tem
    00F59 E003      LDI	R16,3
    00F5A 0301      MULSU	R16,R17
    00F5B EF82      LDI	R24,0xF2
    00F5C E093      LDI	R25,3
    00F5D 01F0      MOVW	R30,R0
    00F5E 0FE8      ADD	R30,R24
    00F5F 1FF9      ADC	R31,R25
    00F60 9020 03EF LDS	R2,Amplitude_degree+1
    00F62 8220      ST	Z,R2
(1256) 					  }//if(redata==0xc4)	
(1257) 					  
(1258) 					  if(redata==0xc5)//改第三关节摆动幅度
    00F63 9180 0425 LDS	R24,redata
    00F65 3C85      CPI	R24,0xC5
    00F66 F4B1      BNE	0x0F7D
(1259) 					  {
(1260) 			 		   if(Amplitude_degree[2]==0)
    00F67 9020 03F0 LDS	R2,Amplitude_degree+2
    00F69 2022      TST	R2
    00F6A F409      BNE	0x0F6C
(1261) 			 		   {
(1262) 			  		   }
    00F6B C005      RJMP	0x0F71
(1263) 			  		   else
(1264) 			  		   {
(1265) 			  		   Amplitude_degree[2]--;
    00F6C 9180 03F0 LDS	R24,Amplitude_degree+2
    00F6E 5081      SUBI	R24,1
    00F6F 9380 03F0 STS	Amplitude_degree+2,R24
(1266) 			  		   }
(1267) 			          Amplitude_degree_tem[s_tem][2]=Amplitude_degree[2];
    00F71 9110 032C LDS	R17,s_tem
    00F73 E003      LDI	R16,3
    00F74 0301      MULSU	R16,R17
    00F75 EF83      LDI	R24,0xF3
    00F76 E093      LDI	R25,3
    00F77 01F0      MOVW	R30,R0
    00F78 0FE8      ADD	R30,R24
    00F79 1FF9      ADC	R31,R25
    00F7A 9020 03F0 LDS	R2,Amplitude_degree+2
    00F7C 8220      ST	Z,R2
(1268) 					  }//if(redata==0xc5)
(1269) 					  
(1270) 					  if(redata==0xc6)
    00F7D 9180 0425 LDS	R24,redata
    00F7F 3C86      CPI	R24,0xC6
    00F80 F4B1      BNE	0x0F97
(1271) 					  {
(1272) 			           if(Amplitude_degree[2]==90)
    00F81 9180 03F0 LDS	R24,Amplitude_degree+2
    00F83 358A      CPI	R24,0x5A
    00F84 F409      BNE	0x0F86
(1273) 			           {
(1274) 			           }
    00F85 C005      RJMP	0x0F8B
(1275) 			           else
(1276) 			           { 
(1277) 			 		   Amplitude_degree[2]++;
    00F86 9180 03F0 LDS	R24,Amplitude_degree+2
    00F88 5F8F      SUBI	R24,0xFF
    00F89 9380 03F0 STS	Amplitude_degree+2,R24
(1278) 			  		   }
(1279) 			         Amplitude_degree_tem[s_tem][2]=Amplitude_degree[2];
    00F8B 9110 032C LDS	R17,s_tem
    00F8D E003      LDI	R16,3
    00F8E 0301      MULSU	R16,R17
    00F8F EF83      LDI	R24,0xF3
    00F90 E093      LDI	R25,3
    00F91 01F0      MOVW	R30,R0
    00F92 0FE8      ADD	R30,R24
    00F93 1FF9      ADC	R31,R25
    00F94 9020 03F0 LDS	R2,Amplitude_degree+2
    00F96 8220      ST	Z,R2
(1280) 					 }//if(redata==0xc6)
(1281) 					 
(1282) 					 if(redata==0xc7)//第二关节减滞后角
    00F97 9180 0425 LDS	R24,redata
    00F99 3C87      CPI	R24,0xC7
    00F9A F451      BNE	0x0FA5
(1283) 					 {
(1284) 			  		  if(Neighbouring_Offset_degree[1]==0)
    00F9B 9020 03EC LDS	R2,Neighbouring_Offset_degree+1
    00F9D 2022      TST	R2
    00F9E F409      BNE	0x0FA0
(1285) 			  		  {
(1286) 			  		  }
    00F9F C005      RJMP	0x0FA5
(1287) 			  		  else
(1288) 			  		  {
(1289) 			  		  Neighbouring_Offset_degree[1]--;
    00FA0 9180 03EC LDS	R24,Neighbouring_Offset_degree+1
    00FA2 5081      SUBI	R24,1
    00FA3 9380 03EC STS	Neighbouring_Offset_degree+1,R24
(1290) 			  		  }					  
(1291) 					 }//if(redata==0xc7)
(1292) 					 
(1293) 					 if(redata==0xc8)//第二关节加滞后角
    00FA5 9180 0425 LDS	R24,redata
    00FA7 3C88      CPI	R24,0xC8
    00FA8 F451      BNE	0x0FB3
(1294) 					 {
(1295) 			  		  if(Neighbouring_Offset_degree[1]==255)
    00FA9 9180 03EC LDS	R24,Neighbouring_Offset_degree+1
    00FAB 3F8F      CPI	R24,0xFF
    00FAC F409      BNE	0x0FAE
(1296) 			  		  {
(1297) 			  		  }
    00FAD C005      RJMP	0x0FB3
(1298) 			  		  else
(1299) 			  		  {
(1300) 			 		  Neighbouring_Offset_degree[1]++;
    00FAE 9180 03EC LDS	R24,Neighbouring_Offset_degree+1
    00FB0 5F8F      SUBI	R24,0xFF
    00FB1 9380 03EC STS	Neighbouring_Offset_degree+1,R24
(1301) 			  		  }
(1302) 					 }//if(redata==0xc8)
(1303) 					 
(1304) 					 if(redata==0xc9)//第三关节减滞后角
    00FB3 9180 0425 LDS	R24,redata
    00FB5 3C89      CPI	R24,0xC9
    00FB6 F451      BNE	0x0FC1
(1305) 					 {
(1306) 			  		  if(Neighbouring_Offset_degree[2]==0)
    00FB7 9020 03ED LDS	R2,Neighbouring_Offset_degree+2
    00FB9 2022      TST	R2
    00FBA F409      BNE	0x0FBC
(1307) 			  		  {
(1308) 			  		  }
    00FBB C005      RJMP	0x0FC1
(1309) 			  		  else
(1310) 			  		  {
(1311) 			  		  Neighbouring_Offset_degree[2]--;
    00FBC 9180 03ED LDS	R24,Neighbouring_Offset_degree+2
    00FBE 5081      SUBI	R24,1
    00FBF 9380 03ED STS	Neighbouring_Offset_degree+2,R24
(1312) 			  		  }
(1313) 					 }//if(redata==0xc9)
(1314) 					 
(1315) 					 if(redata==0xc0)//第三关节加滞后角
    00FC1 9180 0425 LDS	R24,redata
    00FC3 3C80      CPI	R24,0xC0
    00FC4 F451      BNE	0x0FCF
(1316) 					 {
(1317) 			  		  if(Neighbouring_Offset_degree[2]==255)
    00FC5 9180 03ED LDS	R24,Neighbouring_Offset_degree+2
    00FC7 3F8F      CPI	R24,0xFF
    00FC8 F409      BNE	0x0FCA
(1318) 			  		  {
(1319) 			  		  }
    00FC9 C005      RJMP	0x0FCF
(1320) 			  		  else
(1321) 			  		  {
(1322) 			  		  Neighbouring_Offset_degree[2]++;
    00FCA 9180 03ED LDS	R24,Neighbouring_Offset_degree+2
    00FCC 5F8F      SUBI	R24,0xFF
    00FCD 9380 03ED STS	Neighbouring_Offset_degree+2,R24
(1323) 			  		  }
(1324) 					 }//if(redata==0xc0)
(1325) 					 senddata(redata);
    00FCF 9100 0425 LDS	R16,redata
    00FD1 940E 02CA CALL	_senddata
(1326) 					 break;
    00FD3 C087      RJMP	0x105B
(1327) 
(1328) 	/////////----测试指令--END----//////////////
(1329) 
(1330) 			    case 0xf0://是否结束位
(1331) 			            if(redata==0xfc)
    00FD4 9180 0425 LDS	R24,redata
    00FD6 3F8C      CPI	R24,0xFC
    00FD7 F009      BEQ	0x0FD9
    00FD8 C082      RJMP	0x105B
(1332) 						{
(1333) 							e_change=1;//
    00FD9 E081      LDI	R24,1
    00FDA 9380 0314 STS	e_change,R24
(1334) 							is_uart=1; //退出自动模式，进入手动控制模式
    00FDC 9380 0319 STS	is_uart,R24
(1335) 						}//if(redata==0xfc)
(1336) 						break;		
    00FDE C07C      RJMP	0x105B
(1337) 			    default://接收到的不是指令也不是结束位，重新接收下一次命令
(1338) 			  	      isSrlStart=0;
    00FDF 2422      CLR	R2
    00FE0 9220 0307 STS	isSrlStart,R2
(1339) 					  addr=0;
    00FE2 9220 0309 STS	addr,R2
(1340) 			     }//switch(redata&0xf0)
(1341) 			  } //if(isInstruction==1) else
(1342) 			  
(1343) 		   }//if(addr)
    00FE4 C076      RJMP	0x105B
(1344) 		   
(1345) 		   else//地址码没接收，或已经接收但不匹配
(1346) 		   {
(1347) 		     if(redata==(0x90|FISHID[0]))//接收地址码，匹配，置位标志位
    00FE5 9180 010A LDS	R24,FISHID
    00FE7 6980      ORI	R24,0x90
    00FE8 9020 0425 LDS	R2,redata
    00FEA 1628      CP	R2,R24
    00FEB F421      BNE	0x0FF0
(1348) 			 {
(1349) 			 addr=1;
    00FEC E081      LDI	R24,1
    00FED 9380 0309 STS	addr,R24
(1350) 			 }//if(redata==(0x90|FISHID))
    00FEF C06B      RJMP	0x105B
(1351) 			 
(1352) 			 else//地址码不匹配，清零开始位标志位，重新接收下一次指令
(1353) 			 {
(1354) 			 isSrlStart=0;
    00FF0 2422      CLR	R2
    00FF1 9220 0307 STS	isSrlStart,R2
(1355) 			 }//if(redata==(0x90|FISHID)) else
(1356) 			 
(1357) 		   }//if(addr) else
(1358) 		   
(1359) 		 }//if(isSrlStart)
    00FF3 C067      RJMP	0x105B
(1360) 
(1361) 	/////////----初始化i2c的通信协议--BEGIN----//////////////
(1362) 
(1363) 		 else if(isSrlStartI2c)//若已经发送初始化i2c的起始位，判断地址码（0x74，起确定指令的作用）是否匹配
    00FF4 9020 0308 LDS	R2,isSrlStartI2c
    00FF6 2022      TST	R2
    00FF7 F409      BNE	0x0FF9
    00FF8 C054      RJMP	0x104D
(1364) 		 {
(1365) 			 if(addrI2c)//若地址码已经匹配，准备接收命令
    00FF9 9020 030A LDS	R2,addrI2c
    00FFB 2022      TST	R2
    00FFC F409      BNE	0x0FFE
    00FFD C043      RJMP	0x1041
(1366) 			 {
(1367) 				 if(isInstructionI2c)//已经接受过命令了，那么判断是否是结束位
    00FFE 9020 0318 LDS	R2,isInstructionI2c
    01000 2022      TST	R2
    01001 F091      BEQ	0x1014
(1368) 				 {
(1369) 					 if(redata==0xfb)
    01002 9180 0425 LDS	R24,redata
    01004 3F8B      CPI	R24,0xFB
    01005 F431      BNE	0x100C
(1370) 					 {
(1371) 						 i2c_change=1;
    01006 E081      LDI	R24,1
    01007 9380 0316 STS	i2c_change,R24
(1372) 						 is_uart=1;
    01009 9380 0319 STS	is_uart,R24
(1373) 					 }
    0100B C04F      RJMP	0x105B
(1374) 					 else//接收到的不是结束位，那么这条指令无效，重新接收下一次命令
(1375) 					 {
(1376) 						 isSrlStartI2c=0;
    0100C 2422      CLR	R2
    0100D 9220 0308 STS	isSrlStartI2c,R2
(1377) 						 addrI2c=0;
    0100F 9220 030A STS	addrI2c,R2
(1378) 						 isInstructionI2c=0;
    01011 9220 0318 STS	isInstructionI2c,R2
(1379) 					 }
(1380) 				 }
    01013 C047      RJMP	0x105B
(1381) 				 else//没有接收命令，则接收命令
(1382) 				 {
(1383) 					 switch(redata&0xf0)
    01014 9140 0425 LDS	R20,redata
    01016 2755      CLR	R21
    01017 7F40      ANDI	R20,0xF0
    01018 7050      ANDI	R21,0
    01019 3840      CPI	R20,0x80
    0101A E0E0      LDI	R30,0
    0101B 075E      CPC	R21,R30
    0101C F049      BEQ	0x1026
    0101D 3840      CPI	R20,0x80
    0101E E0E0      LDI	R30,0
    0101F 075E      CPC	R21,R30
    01020 F0CC      BLT	0x103A
    01021 3F4B      CPI	R20,0xFB
    01022 E0E0      LDI	R30,0
    01023 075E      CPC	R21,R30
    01024 F059      BEQ	0x1030
    01025 C014      RJMP	0x103A
(1384) 					 {
(1385) 					 case 0x80:
(1386) 						 redata_i2c=redata;
    01026 9020 0425 LDS	R2,redata
    01028 9220 0423 STS	redata_i2c,R2
(1387) 						 i_change=1;
    0102A E081      LDI	R24,1
    0102B 9380 0315 STS	i_change,R24
(1388) 						 isInstructionI2c=1;
    0102D 9380 0318 STS	isInstructionI2c,R24
(1389) 						 break;
    0102F C02B      RJMP	0x105B
(1390) 					 case 0xfb:
(1391) 						 if(redata==0xfb)
    01030 9180 0425 LDS	R24,redata
    01032 3F8B      CPI	R24,0xFB
    01033 F539      BNE	0x105B
(1392) 						 {
(1393) 							 i2c_change=1;
    01034 E081      LDI	R24,1
    01035 9380 0316 STS	i2c_change,R24
(1394) 							  is_uart=1;
    01037 9380 0319 STS	is_uart,R24
(1395) 						 }
(1396) 						 break;
    01039 C021      RJMP	0x105B
(1397) 					 default:
(1398) 						 isSrlStartI2c=1;
    0103A E081      LDI	R24,1
    0103B 9380 0308 STS	isSrlStartI2c,R24
(1399) 						 addrI2c=0;
    0103D 2422      CLR	R2
    0103E 9220 030A STS	addrI2c,R2
(1400) 						 break;
(1401) 					 }
(1402) 				 }					 
(1403) 			 }
    01040 C01A      RJMP	0x105B
(1404) 
(1405) 
(1406) 			 else//地址码没有接收，或者已接收但不匹配
(1407) 			 {
(1408) 				 if(redata==0x74)//接收地址码，匹配，置位标志位
    01041 9180 0425 LDS	R24,redata
    01043 3784      CPI	R24,0x74
    01044 F421      BNE	0x1049
(1409) 				 {
(1410) 					 addrI2c=1;
    01045 E081      LDI	R24,1
    01046 9380 030A STS	addrI2c,R24
(1411) 				 }
    01048 C012      RJMP	0x105B
(1412) 				 else//地址码不匹配，清零开始位标志位，重新接收下一次指令
(1413) 				 {
(1414) 					 isSrlStartI2c=0;
    01049 2422      CLR	R2
    0104A 9220 0308 STS	isSrlStartI2c,R2
(1415) 				 }					
(1416) 			 }
(1417) 		 }
    0104C C00E      RJMP	0x105B
(1418) 		 else
(1419) 		 {
(1420) 		    if(redata==0xaa)//判断起始位，置位标志位
    0104D 9180 0425 LDS	R24,redata
    0104F 3A8A      CPI	R24,0xAA
    01050 F419      BNE	0x1054
(1421) 			{
(1422) 			  isSrlStart=1;
    01051 E081      LDI	R24,1
    01052 9380 0307 STS	isSrlStart,R24
(1423) 			}
(1424) 			if(redata==0xcc)//判断初始化i2c的起始位
    01054 9180 0425 LDS	R24,redata
    01056 3C8C      CPI	R24,0xCC
    01057 F419      BNE	0x105B
(1425) 			{
(1426) 				isSrlStartI2c=1;
    01058 E081      LDI	R24,1
    01059 9380 0308 STS	isSrlStartI2c,R24
(1427) 			}
(1428) 		 }//if(isSrlStart) else
(1429) 
(1430) 	/////////----初始化i2c的通信协议--END----//////////////
(1431) 
(1432) 	}//if(1)
    0105B 940E 1AD7 CALL	pop_xgset300C
    0105D 9009      LD	R0,Y+
    0105E BE0F      OUT	0x3F,R0
    0105F 91F9      LD	R31,Y+
    01060 91E9      LD	R30,Y+
    01061 91B9      LD	R27,Y+
    01062 91A9      LD	R26,Y+
    01063 9199      LD	R25,Y+
    01064 9189      LD	R24,Y+
    01065 9139      LD	R19,Y+
    01066 9129      LD	R18,Y+
    01067 9119      LD	R17,Y+
    01068 9109      LD	R16,Y+
    01069 9099      LD	R9,Y+
    0106A 9089      LD	R8,Y+
    0106B 9079      LD	R7,Y+
    0106C 9069      LD	R6,Y+
    0106D 9059      LD	R5,Y+
    0106E 9049      LD	R4,Y+
    0106F 9039      LD	R3,Y+
    01070 9029      LD	R2,Y+
    01071 9019      LD	R1,Y+
    01072 9009      LD	R0,Y+
    01073 9518      RETI
_timer3_ovf_isr:
  i                    --> Y,+1
    01074 920A      ST	-Y,R0
    01075 921A      ST	-Y,R1
    01076 922A      ST	-Y,R2
    01077 923A      ST	-Y,R3
    01078 924A      ST	-Y,R4
    01079 925A      ST	-Y,R5
    0107A 926A      ST	-Y,R6
    0107B 927A      ST	-Y,R7
    0107C 928A      ST	-Y,R8
    0107D 929A      ST	-Y,R9
    0107E 930A      ST	-Y,R16
    0107F 931A      ST	-Y,R17
    01080 932A      ST	-Y,R18
    01081 933A      ST	-Y,R19
    01082 938A      ST	-Y,R24
    01083 939A      ST	-Y,R25
    01084 93AA      ST	-Y,R26
    01085 93BA      ST	-Y,R27
    01086 93EA      ST	-Y,R30
    01087 93FA      ST	-Y,R31
    01088 B60F      IN	R0,0x3F
    01089 920A      ST	-Y,R0
(1433) }
(1434) 
(1435) 
(1436) //***********************************计数器3溢出中断*****************************
(1437) #pragma interrupt_handler timer3_ovf_isr:30
(1438) void timer3_ovf_isr(void)
(1439) {
(1440)   unsigned char i;
(1441)   
(1442)  TCNT3H = 0x00 ; //reload counter high value  INVALID SETTING
    0108A 2422      CLR	R2
    0108B 9220 0089 STS	0x89,R2
(1443)  TCNT3L = 0x00 ; //reload counter low value   INVALID SETTING
    0108D 9220 0088 STS	0x88,R2
(1444)  
(1445)  if(Speed!=0)   //即没有启动则一直1500，中间位置
    0108F 9020 0100 LDS	R2,Speed
    01091 2022      TST	R2
    01092 F059      BEQ	0x109E
(1446)  {
(1447)     Instant++;
    01093 9180 0101 LDS	R24,Instant
    01095 5F8F      SUBI	R24,0xFF
    01096 9380 0101 STS	Instant,R24
(1448)   	Instant=Instant%Speed;
    01098 2D12      MOV	R17,R2
    01099 2F08      MOV	R16,R24
    0109A 940E 1A74 CALL	mod8u
    0109C 9300 0101 STS	Instant,R16
(1449)  }
(1450)  	t_dynamic++;
    0109E 9180 0105 LDS	R24,t_dynamic
    010A0 5F8F      SUBI	R24,0xFF
    010A1 9380 0105 STS	t_dynamic,R24
(1451) 	if(t_dynamic>Speed)
    010A3 9020 0100 LDS	R2,Speed
    010A5 2433      CLR	R3
    010A6 2E48      MOV	R4,R24
    010A7 2455      CLR	R5
    010A8 1424      CP	R2,R4
    010A9 0435      CPC	R3,R5
    010AA F414      BGE	0x10AD
(1452) 	{
(1453) 	  t_dynamic=Speed;
    010AB 9220 0105 STS	t_dynamic,R2
(1454) 	}	
(1455)     calculate_data();
    010AD 940E 04E5 CALL	_calculate_data
(1456) 	OCR3A=Joint_Angle_value[2];
    010AF 9020 03C2 LDS	R2,Joint_Angle_value+4
    010B1 9030 03C3 LDS	R3,Joint_Angle_value+5
    010B3 9230 0087 STS	0x87,R3
    010B5 9220 0086 STS	0x86,R2
    010B7 9009      LD	R0,Y+
    010B8 BE0F      OUT	0x3F,R0
    010B9 91F9      LD	R31,Y+
    010BA 91E9      LD	R30,Y+
    010BB 91B9      LD	R27,Y+
    010BC 91A9      LD	R26,Y+
    010BD 9199      LD	R25,Y+
    010BE 9189      LD	R24,Y+
    010BF 9139      LD	R19,Y+
    010C0 9129      LD	R18,Y+
    010C1 9119      LD	R17,Y+
    010C2 9109      LD	R16,Y+
    010C3 9099      LD	R9,Y+
    010C4 9089      LD	R8,Y+
    010C5 9079      LD	R7,Y+
    010C6 9069      LD	R6,Y+
    010C7 9059      LD	R5,Y+
    010C8 9049      LD	R4,Y+
    010C9 9039      LD	R3,Y+
    010CA 9029      LD	R2,Y+
    010CB 9019      LD	R1,Y+
    010CC 9009      LD	R0,Y+
    010CD 9518      RETI
_timer1_ovf_isr:
  i                    --> Y,+1
    010CE 920A      ST	-Y,R0
    010CF 921A      ST	-Y,R1
    010D0 922A      ST	-Y,R2
    010D1 923A      ST	-Y,R3
    010D2 924A      ST	-Y,R4
    010D3 925A      ST	-Y,R5
    010D4 926A      ST	-Y,R6
    010D5 927A      ST	-Y,R7
    010D6 928A      ST	-Y,R8
    010D7 929A      ST	-Y,R9
    010D8 930A      ST	-Y,R16
    010D9 931A      ST	-Y,R17
    010DA 932A      ST	-Y,R18
    010DB 933A      ST	-Y,R19
    010DC 938A      ST	-Y,R24
    010DD 939A      ST	-Y,R25
    010DE 93AA      ST	-Y,R26
    010DF 93BA      ST	-Y,R27
    010E0 93EA      ST	-Y,R30
    010E1 93FA      ST	-Y,R31
    010E2 B60F      IN	R0,0x3F
    010E3 920A      ST	-Y,R0
(1457) 	/*wang genghai*/
(1458) 	//OCR3B=Joint_Angle_value[2];	   
(1459)  
(1460) }
(1461) 
(1462) //***********************************计数器1溢出中断*****************************
(1463) #pragma interrupt_handler timer1_ovf_isr:15
(1464) void timer1_ovf_isr(void)
(1465) {
(1466)     unsigned char i;
(1467)   
(1468)     TCNT1H = 0x00 ; //reload counter high value  INVALID SETTING
    010E4 2422      CLR	R2
    010E5 BC2D      OUT	0x2D,R2
(1469)     TCNT1L = 0x00 ; //reload counter low value   INVALID SETTING
    010E6 BC2C      OUT	0x2C,R2
(1470)  
(1471)     if(Speed!=0)   //即没有启动则一直1500，中间位置
    010E7 9020 0100 LDS	R2,Speed
    010E9 2022      TST	R2
    010EA F059      BEQ	0x10F6
(1472)     {
(1473)           Instant++;
    010EB 9180 0101 LDS	R24,Instant
    010ED 5F8F      SUBI	R24,0xFF
    010EE 9380 0101 STS	Instant,R24
(1474) 		    //注意，在两个定时器的中断中，都增加了Instant++，实际是不必要的，只在一个定时器中断加就可以了。
(1475) 	        //两处都加和只加一处的区别，只是电机运动快了，因为两处都加，相当于离散点的间隔是原来的一半（原来20ms，现在10ms）。理论分析时注意即可，不影响使用。
(1476) 	        //详细解释  （一个摆动周期T定义为 左边――中间――右边――中间――左边）
(1477) 	        //只在一处加Instant++：一个摆动周期被离散为speed份，每份间隔20ms，即，T=（speed-1）X20    此时最快速度时用speed=23
(1478) 	        //两处都加Instant++：一个摆动周期被离散为speed份，每份间隔20/2ms，即，T=（speed-1）X10    此时最快速度时用speed=45(与上面23一个效果) 
(1479) 	        //以上计算公式有误差，修正如下――09.06.25
(1480) 			//只在一处加Instant++：一个摆动周期被离散为speed份，每份间隔20ms，即，T=（speed）X20    此时最快速度时用speed=23
(1481) 			//两处都加Instant++：一个摆动周期被离散为speed份，每份间隔20/2ms，即，T=（speed）X10    此时最快速度时用speed=45(与上面23一个效果)
(1482)   	    Instant=Instant%Speed;
    010F0 2D12      MOV	R17,R2
    010F1 2F08      MOV	R16,R24
    010F2 940E 1A74 CALL	mod8u
    010F4 9300 0101 STS	Instant,R16
(1483)    }
(1484)     calculate_data(); 
    010F6 940E 04E5 CALL	_calculate_data
(1485) 	OCR1A=Joint_Angle_value[0];	 
    010F8 9020 03BE LDS	R2,Joint_Angle_value
    010FA 9030 03BF LDS	R3,Joint_Angle_value+1
    010FC BC3B      OUT	0x2B,R3
    010FD BC2A      OUT	0x2A,R2
(1486) 	OCR1B=Joint_Angle_value[1];  
    010FE 9020 03C0 LDS	R2,Joint_Angle_value+2
    01100 9030 03C1 LDS	R3,Joint_Angle_value+3
    01102 BC39      OUT	0x29,R3
    01103 BC28      OUT	0x28,R2
    01104 9009      LD	R0,Y+
    01105 BE0F      OUT	0x3F,R0
    01106 91F9      LD	R31,Y+
    01107 91E9      LD	R30,Y+
    01108 91B9      LD	R27,Y+
    01109 91A9      LD	R26,Y+
    0110A 9199      LD	R25,Y+
    0110B 9189      LD	R24,Y+
    0110C 9139      LD	R19,Y+
    0110D 9129      LD	R18,Y+
    0110E 9119      LD	R17,Y+
    0110F 9109      LD	R16,Y+
    01110 9099      LD	R9,Y+
    01111 9089      LD	R8,Y+
    01112 9079      LD	R7,Y+
    01113 9069      LD	R6,Y+
    01114 9059      LD	R5,Y+
    01115 9049      LD	R4,Y+
    01116 9039      LD	R3,Y+
    01117 9029      LD	R2,Y+
    01118 9019      LD	R1,Y+
    01119 9009      LD	R0,Y+
    0111A 9518      RETI
_main:
  tem_y                --> R22
  tem                  --> R22
  j                    --> R10
  i                    --> R20
    0111B 972A      SBIW	R28,0xA
(1487) }
(1488) //*************************************************************************
(1489) //********************************主函数***********************************
(1490) //*************************************************************************
(1491) void main(void)
(1492) {   
(1493)      unsigned char i;
(1494)   	 unsigned char tem;
(1495) 	 unsigned char tem_y;
(1496) 	 unsigned char j; 
(1497)  	 init_devices();//初始化
    0111C 940E 02B6 CALL	_init_devices
(1498) 	 TWI_Master_Initialise(); //*IIC控制初始化
    0111E 940E 18EE CALL	_TWI_Master_Initialise
(1499) 	 SEI();
    01120 9478      BSET	7
(1500)      /////////////////////////////////////////////////////
(1501) 	 //读i2c数据
(1502) 	 i2c_read(ADD_i,FISHID_I2C,FISHID,1);
    01121 E081      LDI	R24,1
    01122 838A      STD	Y+2,R24
    01123 E08A      LDI	R24,0xA
    01124 E091      LDI	R25,1
    01125 8399      STD	Y+1,R25
    01126 8388      ST	Y,R24
    01127 E02C      LDI	R18,0xC
    01128 E031      LDI	R19,1
    01129 E100      LDI	R16,0x10
    0112A D80A      RCALL	_i2c_read
(1503) 	 i2c_read(ADD_f,freqs_I2C,freqs,1);
    0112B E081      LDI	R24,1
    0112C 838A      STD	Y+2,R24
    0112D E08F      LDI	R24,0xF
    0112E E091      LDI	R25,1
    0112F 8399      STD	Y+1,R25
    01130 8388      ST	Y,R24
    01131 E121      LDI	R18,0x11
    01132 E031      LDI	R19,1
    01133 E200      LDI	R16,0x20
    01134 D800      RCALL	_i2c_read
(1504) 	 //PORTD=freq[freqs[0]];
(1505) 	 i2c_read(ADD_t,degree_I2C,Static_Offset_degree,3);
    01135 E083      LDI	R24,3
    01136 838A      STD	Y+2,R24
    01137 E184      LDI	R24,0x14
    01138 E091      LDI	R25,1
    01139 8399      STD	Y+1,R25
    0113A 8388      ST	Y,R24
    0113B E12A      LDI	R18,0x1A
    0113C E031      LDI	R19,1
    0113D E300      LDI	R16,0x30
    0113E 940E 0935 CALL	_i2c_read
(1506) 	 i2c_read(ADD_s1,Speed_tem_I2C1,Speed_tem_z1,8);
    01140 E088      LDI	R24,0x8
    01141 838A      STD	Y+2,R24
    01142 E681      LDI	R24,0x61
    01143 E091      LDI	R25,1
    01144 8399      STD	Y+1,R25
    01145 8388      ST	Y,R24
    01146 E721      LDI	R18,0x71
    01147 E031      LDI	R19,1
    01148 E400      LDI	R16,0x40
    01149 940E 0935 CALL	_i2c_read
(1507) 	 i2c_read(ADD_s2,Speed_tem_I2C2,Speed_tem_z2,8);
    0114B E088      LDI	R24,0x8
    0114C 838A      STD	Y+2,R24
    0114D E689      LDI	R24,0x69
    0114E E091      LDI	R25,1
    0114F 8399      STD	Y+1,R25
    01150 8388      ST	Y,R24
    01151 E72B      LDI	R18,0x7B
    01152 E031      LDI	R19,1
    01153 E408      LDI	R16,0x48
    01154 940E 0935 CALL	_i2c_read
(1508) 	 two2one(Speed_tem_z,Speed_tem_z1,Speed_tem_z2);
    01156 E689      LDI	R24,0x69
    01157 E091      LDI	R25,1
    01158 8399      STD	Y+1,R25
    01159 8388      ST	Y,R24
    0115A E621      LDI	R18,0x61
    0115B E031      LDI	R19,1
    0115C E501      LDI	R16,0x51
    0115D E011      LDI	R17,1
    0115E 940E 06AC CALL	_two2one
(1509) 	 for(i=0;i<=15;i++)
    01160 2744      CLR	R20
    01161 C00F      RJMP	0x1171
(1510) 	 {
(1511) 	      Speed_tem[i]=Speed_tem_z[i];    //Speed_tem[i] = Speed_Amplitudeem_z[i];//Speed_Amplitudeem_z[i];//*为什么会有错？？
    01162 E581      LDI	R24,0x51
    01163 E091      LDI	R25,1
    01164 2FE4      MOV	R30,R20
    01165 27FF      CLR	R31
    01166 0FE8      ADD	R30,R24
    01167 1FF9      ADC	R31,R25
    01168 8020      LD	R2,Z
    01169 E386      LDI	R24,0x36
    0116A E093      LDI	R25,3
    0116B 2FE4      MOV	R30,R20
    0116C 27FF      CLR	R31
    0116D 0FE8      ADD	R30,R24
    0116E 1FF9      ADC	R31,R25
    0116F 8220      ST	Z,R2
    01170 9543      INC	R20
    01171 E08F      LDI	R24,0xF
    01172 1784      CP	R24,R20
    01173 F770      BCC	0x1162
(1512) 	 }
(1513) 	 i2c_read(ADD_d,Neighbouring_Offset_degree_I2C,Neighbouring_Offset_degree,3);
    01174 E083      LDI	R24,3
    01175 838A      STD	Y+2,R24
    01176 EE8B      LDI	R24,0xEB
    01177 E093      LDI	R25,3
    01178 8399      STD	Y+1,R25
    01179 8388      ST	Y,R24
    0117A E828      LDI	R18,0x88
    0117B E031      LDI	R19,1
    0117C E500      LDI	R16,0x50
    0117D 940E 0935 CALL	_i2c_read
(1514) 	 i2c_read(ADD_1,Amplitude_degree_tem_I2C1,Amplitude_degree_tem_z1,8);
    0117F E088      LDI	R24,0x8
    01180 838A      STD	Y+2,R24
    01181 E18D      LDI	R24,0x1D
    01182 E092      LDI	R25,2
    01183 8399      STD	Y+1,R25
    01184 8388      ST	Y,R24
    01185 E42D      LDI	R18,0x4D
    01186 E032      LDI	R19,2
    01187 E600      LDI	R16,0x60
    01188 940E 0935 CALL	_i2c_read
(1515) 	 i2c_read(ADD_2,Amplitude_degree_tem_I2C2,Amplitude_degree_tem_z2,8);
    0118A E088      LDI	R24,0x8
    0118B 838A      STD	Y+2,R24
    0118C E285      LDI	R24,0x25
    0118D E092      LDI	R25,2
    0118E 8399      STD	Y+1,R25
    0118F 8388      ST	Y,R24
    01190 E527      LDI	R18,0x57
    01191 E032      LDI	R19,2
    01192 E608      LDI	R16,0x68
    01193 940E 0935 CALL	_i2c_read
(1516) 	 i2c_read(ADD_3,Amplitude_degree_tem_I2C3,Amplitude_degree_tem_z3,8);
    01195 E088      LDI	R24,0x8
    01196 838A      STD	Y+2,R24
    01197 E28D      LDI	R24,0x2D
    01198 E092      LDI	R25,2
    01199 8399      STD	Y+1,R25
    0119A 8388      ST	Y,R24
    0119B E621      LDI	R18,0x61
    0119C E032      LDI	R19,2
    0119D E700      LDI	R16,0x70
    0119E 940E 0935 CALL	_i2c_read
(1517) 	 i2c_read(ADD_4,Amplitude_degree_tem_I2C4,Amplitude_degree_tem_z4,8);
    011A0 E088      LDI	R24,0x8
    011A1 838A      STD	Y+2,R24
    011A2 E385      LDI	R24,0x35
    011A3 E092      LDI	R25,2
    011A4 8399      STD	Y+1,R25
    011A5 8388      ST	Y,R24
    011A6 E62B      LDI	R18,0x6B
    011A7 E032      LDI	R19,2
    011A8 E708      LDI	R16,0x78
    011A9 940E 0935 CALL	_i2c_read
(1518) 	 i2c_read(ADD_5,Amplitude_degree_tem_I2C5,Amplitude_degree_tem_z5,8);
    011AB E088      LDI	R24,0x8
    011AC 838A      STD	Y+2,R24
    011AD E38D      LDI	R24,0x3D
    011AE E092      LDI	R25,2
    011AF 8399      STD	Y+1,R25
    011B0 8388      ST	Y,R24
    011B1 E725      LDI	R18,0x75
    011B2 E032      LDI	R19,2
    011B3 E800      LDI	R16,0x80
    011B4 940E 0935 CALL	_i2c_read
(1519) 	 i2c_read(ADD_6,Amplitude_degree_tem_I2C6,Amplitude_degree_tem_z6,8);
    011B6 E088      LDI	R24,0x8
    011B7 838A      STD	Y+2,R24
    011B8 E485      LDI	R24,0x45
    011B9 E092      LDI	R25,2
    011BA 8399      STD	Y+1,R25
    011BB 8388      ST	Y,R24
    011BC E72F      LDI	R18,0x7F
    011BD E032      LDI	R19,2
    011BE E808      LDI	R16,0x88
    011BF 940E 0935 CALL	_i2c_read
(1520) 	 six2one(Amplitude_degree_tem_z,Amplitude_degree_tem_z1,Amplitude_degree_tem_z2,Amplitude_degree_tem_z3,Amplitude_degree_tem_z4,Amplitude_degree_tem_z5,Amplitude_degree_tem_z6);  
    011C1 E485      LDI	R24,0x45
    011C2 E092      LDI	R25,2
    011C3 8799      STD	Y+9,R25
    011C4 8788      STD	Y+8,R24
    011C5 E38D      LDI	R24,0x3D
    011C6 E092      LDI	R25,2
    011C7 839F      STD	Y+7,R25
    011C8 838E      STD	Y+6,R24
    011C9 E385      LDI	R24,0x35
    011CA E092      LDI	R25,2
    011CB 839D      STD	Y+5,R25
    011CC 838C      STD	Y+4,R24
    011CD E28D      LDI	R24,0x2D
    011CE E092      LDI	R25,2
    011CF 839B      STD	Y+3,R25
    011D0 838A      STD	Y+2,R24
    011D1 E285      LDI	R24,0x25
    011D2 E092      LDI	R25,2
    011D3 8399      STD	Y+1,R25
    011D4 8388      ST	Y,R24
    011D5 E12D      LDI	R18,0x1D
    011D6 E032      LDI	R19,2
    011D7 EE0D      LDI	R16,0xED
    011D8 E011      LDI	R17,1
    011D9 940E 0844 CALL	_six2one
(1521) 	 for(i=0;i<=47;i++)
    011DB 2744      CLR	R20
    011DC C01F      RJMP	0x11FC
(1522) 	 {
(1523) 		Amplitude_degree_tem[i/3][i%3]=Amplitude_degree_tem_z[i];
    011DD E013      LDI	R17,3
    011DE 2F04      MOV	R16,R20
    011DF 940E 1A76 CALL	div8u
    011E1 E083      LDI	R24,3
    011E2 2F10      MOV	R17,R16
    011E3 2F08      MOV	R16,R24
    011E4 0301      MULSU	R16,R17
    011E5 0110      MOVW	R2,R0
    011E6 EF81      LDI	R24,0xF1
    011E7 E093      LDI	R25,3
    011E8 0E28      ADD	R2,R24
    011E9 1E39      ADC	R3,R25
    011EA E023      LDI	R18,3
    011EB E030      LDI	R19,0
    011EC 2F04      MOV	R16,R20
    011ED 2711      CLR	R17
    011EE 940E 1A3A CALL	mod16s
    011F0 01F8      MOVW	R30,R16
    011F1 0DE2      ADD	R30,R2
    011F2 1DF3      ADC	R31,R3
    011F3 EE8D      LDI	R24,0xED
    011F4 E091      LDI	R25,1
    011F5 2FA4      MOV	R26,R20
    011F6 27BB      CLR	R27
    011F7 0FA8      ADD	R26,R24
    011F8 1FB9      ADC	R27,R25
    011F9 902C      LD	R2,X
    011FA 8220      ST	Z,R2
    011FB 9543      INC	R20
    011FC E28F      LDI	R24,0x2F
    011FD 1784      CP	R24,R20
    011FE F6F0      BCC	0x11DD
(1524) 	 }	
(1525) 	 i2c_read(ADD_10,Dynamic_Offset_degree_origin_I2C1,Dynamic_Offset_degree_origin_z1,8);
    011FF E088      LDI	R24,0x8
    01200 838A      STD	Y+2,R24
    01201 ED81      LDI	R24,0xD1
    01202 E092      LDI	R25,2
    01203 8399      STD	Y+1,R25
    01204 8388      ST	Y,R24
    01205 EE29      LDI	R18,0xE9
    01206 E032      LDI	R19,2
    01207 E900      LDI	R16,0x90
    01208 940E 0935 CALL	_i2c_read
(1526) 	 i2c_read(ADD_20,Dynamic_Offset_degree_origin_I2C2,Dynamic_Offset_degree_origin_z2,8);
    0120A E088      LDI	R24,0x8
    0120B 838A      STD	Y+2,R24
    0120C ED89      LDI	R24,0xD9
    0120D E092      LDI	R25,2
    0120E 8399      STD	Y+1,R25
    0120F 8388      ST	Y,R24
    01210 EF23      LDI	R18,0xF3
    01211 E032      LDI	R19,2
    01212 E908      LDI	R16,0x98
    01213 940E 0935 CALL	_i2c_read
(1527) 	 i2c_read(ADD_30,Dynamic_Offset_degree_origin_I2C3,Dynamic_Offset_degree_origin_z3,8);
    01215 E088      LDI	R24,0x8
    01216 838A      STD	Y+2,R24
    01217 EE81      LDI	R24,0xE1
    01218 E092      LDI	R25,2
    01219 8399      STD	Y+1,R25
    0121A 8388      ST	Y,R24
    0121B EF2D      LDI	R18,0xFD
    0121C E032      LDI	R19,2
    0121D EA00      LDI	R16,0xA0
    0121E 940E 0935 CALL	_i2c_read
(1528) 	 three2one(Dynamic_Offset_degree_origin_z,Dynamic_Offset_degree_origin_z1,Dynamic_Offset_degree_origin_z2,Dynamic_Offset_degree_origin_z3);  
    01220 EE81      LDI	R24,0xE1
    01221 E092      LDI	R25,2
    01222 839B      STD	Y+3,R25
    01223 838A      STD	Y+2,R24
    01224 ED89      LDI	R24,0xD9
    01225 E092      LDI	R25,2
    01226 8399      STD	Y+1,R25
    01227 8388      ST	Y,R24
    01228 ED21      LDI	R18,0xD1
    01229 E032      LDI	R19,2
    0122A EB09      LDI	R16,0xB9
    0122B E012      LDI	R17,2
    0122C 940E 073F CALL	_three2one
(1529) 	 for(i=0;i<=23;i++)
    0122E 2744      CLR	R20
    0122F C01F      RJMP	0x124F
(1530) 	 {
(1531) 		Dynamic_Offset_degree_origin[i/3][i%3]=Dynamic_Offset_degree_origin_z[i];
    01230 E013      LDI	R17,3
    01231 2F04      MOV	R16,R20
    01232 940E 1A76 CALL	div8u
    01234 E083      LDI	R24,3
    01235 2F10      MOV	R17,R16
    01236 2F08      MOV	R16,R24
    01237 0301      MULSU	R16,R17
    01238 0110      MOVW	R2,R0
    01239 E486      LDI	R24,0x46
    0123A E093      LDI	R25,3
    0123B 0E28      ADD	R2,R24
    0123C 1E39      ADC	R3,R25
    0123D E023      LDI	R18,3
    0123E E030      LDI	R19,0
    0123F 2F04      MOV	R16,R20
    01240 2711      CLR	R17
    01241 940E 1A3A CALL	mod16s
    01243 01F8      MOVW	R30,R16
    01244 0DE2      ADD	R30,R2
    01245 1DF3      ADC	R31,R3
    01246 EB89      LDI	R24,0xB9
    01247 E092      LDI	R25,2
    01248 2FA4      MOV	R26,R20
    01249 27BB      CLR	R27
    0124A 0FA8      ADD	R26,R24
    0124B 1FB9      ADC	R27,R25
    0124C 902C      LD	R2,X
    0124D 8220      ST	Z,R2
    0124E 9543      INC	R20
    0124F E187      LDI	R24,0x17
    01250 1784      CP	R24,R20
    01251 F6F0      BCC	0x1230
(1532)      }
(1533) ////////////////////////////////////////////////////
(1534) 	 CLI();
    01252 94F8      BCLR	7
(1535) 	 timer3_init();
    01253 940E 027D CALL	_timer3_init
(1536) 	 timer1_init();
    01255 940E 0297 CALL	_timer1_init
(1537) 	 SEI();
    01257 9478      BSET	7
(1538) 	 init_data();
    01258 940E 0645 CALL	_init_data
(1539) 	 init_static_offset();
    0125A 940E 0490 CALL	_init_static_offset
(1540) 	 calculate_data();
    0125C 940E 04E5 CALL	_calculate_data
(1541) 	 
(1542) 	 CLI();
    0125E 94F8      BCLR	7
(1543) 	 TCCR3B=0x00;		//暂停定时／计数器3  最后两位设为0即可
    0125F 2422      CLR	R2
    01260 9220 008A STS	0x8A,R2
(1544) 	 TCCR1B=0x00;		//暂停定时／计数器3  最后两位设为0即可
    01262 BC2E      OUT	0x2E,R2
(1545) 	
(1546) 	 ICR3=PWM_Period_value;//计数器3上限值TOP
    01263 9020 0426 LDS	R2,PWM_Period_value
    01265 9030 0427 LDS	R3,PWM_Period_value+1
    01267 9230 0081 STS	0x81,R3
    01269 9220 0080 STS	0x80,R2
(1547) 	 ICR1=PWM_Period_value;//计数器1上限值TOP
    0126B BC37      OUT	0x27,R3
    0126C BC26      OUT	0x26,R2
(1548) 	 OCR1A=Joint_Angle_value[0];
    0126D 9020 03BE LDS	R2,Joint_Angle_value
    0126F 9030 03BF LDS	R3,Joint_Angle_value+1
    01271 BC3B      OUT	0x2B,R3
    01272 BC2A      OUT	0x2A,R2
(1549) 	 OCR1B=Joint_Angle_value[1];
    01273 9020 03C0 LDS	R2,Joint_Angle_value+2
    01275 9030 03C1 LDS	R3,Joint_Angle_value+3
    01277 BC39      OUT	0x29,R3
    01278 BC28      OUT	0x28,R2
(1550) 	 OCR3A=Joint_Angle_value[2];
    01279 9020 03C2 LDS	R2,Joint_Angle_value+4
    0127B 9030 03C3 LDS	R3,Joint_Angle_value+5
    0127D 9230 0087 STS	0x87,R3
    0127F 9220 0086 STS	0x86,R2
(1551) 	 /*wang genggai*/
(1552) 	// OCR3B=Joint_Angle_value[2];
(1553) 	 
(1554) 	 SEI();         //re-enable interrupts
    01281 9478      BSET	7
(1555) 	 TCCR3B=0x1A;	//启动定时／计数器3
    01282 E18A      LDI	R24,0x1A
    01283 9380 008A STS	0x8A,R24
(1556) 	 TCCR1B=0x1A;	//启动定时／计数器1
    01285 BD8E      OUT	0x2E,R24
    01286 C664      RJMP	0x18EB
(1557) 	 
(1558) ////////////////////////////////////////////////////////////////////////////////
(1559) ////////////////////////////////////////////////////////////////////////////////
(1560) 	while(1)
(1561) 	{
(1562) ///////////----手动模式--BEGIN//////////////////////////////////////////
(1563) 	   if(is_uart==1)//手动模式
    01287 9180 0319 LDS	R24,is_uart
    01289 3081      CPI	R24,1
    0128A F009      BEQ	0x128C
    0128B C50A      RJMP	0x1796
(1564) 	   {
(1565) 	   if(i2c_canshu)
    0128C 9020 0331 LDS	R2,i2c_canshu
    0128E 2022      TST	R2
    0128F F409      BNE	0x1291
    01290 C16E      RJMP	0x13FF
(1566) 	   {
(1567) 	     i2c_canshu=0;
    01291 2422      CLR	R2
    01292 9220 0331 STS	i2c_canshu,R2
(1568) 		 baocun_i++;
    01294 9180 0104 LDS	R24,baocun_i
    01296 5F8F      SUBI	R24,0xFF
    01297 9380 0104 STS	baocun_i,R24
(1569) 		 switch(baocun_i)
    01299 2F68      MOV	R22,R24
    0129A 2777      CLR	R23
    0129B 3061      CPI	R22,1
    0129C E0E0      LDI	R30,0
    0129D 077E      CPC	R23,R30
    0129E F149      BEQ	0x12C8
    0129F 3062      CPI	R22,2
    012A0 E0E0      LDI	R30,0
    012A1 077E      CPC	R23,R30
    012A2 F409      BNE	0x12A4
    012A3 C04D      RJMP	0x12F1
    012A4 3063      CPI	R22,3
    012A5 E0E0      LDI	R30,0
    012A6 077E      CPC	R23,R30
    012A7 F409      BNE	0x12A9
    012A8 C058      RJMP	0x1301
    012A9 3064      CPI	R22,4
    012AA E0E0      LDI	R30,0
    012AB 077E      CPC	R23,R30
    012AC F409      BNE	0x12AE
    012AD C0A0      RJMP	0x134E
    012AE 3065      CPI	R22,5
    012AF E0E0      LDI	R30,0
    012B0 077E      CPC	R23,R30
    012B1 F409      BNE	0x12B3
    012B2 C0BA      RJMP	0x136D
    012B3 3066      CPI	R22,6
    012B4 E0E0      LDI	R30,0
    012B5 077E      CPC	R23,R30
    012B6 F409      BNE	0x12B8
    012B7 C0D4      RJMP	0x138C
    012B8 3067      CPI	R22,7
    012B9 E0E0      LDI	R30,0
    012BA 077E      CPC	R23,R30
    012BB F409      BNE	0x12BD
    012BC C0DF      RJMP	0x139C
    012BD 3068      CPI	R22,0x8
    012BE E0E0      LDI	R30,0
    012BF 077E      CPC	R23,R30
    012C0 F409      BNE	0x12C2
    012C1 C11B      RJMP	0x13DD
    012C2 3069      CPI	R22,0x9
    012C3 E0E0      LDI	R30,0
    012C4 077E      CPC	R23,R30
    012C5 F409      BNE	0x12C7
    012C6 C126      RJMP	0x13ED
    012C7 C137      RJMP	0x13FF
(1570) 		 {
(1571) 		 case 1:
(1572) 				one2two(Speed_tem_z,Speed_tem_z1,Speed_tem_z2);
    012C8 E689      LDI	R24,0x69
    012C9 E091      LDI	R25,1
    012CA 8399      STD	Y+1,R25
    012CB 8388      ST	Y,R24
    012CC E621      LDI	R18,0x61
    012CD E031      LDI	R19,1
    012CE E501      LDI	R16,0x51
    012CF E011      LDI	R17,1
    012D0 940E 0670 CALL	_one2two
(1573) 		        i2c_write(ADD_s1,Speed_tem_I2C1,Speed_tem_z1,8);
    012D2 E088      LDI	R24,0x8
    012D3 838A      STD	Y+2,R24
    012D4 E681      LDI	R24,0x61
    012D5 E091      LDI	R25,1
    012D6 8399      STD	Y+1,R25
    012D7 8388      ST	Y,R24
    012D8 E721      LDI	R18,0x71
    012D9 E031      LDI	R19,1
    012DA E400      LDI	R16,0x40
    012DB 940E 090F CALL	_i2c_write
(1574) 				delay_nms(200);
    012DD EC08      LDI	R16,0xC8
    012DE E010      LDI	R17,0
    012DF 940E 0256 CALL	_delay_nms
(1575) 		        i2c_write(ADD_s2,Speed_tem_I2C2,Speed_tem_z2,8);
    012E1 E088      LDI	R24,0x8
    012E2 838A      STD	Y+2,R24
    012E3 E689      LDI	R24,0x69
    012E4 E091      LDI	R25,1
    012E5 8399      STD	Y+1,R25
    012E6 8388      ST	Y,R24
    012E7 E72B      LDI	R18,0x7B
    012E8 E031      LDI	R19,1
    012E9 E408      LDI	R16,0x48
    012EA 940E 090F CALL	_i2c_write
(1576) 		        senddata(baocun_i);
    012EC 9100 0104 LDS	R16,baocun_i
    012EE 940E 02CA CALL	_senddata
(1577) 				break;
    012F0 C10E      RJMP	0x13FF
(1578) 		 case 2:
(1579) 		        i2c_write(ADD_d,Neighbouring_Offset_degree_I2C,Neighbouring_Offset_degree,3);//滞后角
    012F1 E083      LDI	R24,3
    012F2 838A      STD	Y+2,R24
    012F3 EE8B      LDI	R24,0xEB
    012F4 E093      LDI	R25,3
    012F5 8399      STD	Y+1,R25
    012F6 8388      ST	Y,R24
    012F7 E828      LDI	R18,0x88
    012F8 E031      LDI	R19,1
    012F9 E500      LDI	R16,0x50
    012FA 940E 090F CALL	_i2c_write
(1580) 		        senddata(baocun_i);
    012FC 9100 0104 LDS	R16,baocun_i
    012FE 940E 02CA CALL	_senddata
(1581) 				break;
    01300 C0FE      RJMP	0x13FF
(1582) 		 case 3://幅度
(1583) 				for(i=0;i<=15;i++)
    01301 2744      CLR	R20
    01302 C01E      RJMP	0x1321
(1584) 				{
(1585) 				  for(j=0;j<=2;j++)
    01303 24AA      CLR	R10
    01304 C018      RJMP	0x131D
(1586) 				  {
(1587) 				    Amplitude_degree_tem_z[i*3+j]=Amplitude_degree_tem[i][j];
    01305 E003      LDI	R16,3
    01306 2F14      MOV	R17,R20
    01307 0301      MULSU	R16,R17
    01308 EF81      LDI	R24,0xF1
    01309 E093      LDI	R25,3
    0130A 0110      MOVW	R2,R0
    0130B 0E28      ADD	R2,R24
    0130C 1E39      ADC	R3,R25
    0130D 2DEA      MOV	R30,R10
    0130E 27FF      CLR	R31
    0130F 0DE2      ADD	R30,R2
    01310 1DF3      ADC	R31,R3
    01311 8020      LD	R2,Z
    01312 2C3A      MOV	R3,R10
    01313 2444      CLR	R4
    01314 01F0      MOVW	R30,R0
    01315 0DE3      ADD	R30,R3
    01316 1DF4      ADC	R31,R4
    01317 EE8D      LDI	R24,0xED
    01318 E091      LDI	R25,1
    01319 0FE8      ADD	R30,R24
    0131A 1FF9      ADC	R31,R25
    0131B 8220      ST	Z,R2
    0131C 94A3      INC	R10
    0131D E082      LDI	R24,2
    0131E 158A      CP	R24,R10
    0131F F728      BCC	0x1305
    01320 9543      INC	R20
    01321 E08F      LDI	R24,0xF
    01322 1784      CP	R24,R20
    01323 F6F8      BCC	0x1303
(1588) 				  }
(1589) 				}
(1590) 				one2six(Amplitude_degree_tem_z,Amplitude_degree_tem_z1,Amplitude_degree_tem_z2,Amplitude_degree_tem_z3,Amplitude_degree_tem_z4,Amplitude_degree_tem_z5,Amplitude_degree_tem_z6);			
    01324 E485      LDI	R24,0x45
    01325 E092      LDI	R25,2
    01326 8799      STD	Y+9,R25
    01327 8788      STD	Y+8,R24
    01328 E38D      LDI	R24,0x3D
    01329 E092      LDI	R25,2
    0132A 839F      STD	Y+7,R25
    0132B 838E      STD	Y+6,R24
    0132C E385      LDI	R24,0x35
    0132D E092      LDI	R25,2
    0132E 839D      STD	Y+5,R25
    0132F 838C      STD	Y+4,R24
    01330 E28D      LDI	R24,0x2D
    01331 E092      LDI	R25,2
    01332 839B      STD	Y+3,R25
    01333 838A      STD	Y+2,R24
    01334 E285      LDI	R24,0x25
    01335 E092      LDI	R25,2
    01336 8399      STD	Y+1,R25
    01337 8388      ST	Y,R24
    01338 E12D      LDI	R18,0x1D
    01339 E032      LDI	R19,2
    0133A EE0D      LDI	R16,0xED
    0133B E011      LDI	R17,1
    0133C 940E 0795 CALL	_one2six
(1591) 				i2c_write(ADD_1,Amplitude_degree_tem_I2C1,Amplitude_degree_tem_z1,8);
    0133E E088      LDI	R24,0x8
    0133F 838A      STD	Y+2,R24
    01340 E18D      LDI	R24,0x1D
    01341 E092      LDI	R25,2
    01342 8399      STD	Y+1,R25
    01343 8388      ST	Y,R24
    01344 E42D      LDI	R18,0x4D
    01345 E032      LDI	R19,2
    01346 E600      LDI	R16,0x60
    01347 940E 090F CALL	_i2c_write
(1592) 		        senddata(baocun_i);
    01349 9100 0104 LDS	R16,baocun_i
    0134B 940E 02CA CALL	_senddata
(1593) 				break;
    0134D C0B1      RJMP	0x13FF
(1594) 		 case 4:
(1595) 				i2c_write(ADD_2,Amplitude_degree_tem_I2C2,Amplitude_degree_tem_z2,8);
    0134E E088      LDI	R24,0x8
    0134F 838A      STD	Y+2,R24
    01350 E285      LDI	R24,0x25
    01351 E092      LDI	R25,2
    01352 8399      STD	Y+1,R25
    01353 8388      ST	Y,R24
    01354 E527      LDI	R18,0x57
    01355 E032      LDI	R19,2
    01356 E608      LDI	R16,0x68
    01357 940E 090F CALL	_i2c_write
(1596) 				delay_nms(200);
    01359 EC08      LDI	R16,0xC8
    0135A E010      LDI	R17,0
    0135B 940E 0256 CALL	_delay_nms
(1597) 				i2c_write(ADD_3,Amplitude_degree_tem_I2C3,Amplitude_degree_tem_z3,8);
    0135D E088      LDI	R24,0x8
    0135E 838A      STD	Y+2,R24
    0135F E28D      LDI	R24,0x2D
    01360 E092      LDI	R25,2
    01361 8399      STD	Y+1,R25
    01362 8388      ST	Y,R24
    01363 E621      LDI	R18,0x61
    01364 E032      LDI	R19,2
    01365 E700      LDI	R16,0x70
    01366 940E 090F CALL	_i2c_write
(1598) 				senddata(baocun_i);
    01368 9100 0104 LDS	R16,baocun_i
    0136A 940E 02CA CALL	_senddata
(1599) 				break;
    0136C C092      RJMP	0x13FF
(1600) 		 case 5:
(1601) 				i2c_write(ADD_4,Amplitude_degree_tem_I2C4,Amplitude_degree_tem_z4,8);
    0136D E088      LDI	R24,0x8
    0136E 838A      STD	Y+2,R24
    0136F E385      LDI	R24,0x35
    01370 E092      LDI	R25,2
    01371 8399      STD	Y+1,R25
    01372 8388      ST	Y,R24
    01373 E62B      LDI	R18,0x6B
    01374 E032      LDI	R19,2
    01375 E708      LDI	R16,0x78
    01376 940E 090F CALL	_i2c_write
(1602) 				delay_nms(200);
    01378 EC08      LDI	R16,0xC8
    01379 E010      LDI	R17,0
    0137A 940E 0256 CALL	_delay_nms
(1603) 				i2c_write(ADD_5,Amplitude_degree_tem_I2C5,Amplitude_degree_tem_z5,8);
    0137C E088      LDI	R24,0x8
    0137D 838A      STD	Y+2,R24
    0137E E38D      LDI	R24,0x3D
    0137F E092      LDI	R25,2
    01380 8399      STD	Y+1,R25
    01381 8388      ST	Y,R24
    01382 E725      LDI	R18,0x75
    01383 E032      LDI	R19,2
    01384 E800      LDI	R16,0x80
    01385 940E 090F CALL	_i2c_write
(1604) 		        senddata(baocun_i);
    01387 9100 0104 LDS	R16,baocun_i
    01389 940E 02CA CALL	_senddata
(1605) 				break;
    0138B C073      RJMP	0x13FF
(1606) 		 case 6:
(1607) 				i2c_write(ADD_6,Amplitude_degree_tem_I2C6,Amplitude_degree_tem_z6,8);
    0138C E088      LDI	R24,0x8
    0138D 838A      STD	Y+2,R24
    0138E E485      LDI	R24,0x45
    0138F E092      LDI	R25,2
    01390 8399      STD	Y+1,R25
    01391 8388      ST	Y,R24
    01392 E72F      LDI	R18,0x7F
    01393 E032      LDI	R19,2
    01394 E808      LDI	R16,0x88
    01395 940E 090F CALL	_i2c_write
(1608) 				senddata(baocun_i);
    01397 9100 0104 LDS	R16,baocun_i
    01399 940E 02CA CALL	_senddata
(1609)     			break;
    0139B C063      RJMP	0x13FF
(1610) 		 case 7://转弯偏移角
(1611) 				for(i=0;i<=7;i++)
    0139C 2744      CLR	R20
    0139D C01E      RJMP	0x13BC
(1612) 				{
(1613) 				  for(j=0;j<=2;j++) 
    0139E 24AA      CLR	R10
    0139F C018      RJMP	0x13B8
(1614) 				  {
(1615) 				    Dynamic_Offset_degree_origin_z[i*3+j]=Dynamic_Offset_degree_origin[i][j];
    013A0 E003      LDI	R16,3
    013A1 2F14      MOV	R17,R20
    013A2 0301      MULSU	R16,R17
    013A3 E486      LDI	R24,0x46
    013A4 E093      LDI	R25,3
    013A5 0110      MOVW	R2,R0
    013A6 0E28      ADD	R2,R24
    013A7 1E39      ADC	R3,R25
    013A8 2DEA      MOV	R30,R10
    013A9 27FF      CLR	R31
    013AA 0DE2      ADD	R30,R2
    013AB 1DF3      ADC	R31,R3
    013AC 8020      LD	R2,Z
    013AD 2C3A      MOV	R3,R10
    013AE 2444      CLR	R4
    013AF 01F0      MOVW	R30,R0
    013B0 0DE3      ADD	R30,R3
    013B1 1DF4      ADC	R31,R4
    013B2 EB89      LDI	R24,0xB9
    013B3 E092      LDI	R25,2
    013B4 0FE8      ADD	R30,R24
    013B5 1FF9      ADC	R31,R25
    013B6 8220      ST	Z,R2
    013B7 94A3      INC	R10
    013B8 E082      LDI	R24,2
    013B9 158A      CP	R24,R10
    013BA F728      BCC	0x13A0
    013BB 9543      INC	R20
    013BC E087      LDI	R24,7
    013BD 1784      CP	R24,R20
    013BE F6F8      BCC	0x139E
(1616) 				  }
(1617) 				}
(1618) 				one2three(Dynamic_Offset_degree_origin_z,Dynamic_Offset_degree_origin_z1,Dynamic_Offset_degree_origin_z2,Dynamic_Offset_degree_origin_z3);			
    013BF EE81      LDI	R24,0xE1
    013C0 E092      LDI	R25,2
    013C1 839B      STD	Y+3,R25
    013C2 838A      STD	Y+2,R24
    013C3 ED89      LDI	R24,0xD9
    013C4 E092      LDI	R25,2
    013C5 8399      STD	Y+1,R25
    013C6 8388      ST	Y,R24
    013C7 ED21      LDI	R18,0xD1
    013C8 E032      LDI	R19,2
    013C9 EB09      LDI	R16,0xB9
    013CA E012      LDI	R17,2
    013CB 940E 06E7 CALL	_one2three
(1619) 				i2c_write(ADD_10,Dynamic_Offset_degree_origin_I2C1,Dynamic_Offset_degree_origin_z1,8);
    013CD E088      LDI	R24,0x8
    013CE 838A      STD	Y+2,R24
    013CF ED81      LDI	R24,0xD1
    013D0 E092      LDI	R25,2
    013D1 8399      STD	Y+1,R25
    013D2 8388      ST	Y,R24
    013D3 EE29      LDI	R18,0xE9
    013D4 E032      LDI	R19,2
    013D5 E900      LDI	R16,0x90
    013D6 940E 090F CALL	_i2c_write
(1620) 		        senddata(baocun_i);
    013D8 9100 0104 LDS	R16,baocun_i
    013DA 940E 02CA CALL	_senddata
(1621) 				break;
    013DC C022      RJMP	0x13FF
(1622) 		 case 8:
(1623) 				i2c_write(ADD_20,Dynamic_Offset_degree_origin_I2C2,Dynamic_Offset_degree_origin_z2,8);
    013DD E088      LDI	R24,0x8
    013DE 838A      STD	Y+2,R24
    013DF ED89      LDI	R24,0xD9
    013E0 E092      LDI	R25,2
    013E1 8399      STD	Y+1,R25
    013E2 8388      ST	Y,R24
    013E3 EF23      LDI	R18,0xF3
    013E4 E032      LDI	R19,2
    013E5 E908      LDI	R16,0x98
    013E6 940E 090F CALL	_i2c_write
(1624) 				senddata(baocun_i);
    013E8 9100 0104 LDS	R16,baocun_i
    013EA 940E 02CA CALL	_senddata
(1625) 				break;
    013EC C012      RJMP	0x13FF
(1626) 		 case 9:baocun_i=0;
    013ED 2422      CLR	R2
    013EE 9220 0104 STS	baocun_i,R2
(1627) 				i2c_write(ADD_30,Dynamic_Offset_degree_origin_I2C3,Dynamic_Offset_degree_origin_z3,8);
    013F0 E088      LDI	R24,0x8
    013F1 838A      STD	Y+2,R24
    013F2 EE81      LDI	R24,0xE1
    013F3 E092      LDI	R25,2
    013F4 8399      STD	Y+1,R25
    013F5 8388      ST	Y,R24
    013F6 EF2D      LDI	R18,0xFD
    013F7 E032      LDI	R19,2
    013F8 EA00      LDI	R16,0xA0
    013F9 940E 090F CALL	_i2c_write
(1628) 		        senddata(baocun_i);
    013FB 9100 0104 LDS	R16,baocun_i
    013FD 940E 02CA CALL	_senddata
(1629) 				break;  
(1630) 		 }//switch baocun_i		  
(1631) 	   }//if(i2c_canshu)
(1632) 	   	   
(1633) 	   if(i2c_change == 1)
    013FF 9180 0316 LDS	R24,i2c_change
    01401 3081      CPI	R24,1
    01402 F469      BNE	0x1410
(1634) 	   {
(1635) 			i2c_init();
    01403 940E 0966 CALL	_i2c_init
(1636) 			i2c_change=0;
    01405 2422      CLR	R2
    01406 9220 0316 STS	i2c_change,R2
(1637) 			isSrlStartI2c=0;
    01408 9220 0308 STS	isSrlStartI2c,R2
(1638) 			addrI2c=0;
    0140A 9220 030A STS	addrI2c,R2
(1639) 			isInstructionI2c=0;
    0140C 9220 0318 STS	isInstructionI2c,R2
(1640) 			i_change=0;
    0140E 9220 0315 STS	i_change,R2
(1641) 	   }//if(i2c_change)
(1642) 
(1643) 	   if(e_change)//接收到结束位,处理指令
    01410 9020 0314 LDS	R2,e_change
    01412 2022      TST	R2
    01413 F409      BNE	0x1415
    01414 C1FE      RJMP	0x1613
(1644) 	   {
(1645) 	   //senddata(FISHID[0]);
(1646) 	   redata=redata_tem;
    01415 9020 0424 LDS	R2,redata_tem
    01417 9220 0425 STS	redata,R2
(1647) 	     if(s_change)//速度变化
    01419 9020 030B LDS	R2,s_change
    0141B 2022      TST	R2
    0141C F409      BNE	0x141E
    0141D C06D      RJMP	0x148B
(1648) 		 {
(1649) 			 id_change=0;
    0141E 2422      CLR	R2
    0141F 9220 0313 STS	id_change,R2
(1650) 			id_fan=(FISHID[0]<<5)|(redata_fan&0x0f);
    01421 9180 0102 LDS	R24,redata_fan
    01423 708F      ANDI	R24,0xF
    01424 9020 010A LDS	R2,FISHID
    01426 0C22      LSL	R2
    01427 0C22      LSL	R2
    01428 0C22      LSL	R2
    01429 0C22      LSL	R2
    0142A 0C22      LSL	R2
    0142B 2A28      OR	R2,R24
    0142C 9220 0103 STS	id_fan,R2
(1651) 		    if((redata_fan>>4)<<4==0xd0)
    0142E 9180 0102 LDS	R24,redata_fan
    01430 9582      SWAP	R24
    01431 708F      ANDI	R24,0xF
    01432 708F      ANDI	R24,0xF
    01433 9582      SWAP	R24
    01434 3D80      CPI	R24,0xD0
    01435 F421      BNE	0x143A
(1652) 		      id_fan=id_fan|0x10;
    01436 2D82      MOV	R24,R2
    01437 6180      ORI	R24,0x10
    01438 9380 0103 STS	id_fan,R24
(1653) 		    ///////senddata(id_fan);	//前三位用来表示id号，第４位为１时为速度，０为方向，后四位为具体的速度或是方向的值
(1654) 	   
(1655) 			//senddata(t_dynamic);////////////////////
(1656) 			s_tem=redata&0x0f;//速度档0-15
    0143A 9180 0425 LDS	R24,redata
    0143C 708F      ANDI	R24,0xF
    0143D 9380 032C STS	s_tem,R24
(1657) 			if(s_tem==0)//速度0时，停止，直
    0143F 2388      TST	R24
    01440 F529      BNE	0x1466
(1658) 			{
(1659) 			  for(i=0;i<=2;i++)
    01441 2744      CLR	R20
    01442 C00D      RJMP	0x1450
(1660) 				Dynamic_Offset_degree [i]=0;
    01443 EC8A      LDI	R24,0xCA
    01444 E093      LDI	R25,3
    01445 2FE4      MOV	R30,R20
    01446 27FF      CLR	R31
    01447 0FEE      LSL	R30
    01448 1FFF      ROL	R31
    01449 0FE8      ADD	R30,R24
    0144A 1FF9      ADC	R31,R25
    0144B 2422      CLR	R2
    0144C 2433      CLR	R3
    0144D 8231      STD	Z+1,R3
    0144E 8220      ST	Z,R2
    0144F 9543      INC	R20
    01450 E082      LDI	R24,2
    01451 1784      CP	R24,R20
    01452 F780      BCC	0x1443
(1661) 			  init_dynamic_offset();
    01453 940E 04B9 CALL	_init_dynamic_offset
(1662) 	          for(i=0;i<Joint_Num;i++)
    01455 2744      CLR	R20
    01456 C00D      RJMP	0x1464
(1663) 	            {
(1664) 	            Dynamic_Offset_value_last[i]=0;
    01457 ED8F      LDI	R24,0xDF
    01458 E093      LDI	R25,3
    01459 2FE4      MOV	R30,R20
    0145A 27FF      CLR	R31
    0145B 0FEE      LSL	R30
    0145C 1FFF      ROL	R31
    0145D 0FE8      ADD	R30,R24
    0145E 1FF9      ADC	R31,R25
    0145F 2422      CLR	R2
    01460 2433      CLR	R3
    01461 8231      STD	Z+1,R3
    01462 8220      ST	Z,R2
    01463 9543      INC	R20
    01464 3043      CPI	R20,3
    01465 F388      BCS	0x1457
(1665) 	            }
(1666) 	 		}
(1667) 		    Speed=Speed_tem_z[s_tem];
    01466 E581      LDI	R24,0x51
    01467 E091      LDI	R25,1
    01468 91E0 032C LDS	R30,s_tem
    0146A 27FF      CLR	R31
    0146B 0FE8      ADD	R30,R24
    0146C 1FF9      ADC	R31,R25
    0146D 8020      LD	R2,Z
    0146E 9220 0100 STS	Speed,R2
(1668) 			for(i=0;i<=2;i++)//对应摆幅变化
    01470 2744      CLR	R20
    01471 C016      RJMP	0x1488
(1669) 			   Amplitude_degree[i]=Amplitude_degree_tem[s_tem][i];
    01472 9110 032C LDS	R17,s_tem
    01474 E003      LDI	R16,3
    01475 0301      MULSU	R16,R17
    01476 0110      MOVW	R2,R0
    01477 EF81      LDI	R24,0xF1
    01478 E093      LDI	R25,3
    01479 0E28      ADD	R2,R24
    0147A 1E39      ADC	R3,R25
    0147B 2FE4      MOV	R30,R20
    0147C 27FF      CLR	R31
    0147D 0DE2      ADD	R30,R2
    0147E 1DF3      ADC	R31,R3
    0147F 8020      LD	R2,Z
    01480 EE8E      LDI	R24,0xEE
    01481 E093      LDI	R25,3
    01482 2FE4      MOV	R30,R20
    01483 27FF      CLR	R31
    01484 0FE8      ADD	R30,R24
    01485 1FF9      ADC	R31,R25
    01486 8220      ST	Z,R2
    01487 9543      INC	R20
    01488 E082      LDI	R24,2
    01489 1784      CP	R24,R20
    0148A F738      BCC	0x1472
(1670) //		    init_dynamic_offset();
(1671) 		 }//if(s_change)
(1672) 		 
(1673) 		 if(d_change)//方向变化,有过渡状态08.01.14
    0148B 9020 030C LDS	R2,d_change
    0148D 2022      TST	R2
    0148E F409      BNE	0x1490
    0148F C06B      RJMP	0x14FB
(1674) 		 {
(1675) 			 id_change=0;
    01490 2422      CLR	R2
    01491 9220 0313 STS	id_change,R2
(1676) 			id_fan=(FISHID[0]<<5)|(redata_fan&0x0f);
    01493 9180 0102 LDS	R24,redata_fan
    01495 708F      ANDI	R24,0xF
    01496 9020 010A LDS	R2,FISHID
    01498 0C22      LSL	R2
    01499 0C22      LSL	R2
    0149A 0C22      LSL	R2
    0149B 0C22      LSL	R2
    0149C 0C22      LSL	R2
    0149D 2A28      OR	R2,R24
    0149E 9220 0103 STS	id_fan,R2
(1677) 		    if((redata_fan>>4)<<4==0xd0)
    014A0 9180 0102 LDS	R24,redata_fan
    014A2 9582      SWAP	R24
    014A3 708F      ANDI	R24,0xF
    014A4 708F      ANDI	R24,0xF
    014A5 9582      SWAP	R24
    014A6 3D80      CPI	R24,0xD0
    014A7 F421      BNE	0x14AC
(1678) 		      id_fan=id_fan|0x10;
    014A8 2D82      MOV	R24,R2
    014A9 6180      ORI	R24,0x10
    014AA 9380 0103 STS	id_fan,R24
(1679) 		    /////senddata(id_fan);	//前三位用来表示id号，第４位为１时为速度，０为方向，后四位为具体的速度或是方向的值
(1680) 	   
(1681) 			// senddata(t_dynamic);////////////////////
(1682) 			 t_dynamic=0;//过渡状态开始
    014AC 2422      CLR	R2
    014AD 9220 0105 STS	t_dynamic,R2
(1683) 			 d_tem=redata&0x0f;//转弯档0-15
    014AF 9180 0425 LDS	R24,redata
    014B1 708F      ANDI	R24,0xF
    014B2 9380 032E STS	d_tem,R24
(1684) 		 	 dd_tem=change_dd(d_tem);
    014B4 2F08      MOV	R16,R24
    014B5 940E 08EE CALL	_change_dd
    014B7 2EA0      MOV	R10,R16
    014B8 92A0 032F STS	dd_tem,R10
(1685) 			 flag=change_flag(d_tem);
    014BA 9100 032E LDS	R16,d_tem
    014BC 940E 0905 CALL	_change_flag
    014BE 2EA0      MOV	R10,R16
    014BF 92A0 0330 STS	flag,R10
(1686) 			// senddata(d_tem);
(1687) 			// senddata(dd_tem);
(1688) 			// senddata(flag);
(1689) 			 for(i=0;i<=2;i++)
    014C1 2744      CLR	R20
    014C2 C02A      RJMP	0x14ED
(1690) 			 {
(1691) 				Dynamic_Offset_degree_char[i]=Dynamic_Offset_degree_origin[dd_tem][i];
    014C3 9110 032F LDS	R17,dd_tem
    014C5 E003      LDI	R16,3
    014C6 0301      MULSU	R16,R17
    014C7 0110      MOVW	R2,R0
    014C8 E486      LDI	R24,0x46
    014C9 E093      LDI	R25,3
    014CA 0E28      ADD	R2,R24
    014CB 1E39      ADC	R3,R25
    014CC 2FE4      MOV	R30,R20
    014CD 27FF      CLR	R31
    014CE 0DE2      ADD	R30,R2
    014CF 1DF3      ADC	R31,R3
    014D0 8020      LD	R2,Z
    014D1 ED80      LDI	R24,0xD0
    014D2 E093      LDI	R25,3
    014D3 2FE4      MOV	R30,R20
    014D4 27FF      CLR	R31
    014D5 0FE8      ADD	R30,R24
    014D6 1FF9      ADC	R31,R25
    014D7 8220      ST	Z,R2
(1692) 			    Dynamic_Offset_degree[i]=char2int(Dynamic_Offset_degree_char[i],flag);
    014D8 9120 0330 LDS	R18,flag
    014DA 2FE4      MOV	R30,R20
    014DB 27FF      CLR	R31
    014DC 0FE8      ADD	R30,R24
    014DD 1FF9      ADC	R31,R25
    014DE 8100      LD	R16,Z
    014DF 940E 065E CALL	_char2int
    014E1 0158      MOVW	R10,R16
    014E2 EC8A      LDI	R24,0xCA
    014E3 E093      LDI	R25,3
    014E4 2FE4      MOV	R30,R20
    014E5 27FF      CLR	R31
    014E6 0FEE      LSL	R30
    014E7 1FFF      ROL	R31
    014E8 0FE8      ADD	R30,R24
    014E9 1FF9      ADC	R31,R25
    014EA 82B1      STD	Z+1,R11
    014EB 82A0      ST	Z,R10
    014EC 9543      INC	R20
    014ED E082      LDI	R24,2
    014EE 1784      CP	R24,R20
    014EF F698      BCC	0x14C3
(1693) 		     }
(1694) 			 init_dynamic_offset();
    014F0 940E 04B9 CALL	_init_dynamic_offset
(1695) 			 Speed_dynamic=Speed;
    014F2 9020 0100 LDS	R2,Speed
    014F4 9220 0106 STS	Speed_dynamic,R2
(1696) 			 d_change_t=1;
    014F6 E081      LDI	R24,1
    014F7 9380 030D STS	d_change_t,R24
(1697) 			 d_change_t_v=1; 
    014F9 9380 030E STS	d_change_t_v,R24
(1698) 			// senddata(t_dynamic);////////////////////
(1699) 		 }//if(d_change)
(1700) 		 
(1701) /*		 if(a_change)//幅度变化
(1702) 		 {
(1703) 			 tem=redata&0x0f;//幅度档0-15
(1704) 			 for(i=0;i<=2;i++)
(1705) 			    Amplitude_degree[i]=Amplitude_degree_tem[tem][i];
(1706) 		 }//if(a_change)
(1707) */		 
(1708) 		 if(t_change)//调直
    014FB 9020 030F LDS	R2,t_change
    014FD 2022      TST	R2
    014FE F149      BEQ	0x1528
(1709) 		 {
(1710) 			 id_change=0;
    014FF 2422      CLR	R2
    01500 9220 0313 STS	id_change,R2
(1711) 		     senddata(FISHID[0]);
    01502 9100 010A LDS	R16,FISHID
    01504 940E 02CA CALL	_senddata
(1712) 			 tem=redata&0x07;//关节数,0,1,2
    01506 9160 0425 LDS	R22,redata
    01508 7067      ANDI	R22,7
(1713) 			 if(tem>2)
    01509 E082      LDI	R24,2
    0150A 1786      CP	R24,R22
    0150B F408      BCC	0x150D
(1714) 			 {
(1715) 			 }//if(tem>2)
    0150C C019      RJMP	0x1526
(1716) 			 else
(1717) 			 {
(1718) 			    if(redata&0x08)//右调直,1度
    0150D 9020 0425 LDS	R2,redata
    0150F FE23      SBRS	R2,3
    01510 C00B      RJMP	0x151C
(1719) 				{
(1720) 				   Static_Offset_degree[tem]++;
    01511 E184      LDI	R24,0x14
    01512 E091      LDI	R25,1
    01513 2EA6      MOV	R10,R22
    01514 24BB      CLR	R11
    01515 0EA8      ADD	R10,R24
    01516 1EB9      ADC	R11,R25
    01517 01F5      MOVW	R30,R10
    01518 8180      LD	R24,Z
    01519 5F8F      SUBI	R24,0xFF
    0151A 8380      ST	Z,R24
(1721) 				}//if(redata&0x08)
    0151B C00A      RJMP	0x1526
(1722) 				else//左调直,1度
(1723) 				{
(1724) 				   Static_Offset_degree[tem]--;
    0151C E184      LDI	R24,0x14
    0151D E091      LDI	R25,1
    0151E 2EA6      MOV	R10,R22
    0151F 24BB      CLR	R11
    01520 0EA8      ADD	R10,R24
    01521 1EB9      ADC	R11,R25
    01522 01F5      MOVW	R30,R10
    01523 8180      LD	R24,Z
    01524 5081      SUBI	R24,1
    01525 8380      ST	Z,R24
(1725) 				}//if(redata&0x08) else
(1726) 			 }//if(tem>2) else
(1727) 			 init_static_offset();
    01526 940E 0490 CALL	_init_static_offset
(1728) 		 }//if(t_change)
(1729) 		 
(1730) 		 if(ts_change)//调直是否保存
    01528 9020 0310 LDS	R2,ts_change
    0152A 2022      TST	R2
    0152B F111      BEQ	0x154E
(1731) 		 {
(1732) 			 id_change=0;
    0152C 2422      CLR	R2
    0152D 9220 0313 STS	id_change,R2
(1733) 		   senddata(FISHID[0]);
    0152F 9100 010A LDS	R16,FISHID
    01531 940E 02CA CALL	_senddata
(1734) 		   if(redata&0x04)//保存
    01533 9020 0425 LDS	R2,redata
    01535 FE22      SBRS	R2,2
    01536 C00C      RJMP	0x1543
(1735) 		   {
(1736) 		       i2c_write(ADD_t,degree_I2C,Static_Offset_degree,3);
    01537 E083      LDI	R24,3
    01538 838A      STD	Y+2,R24
    01539 E184      LDI	R24,0x14
    0153A E091      LDI	R25,1
    0153B 8399      STD	Y+1,R25
    0153C 8388      ST	Y,R24
    0153D E12A      LDI	R18,0x1A
    0153E E031      LDI	R19,1
    0153F E300      LDI	R16,0x30
    01540 940E 090F CALL	_i2c_write
(1737) 		   }//if(redata&0x04)
    01542 C00B      RJMP	0x154E
(1738) 		   else//不保存
(1739) 		   {
(1740) 		       i2c_read(ADD_t,degree_I2C,Static_Offset_degree,3);		   
    01543 E083      LDI	R24,3
    01544 838A      STD	Y+2,R24
    01545 E184      LDI	R24,0x14
    01546 E091      LDI	R25,1
    01547 8399      STD	Y+1,R25
    01548 8388      ST	Y,R24
    01549 E12A      LDI	R18,0x1A
    0154A E031      LDI	R19,1
    0154B E300      LDI	R16,0x30
    0154C 940E 0935 CALL	_i2c_read
(1741) 		   }//if(redatat&0x04) else
(1742) 		 }//if(ts_change)
(1743) 		 
(1744) 		 if(id_change==2)//更改鱼id
    0154E 9180 0313 LDS	R24,id_change
    01550 3082      CPI	R24,2
    01551 F4D9      BNE	0x156D
(1745) 		 {
(1746) 			 id_change=0;
    01552 2422      CLR	R2
    01553 9220 0313 STS	id_change,R2
(1747)             senddata(FISHID[0]);
    01555 9100 010A LDS	R16,FISHID
    01557 940E 02CA CALL	_senddata
(1748) 			tem=redata&0x0f;
    01559 9160 0425 LDS	R22,redata
    0155B 706F      ANDI	R22,0xF
(1749) 		    FISHID[0]=tem;
    0155C 9360 010A STS	FISHID,R22
(1750)             i2c_write(ADD_i,FISHID_I2C,FISHID,1);
    0155E E081      LDI	R24,1
    0155F 838A      STD	Y+2,R24
    01560 E08A      LDI	R24,0xA
    01561 E091      LDI	R25,1
    01562 8399      STD	Y+1,R25
    01563 8388      ST	Y,R24
    01564 E02C      LDI	R18,0xC
    01565 E031      LDI	R19,1
    01566 E100      LDI	R16,0x10
    01567 940E 090F CALL	_i2c_write
(1751) 			senddata(FISHID[0]);
    01569 9100 010A LDS	R16,FISHID
    0156B 940E 02CA CALL	_senddata
(1752) 		 }//if(id_change)
(1753) 		 
(1754) 		 if(f_change)//更改频率
    0156D 9020 0312 LDS	R2,f_change
    0156F 2022      TST	R2
    01570 F409      BNE	0x1572
    01571 C08C      RJMP	0x15FE
(1755) 		 {
(1756) 			 id_change=0;
    01572 2422      CLR	R2
    01573 9220 0313 STS	id_change,R2
(1757) 
(1758) 		    if(redata_tem==0x41)//频率1
    01575 9180 0424 LDS	R24,redata_tem
    01577 3481      CPI	R24,0x41
    01578 F499      BNE	0x158C
(1759) 			{
(1760) 			  PORTD=PORTD&0xf4;
    01579 B382      IN	R24,0x12
    0157A 7F84      ANDI	R24,0xF4
    0157B BB82      OUT	0x12,R24
(1761) 			  senddata(0xaa);//0xfc
    0157C EA0A      LDI	R16,0xAA
    0157D 940E 02CA CALL	_senddata
(1762) 			  senddata(0x49);
    0157F E409      LDI	R16,0x49
    01580 940E 02CA CALL	_senddata
(1763) 			  senddata(0xff);
    01582 EF0F      LDI	R16,0xFF
    01583 940E 02CA CALL	_senddata
(1764) 			  senddata(0x02);
    01585 E002      LDI	R16,2
    01586 940E 02CA CALL	_senddata
(1765) 			  senddata(0xbb);
    01588 EB0B      LDI	R16,0xBB
    01589 940E 02CA CALL	_senddata
(1766) 			}
    0158B C072      RJMP	0x15FE
(1767) 			else if(redata_tem==0x42)//频率2
    0158C 9180 0424 LDS	R24,redata_tem
    0158E 3482      CPI	R24,0x42
    0158F F499      BNE	0x15A3
(1768) 			{
(1769) 			  PORTD=PORTD&0xf4;
    01590 B382      IN	R24,0x12
    01591 7F84      ANDI	R24,0xF4
    01592 BB82      OUT	0x12,R24
(1770) 			  senddata(0xaa);//0xfc
    01593 EA0A      LDI	R16,0xAA
    01594 940E 02CA CALL	_senddata
(1771) 			  senddata(0x49);
    01596 E409      LDI	R16,0x49
    01597 940E 02CA CALL	_senddata
(1772) 			  senddata(0xff);
    01599 EF0F      LDI	R16,0xFF
    0159A 940E 02CA CALL	_senddata
(1773) 			  senddata(0x16);
    0159C E106      LDI	R16,0x16
    0159D 940E 02CA CALL	_senddata
(1774) 			  senddata(0xbb);
    0159F EB0B      LDI	R16,0xBB
    015A0 940E 02CA CALL	_senddata
(1775) 			}
    015A2 C05B      RJMP	0x15FE
(1776) 			else if(redata_tem==0x43)//频率3
    015A3 9180 0424 LDS	R24,redata_tem
    015A5 3483      CPI	R24,0x43
    015A6 F499      BNE	0x15BA
(1777) 			{
(1778) 			  PORTD=PORTD&0xf4;
    015A7 B382      IN	R24,0x12
    015A8 7F84      ANDI	R24,0xF4
    015A9 BB82      OUT	0x12,R24
(1779) 			  senddata(0xaa);//0xfc
    015AA EA0A      LDI	R16,0xAA
    015AB 940E 02CA CALL	_senddata
(1780) 			  senddata(0x49);
    015AD E409      LDI	R16,0x49
    015AE 940E 02CA CALL	_senddata
(1781) 			  senddata(0xff);
    015B0 EF0F      LDI	R16,0xFF
    015B1 940E 02CA CALL	_senddata
(1782) 			  senddata(0x2A);
    015B3 E20A      LDI	R16,0x2A
    015B4 940E 02CA CALL	_senddata
(1783) 			  senddata(0xbb);
    015B6 EB0B      LDI	R16,0xBB
    015B7 940E 02CA CALL	_senddata
(1784) 			}
    015B9 C044      RJMP	0x15FE
(1785) 			else if(redata_tem==0x44)//频率4
    015BA 9180 0424 LDS	R24,redata_tem
    015BC 3484      CPI	R24,0x44
    015BD F499      BNE	0x15D1
(1786) 			{
(1787) 			  PORTD=PORTD&0xf4;
    015BE B382      IN	R24,0x12
    015BF 7F84      ANDI	R24,0xF4
    015C0 BB82      OUT	0x12,R24
(1788) 			  senddata(0xaa);//0xfc
    015C1 EA0A      LDI	R16,0xAA
    015C2 940E 02CA CALL	_senddata
(1789) 			  senddata(0x49);
    015C4 E409      LDI	R16,0x49
    015C5 940E 02CA CALL	_senddata
(1790) 			  senddata(0xff);
    015C7 EF0F      LDI	R16,0xFF
    015C8 940E 02CA CALL	_senddata
(1791) 			  senddata(0x3B);
    015CA E30B      LDI	R16,0x3B
    015CB 940E 02CA CALL	_senddata
(1792) 			  senddata(0xbb);
    015CD EB0B      LDI	R16,0xBB
    015CE 940E 02CA CALL	_senddata
(1793) 			}
    015D0 C02D      RJMP	0x15FE
(1794) 			else if(redata_tem==0x45)//频率5
    015D1 9180 0424 LDS	R24,redata_tem
    015D3 3485      CPI	R24,0x45
    015D4 F499      BNE	0x15E8
(1795) 			{
(1796) 			  PORTD=PORTD&0xf4;
    015D5 B382      IN	R24,0x12
    015D6 7F84      ANDI	R24,0xF4
    015D7 BB82      OUT	0x12,R24
(1797) 			  senddata(0xaa);//0xfc
    015D8 EA0A      LDI	R16,0xAA
    015D9 940E 02CA CALL	_senddata
(1798) 			  senddata(0x49);
    015DB E409      LDI	R16,0x49
    015DC 940E 02CA CALL	_senddata
(1799) 			  senddata(0xff);
    015DE EF0F      LDI	R16,0xFF
    015DF 940E 02CA CALL	_senddata
(1800) 			  senddata(0x33);
    015E1 E303      LDI	R16,0x33
    015E2 940E 02CA CALL	_senddata
(1801) 			  senddata(0xbb);
    015E4 EB0B      LDI	R16,0xBB
    015E5 940E 02CA CALL	_senddata
(1802) 			}
    015E7 C016      RJMP	0x15FE
(1803) 			else if(redata_tem==0x46)//频率6
    015E8 9180 0424 LDS	R24,redata_tem
    015EA 3486      CPI	R24,0x46
    015EB F491      BNE	0x15FE
(1804) 			{
(1805) 			  PORTD=PORTD&0xf4;
    015EC B382      IN	R24,0x12
    015ED 7F84      ANDI	R24,0xF4
    015EE BB82      OUT	0x12,R24
(1806) 			  senddata(0xaa);//0xfc
    015EF EA0A      LDI	R16,0xAA
    015F0 940E 02CA CALL	_senddata
(1807) 			  senddata(0x49);
    015F2 E409      LDI	R16,0x49
    015F3 940E 02CA CALL	_senddata
(1808) 			  senddata(0xff);
    015F5 EF0F      LDI	R16,0xFF
    015F6 940E 02CA CALL	_senddata
(1809) 			  senddata(0x0c);
    015F8 E00C      LDI	R16,0xC
    015F9 940E 02CA CALL	_senddata
(1810) 			  senddata(0xbb);
    015FB EB0B      LDI	R16,0xBB
    015FC 940E 02CA CALL	_senddata
(1811) 			}
(1812) 			
(1813) 			//senddata(FISHID[0]);
(1814) 			//senddata(PORTD&0xf7);//0xf4
(1815) 						//tem=redata&0x07-4;//0x44-0x47,频率1-4,tem(0-3)
(1816) 		    //freqs[0]=tem;
(1817) 		   // PORTD=freq[freqs[0]];
(1818)            // i2c_write(ADD_f,freqs_I2C,freqs,1);
(1819) 		 }//if(f_change)		
(1820) 	
(1821) 	   //清零所有标志位,id_change在以上if(id_change)之外的if(*_change)中清零
(1822) 	     isSrlStart=0;
    015FE 2422      CLR	R2
    015FF 9220 0307 STS	isSrlStart,R2
(1823) 	     addr=0;
    01601 9220 0309 STS	addr,R2
(1824) 		 isInstruction=0;
    01603 9220 0317 STS	isInstruction,R2
(1825) 	     s_change=0;
    01605 9220 030B STS	s_change,R2
(1826) 		 a_change=0;
    01607 9220 0311 STS	a_change,R2
(1827) 	     d_change=0;
    01609 9220 030C STS	d_change,R2
(1828) 	     t_change=0;
    0160B 9220 030F STS	t_change,R2
(1829) 	     ts_change=0;
    0160D 9220 0310 STS	ts_change,R2
(1830) 	     //id_change=0;
(1831) 	     f_change=0;
    0160F 9220 0312 STS	f_change,R2
(1832) 	     e_change=0;
    01611 9220 0314 STS	e_change,R2
(1833) 		}//if(e_change)
(1834) 	   
(1835) 	   if(m_change)//更改模态，m_tem模态码
    01613 9020 031A LDS	R2,m_change
    01615 2022      TST	R2
    01616 F409      BNE	0x1618
    01617 C0EE      RJMP	0x1706
(1836) 	   {
(1837) 	     m_cishu--;//若++第一次反应慢
    01618 9180 031B LDS	R24,m_cishu
    0161A 5081      SUBI	R24,1
    0161B 9380 031B STS	m_cishu,R24
(1838) 	     if(m_cishu==0xff)
    0161D 3F8F      CPI	R24,0xFF
    0161E F009      BEQ	0x1620
    0161F C0E6      RJMP	0x1706
(1839) 	     {
(1840) 		   mm_cishu--;//若++第一次反应慢
    01620 9180 031C LDS	R24,mm_cishu
    01622 5081      SUBI	R24,1
    01623 9380 031C STS	mm_cishu,R24
(1841) 		   if(mm_cishu==0xff)
    01625 3F8F      CPI	R24,0xFF
    01626 F009      BEQ	0x1628
    01627 C0DE      RJMP	0x1706
(1842) 		   {
(1843) 			 mmm_cishu++;
    01628 9180 031D LDS	R24,mmm_cishu
    0162A 5F8F      SUBI	R24,0xFF
    0162B 9380 031D STS	mmm_cishu,R24
(1844) 			 if(mmm_cishu==m_time)
    0162D 3180      CPI	R24,0x10
    0162E F009      BEQ	0x1630
    0162F C0D6      RJMP	0x1706
(1845) 			 {
(1846) 		     mmm_cishu=0;
    01630 2422      CLR	R2
    01631 9220 031D STS	mmm_cishu,R2
(1847) 			 //执行代码
(1848) 			 cishu++;
    01633 9180 0321 LDS	R24,cishu
    01635 5F8F      SUBI	R24,0xFF
    01636 9380 0321 STS	cishu,R24
(1849) 			 if(cishu==3)
    01638 3083      CPI	R24,3
    01639 F411      BNE	0x163C
(1850) 			 {
(1851) 			  cishu=0;
    0163A 9220 0321 STS	cishu,R2
(1852) 			 }//if(cishu==3)
(1853) 			 switch(m_tem&0x0f)
    0163C 9160 032D LDS	R22,m_tem
    0163E 2777      CLR	R23
    0163F 706F      ANDI	R22,0xF
    01640 7070      ANDI	R23,0
    01641 3061      CPI	R22,1
    01642 E0E0      LDI	R30,0
    01643 077E      CPC	R23,R30
    01644 F031      BEQ	0x164B
    01645 3062      CPI	R22,2
    01646 E0E0      LDI	R30,0
    01647 077E      CPC	R23,R30
    01648 F409      BNE	0x164A
    01649 C05E      RJMP	0x16A8
    0164A C0BB      RJMP	0x1706
(1854) 			 {
(1855) 			 case 0x01://模态1
(1856) 					   switch(cishu)
    0164B 9160 0321 LDS	R22,cishu
    0164D 2777      CLR	R23
    0164E 3060      CPI	R22,0
    0164F 0767      CPC	R22,R23
    01650 F051      BEQ	0x165B
    01651 3061      CPI	R22,1
    01652 E0E0      LDI	R30,0
    01653 077E      CPC	R23,R30
    01654 F0F9      BEQ	0x1674
    01655 3062      CPI	R22,2
    01656 E0E0      LDI	R30,0
    01657 077E      CPC	R23,R30
    01658 F409      BNE	0x165A
    01659 C033      RJMP	0x168D
    0165A C0AB      RJMP	0x1706
(1857) 					   {
(1858) 					   case 0x00://0,低速1
(1859) 					             Speed=Speed_tem_z[1];
    0165B 9020 0152 LDS	R2,Speed_tem_z+1
    0165D 9220 0100 STS	Speed,R2
(1860) 		                         for(i=0;i<=2;i++)		  
    0165F 2744      CLR	R20
    01660 C00D      RJMP	0x166E
(1861) 		                            Dynamic_Offset_degree [i]=0;
    01661 EC8A      LDI	R24,0xCA
    01662 E093      LDI	R25,3
    01663 2FE4      MOV	R30,R20
    01664 27FF      CLR	R31
    01665 0FEE      LSL	R30
    01666 1FFF      ROL	R31
    01667 0FE8      ADD	R30,R24
    01668 1FF9      ADC	R31,R25
    01669 2422      CLR	R2
    0166A 2433      CLR	R3
    0166B 8231      STD	Z+1,R3
    0166C 8220      ST	Z,R2
    0166D 9543      INC	R20
    0166E E082      LDI	R24,2
    0166F 1784      CP	R24,R20
    01670 F780      BCC	0x1661
(1862) 		                         init_dynamic_offset();
    01671 940E 04B9 CALL	_init_dynamic_offset
(1863) 								 
(1864) 								 break;//0
    01673 C092      RJMP	0x1706
(1865) 					   case 0x01://1，高速15
(1866) 								 Speed=Speed_tem_z[15];
    01674 9020 0160 LDS	R2,Speed_tem_z+15
    01676 9220 0100 STS	Speed,R2
(1867) 								 for(i=0;i<=2;i++)
    01678 2744      CLR	R20
    01679 C00D      RJMP	0x1687
(1868) 								    Dynamic_Offset_degree [i]=0;
    0167A EC8A      LDI	R24,0xCA
    0167B E093      LDI	R25,3
    0167C 2FE4      MOV	R30,R20
    0167D 27FF      CLR	R31
    0167E 0FEE      LSL	R30
    0167F 1FFF      ROL	R31
    01680 0FE8      ADD	R30,R24
    01681 1FF9      ADC	R31,R25
    01682 2422      CLR	R2
    01683 2433      CLR	R3
    01684 8231      STD	Z+1,R3
    01685 8220      ST	Z,R2
    01686 9543      INC	R20
    01687 E082      LDI	R24,2
    01688 1784      CP	R24,R20
    01689 F780      BCC	0x167A
(1869) 								 init_dynamic_offset();
    0168A 940E 04B9 CALL	_init_dynamic_offset
(1870) 								 break;//1  
    0168C C079      RJMP	0x1706
(1871) 					   case 0x02://2，转弯1
(1872) 		 	                     for(i=0;i<=2;i++)  
    0168D 2744      CLR	R20
    0168E C013      RJMP	0x16A2
(1873) 				                   Dynamic_Offset_degree [i]=Dynamic_Offset_degree_origin [1][i];
    0168F E489      LDI	R24,0x49
    01690 E093      LDI	R25,3
    01691 2FE4      MOV	R30,R20
    01692 27FF      CLR	R31
    01693 0FE8      ADD	R30,R24
    01694 1FF9      ADC	R31,R25
    01695 8020      LD	R2,Z
    01696 2433      CLR	R3
    01697 EC8A      LDI	R24,0xCA
    01698 E093      LDI	R25,3
    01699 2FE4      MOV	R30,R20
    0169A 27FF      CLR	R31
    0169B 0FEE      LSL	R30
    0169C 1FFF      ROL	R31
    0169D 0FE8      ADD	R30,R24
    0169E 1FF9      ADC	R31,R25
    0169F 8231      STD	Z+1,R3
    016A0 8220      ST	Z,R2
    016A1 9543      INC	R20
    016A2 E082      LDI	R24,2
    016A3 1784      CP	R24,R20
    016A4 F750      BCC	0x168F
(1874) 		                         init_dynamic_offset(); 
    016A5 940E 04B9 CALL	_init_dynamic_offset
(1875) 					             break;//2
(1876) 					   }//switch(cishu)
(1877) 			           break;//case模态1
    016A7 C05E      RJMP	0x1706
(1878) 		     case 0x02://模态2
(1879) 					   switch(cishu)
    016A8 9160 0321 LDS	R22,cishu
    016AA 2777      CLR	R23
    016AB 3060      CPI	R22,0
    016AC 0767      CPC	R22,R23
    016AD F051      BEQ	0x16B8
    016AE 3061      CPI	R22,1
    016AF E0E0      LDI	R30,0
    016B0 077E      CPC	R23,R30
    016B1 F109      BEQ	0x16D3
    016B2 3062      CPI	R22,2
    016B3 E0E0      LDI	R30,0
    016B4 077E      CPC	R23,R30
    016B5 F409      BNE	0x16B7
    016B6 C037      RJMP	0x16EE
    016B7 C04E      RJMP	0x1706
(1880) 					   {
(1881) 					   case 0x00://0，左转1
(1882) 		 	                     for(i=0;i<=2;i++)
    016B8 2744      CLR	R20
    016B9 C013      RJMP	0x16CD
(1883) 				                   Dynamic_Offset_degree [i]=Dynamic_Offset_degree_origin [1][i];
    016BA E489      LDI	R24,0x49
    016BB E093      LDI	R25,3
    016BC 2FE4      MOV	R30,R20
    016BD 27FF      CLR	R31
    016BE 0FE8      ADD	R30,R24
    016BF 1FF9      ADC	R31,R25
    016C0 8020      LD	R2,Z
    016C1 2433      CLR	R3
    016C2 EC8A      LDI	R24,0xCA
    016C3 E093      LDI	R25,3
    016C4 2FE4      MOV	R30,R20
    016C5 27FF      CLR	R31
    016C6 0FEE      LSL	R30
    016C7 1FFF      ROL	R31
    016C8 0FE8      ADD	R30,R24
    016C9 1FF9      ADC	R31,R25
    016CA 8231      STD	Z+1,R3
    016CB 8220      ST	Z,R2
    016CC 9543      INC	R20
    016CD E082      LDI	R24,2
    016CE 1784      CP	R24,R20
    016CF F750      BCC	0x16BA
(1884) 		                         init_dynamic_offset(); 
    016D0 940E 04B9 CALL	_init_dynamic_offset
(1885)      							 break;//0
    016D2 C033      RJMP	0x1706
(1886) 					   case 0x01://1，右转12
(1887) 		 	                     for(i=0;i<=2;i++)
    016D3 2744      CLR	R20
    016D4 C013      RJMP	0x16E8
(1888) 				                   Dynamic_Offset_degree [i]=Dynamic_Offset_degree_origin [12][i];
    016D5 E68A      LDI	R24,0x6A
    016D6 E093      LDI	R25,3
    016D7 2FE4      MOV	R30,R20
    016D8 27FF      CLR	R31
    016D9 0FE8      ADD	R30,R24
    016DA 1FF9      ADC	R31,R25
    016DB 8020      LD	R2,Z
    016DC 2433      CLR	R3
    016DD EC8A      LDI	R24,0xCA
    016DE E093      LDI	R25,3
    016DF 2FE4      MOV	R30,R20
    016E0 27FF      CLR	R31
    016E1 0FEE      LSL	R30
    016E2 1FFF      ROL	R31
    016E3 0FE8      ADD	R30,R24
    016E4 1FF9      ADC	R31,R25
    016E5 8231      STD	Z+1,R3
    016E6 8220      ST	Z,R2
    016E7 9543      INC	R20
    016E8 E082      LDI	R24,2
    016E9 1784      CP	R24,R20
    016EA F750      BCC	0x16D5
(1889) 		                         init_dynamic_offset(); 
    016EB 940E 04B9 CALL	_init_dynamic_offset
(1890) 								 break;//1
    016ED C018      RJMP	0x1706
(1891) 					   case 0x02://2，前进12
(1892) 								 Speed=Speed_tem_z[12];
    016EE 9020 015D LDS	R2,Speed_tem_z+12
    016F0 9220 0100 STS	Speed,R2
(1893) 								 for(i=0;i<=2;i++)
    016F2 2744      CLR	R20
    016F3 C00D      RJMP	0x1701
(1894) 								    Dynamic_Offset_degree [i]=0;
    016F4 EC8A      LDI	R24,0xCA
    016F5 E093      LDI	R25,3
    016F6 2FE4      MOV	R30,R20
    016F7 27FF      CLR	R31
    016F8 0FEE      LSL	R30
    016F9 1FFF      ROL	R31
    016FA 0FE8      ADD	R30,R24
    016FB 1FF9      ADC	R31,R25
    016FC 2422      CLR	R2
    016FD 2433      CLR	R3
    016FE 8231      STD	Z+1,R3
    016FF 8220      ST	Z,R2
    01700 9543      INC	R20
    01701 E082      LDI	R24,2
    01702 1784      CP	R24,R20
    01703 F780      BCC	0x16F4
(1895) 								 init_dynamic_offset();					             
    01704 940E 04B9 CALL	_init_dynamic_offset
(1896) 								 break;//2
(1897) 					   }//switch(cishu)			           
(1898) 			           break;//case模态2
(1899) 			 }//switch(m_tem)
(1900) 			 //代码结束
(1901) 			 }//if(mmm_cishu)
(1902) 		   }//if(mm_cishu)		   
(1903) 		 }//if(m_cishu)...延时作用
(1904)        }//if(m_change)
(1905) 	   
(1906) 		if(y_change)//原始转弯模式
    01706 9020 0323 LDS	R2,y_change
    01708 2022      TST	R2
    01709 F409      BNE	0x170B
    0170A C1E0      RJMP	0x18EB
(1907) 		{
(1908) 			y_cishu--;
    0170B 9180 0326 LDS	R24,y_cishu
    0170D 5081      SUBI	R24,1
    0170E 9380 0326 STS	y_cishu,R24
(1909) 			if(y_cishu==0xff)
    01710 3F8F      CPI	R24,0xFF
    01711 F009      BEQ	0x1713
    01712 C1D8      RJMP	0x18EB
(1910) 			{
(1911) 				yy_cishu--;
    01713 9180 0327 LDS	R24,yy_cishu
    01715 5081      SUBI	R24,1
    01716 9380 0327 STS	yy_cishu,R24
(1912) 
(1913) 				if(yy_cishu==0xff)
    01718 3F8F      CPI	R24,0xFF
    01719 F009      BEQ	0x171B
    0171A C1D0      RJMP	0x18EB
(1914) 				{
(1915) 					yyy_cishu++;
    0171B 9180 0328 LDS	R24,yyy_cishu
    0171D 5F8F      SUBI	R24,0xFF
    0171E 9380 0328 STS	yyy_cishu,R24
(1916) 					yy_cishu=yy_time;
    01720 9020 0325 LDS	R2,yy_time
    01722 9220 0327 STS	yy_cishu,R2
(1917) 
(1918) 					if(yyy_cishu==y_time)
    01724 3082      CPI	R24,2
    01725 F009      BEQ	0x1727
    01726 C1C4      RJMP	0x18EB
(1919) 					{
(1920) 						yyy_cishu=0;
    01727 2422      CLR	R2
    01728 9220 0328 STS	yyy_cishu,R2
(1921) 
(1922) 						//执行代码
(1923) 						if(cishu_y==1)//回到收到命令前的速度，直游
    0172A 9180 0329 LDS	R24,cishu_y
    0172C 3081      CPI	R24,1
    0172D F009      BEQ	0x172F
    0172E C037      RJMP	0x1766
(1924) 						{
(1925) 							y_change=0;
    0172F 9220 0323 STS	y_change,R2
(1926) 							y_changing=0;
    01731 9220 0324 STS	y_changing,R2
(1927) 							Speed=y_speed;
    01733 9020 032B LDS	R2,y_speed
    01735 9220 0100 STS	Speed,R2
(1928) 							for(i=0;i<=2;i++)		  
    01737 2744      CLR	R20
    01738 C00D      RJMP	0x1746
(1929) 								Dynamic_Offset_degree [i]=0;
    01739 EC8A      LDI	R24,0xCA
    0173A E093      LDI	R25,3
    0173B 2FE4      MOV	R30,R20
    0173C 27FF      CLR	R31
    0173D 0FEE      LSL	R30
    0173E 1FFF      ROL	R31
    0173F 0FE8      ADD	R30,R24
    01740 1FF9      ADC	R31,R25
    01741 2422      CLR	R2
    01742 2433      CLR	R3
    01743 8231      STD	Z+1,R3
    01744 8220      ST	Z,R2
    01745 9543      INC	R20
    01746 E082      LDI	R24,2
    01747 1784      CP	R24,R20
    01748 F780      BCC	0x1739
(1930) 							for(i=0;i<=2;i++)//对应摆幅变化
    01749 2744      CLR	R20
    0174A C016      RJMP	0x1761
(1931) 								Amplitude_degree[i]=Amplitude_degree_tem[s_tem][i];
    0174B 9110 032C LDS	R17,s_tem
    0174D E003      LDI	R16,3
    0174E 0301      MULSU	R16,R17
    0174F 0110      MOVW	R2,R0
    01750 EF81      LDI	R24,0xF1
    01751 E093      LDI	R25,3
    01752 0E28      ADD	R2,R24
    01753 1E39      ADC	R3,R25
    01754 2FE4      MOV	R30,R20
    01755 27FF      CLR	R31
    01756 0DE2      ADD	R30,R2
    01757 1DF3      ADC	R31,R3
    01758 8020      LD	R2,Z
    01759 EE8E      LDI	R24,0xEE
    0175A E093      LDI	R25,3
    0175B 2FE4      MOV	R30,R20
    0175C 27FF      CLR	R31
    0175D 0FE8      ADD	R30,R24
    0175E 1FF9      ADC	R31,R25
    0175F 8220      ST	Z,R2
    01760 9543      INC	R20
    01761 E082      LDI	R24,2
    01762 1784      CP	R24,R20
    01763 F738      BCC	0x174B
(1932) 							init_dynamic_offset();
    01764 940E 04B9 CALL	_init_dynamic_offset
(1933) 						}//if(cishu_y==1)
(1934) 
(1935) 						if(cishu_y==0)
    01766 9020 0329 LDS	R2,cishu_y
    01768 2022      TST	R2
    01769 F009      BEQ	0x176B
    0176A C180      RJMP	0x18EB
(1936) 						{
(1937) 							cishu_y++;
    0176B 2D82      MOV	R24,R2
    0176C 5F8F      SUBI	R24,0xFF
    0176D 9380 0329 STS	cishu_y,R24
(1938) 							tem_y=y_tem&0x0f;
    0176F 9160 032A LDS	R22,y_tem
    01771 706F      ANDI	R22,0xF
(1939) 							Speed=0;
    01772 2422      CLR	R2
    01773 9220 0100 STS	Speed,R2
(1940) 							for(i=0;i<=2;i++)
    01775 2744      CLR	R20
    01776 C019      RJMP	0x1790
(1941) 								Dynamic_Offset_degree [i]=Dynamic_Offset_degree_y [tem_y][i];
    01777 2EA4      MOV	R10,R20
    01778 24BB      CLR	R11
    01779 0CAA      LSL	R10
    0177A 1CBB      ROL	R11
    0177B E006      LDI	R16,6
    0177C 2F16      MOV	R17,R22
    0177D 0301      MULSU	R16,R17
    0177E 0110      MOVW	R2,R0
    0177F E58E      LDI	R24,0x5E
    01780 E093      LDI	R25,3
    01781 0E28      ADD	R2,R24
    01782 1E39      ADC	R3,R25
    01783 01F5      MOVW	R30,R10
    01784 0DE2      ADD	R30,R2
    01785 1DF3      ADC	R31,R3
    01786 8020      LD	R2,Z
    01787 8031      LDD	R3,Z+1
    01788 EC8A      LDI	R24,0xCA
    01789 E093      LDI	R25,3
    0178A 01F5      MOVW	R30,R10
    0178B 0FE8      ADD	R30,R24
    0178C 1FF9      ADC	R31,R25
    0178D 8231      STD	Z+1,R3
    0178E 8220      ST	Z,R2
    0178F 9543      INC	R20
    01790 E082      LDI	R24,2
    01791 1784      CP	R24,R20
    01792 F720      BCC	0x1777
(1942) 							init_dynamic_offset(); 			 
    01793 940E 04B9 CALL	_init_dynamic_offset
(1943) 						}//if(cishu_y==0)
(1944) 						//代码结束
(1945) 
(1946) 					}//if(yyy_cishu)
(1947) 				}//if(yy_cishu)		   
(1948) 			}//if(y_cishu)...延时作用
(1949) 		}//if(y_change)	
(1950) 	}//if(is_uart==1)
    01795 C155      RJMP	0x18EB
(1951) 
(1952) ///////////----手动模式--END//////////////////////////////////////////	
(1953) 
(1954) ///////////----自动模式--BEGIN//////////////////////////////////////////	
(1955) 
(1956) 		else//自动模式,is_uart==0
(1957) 		{
(1958)              a_cishu--;//若++第一次反应慢
    01796 9180 031E LDS	R24,a_cishu
    01798 5081      SUBI	R24,1
    01799 9380 031E STS	a_cishu,R24
(1959) 	    	    if(a_cishu==0xff)
    0179B 3F8F      CPI	R24,0xFF
    0179C F009      BEQ	0x179E
    0179D C14D      RJMP	0x18EB
(1960) 	            {
(1961) 		          aa_cishu--;//若++第一次反应慢
    0179E 9180 031F LDS	R24,aa_cishu
    017A0 5081      SUBI	R24,1
    017A1 9380 031F STS	aa_cishu,R24
(1962) 		           if(aa_cishu==0xff)
    017A3 3F8F      CPI	R24,0xFF
    017A4 F009      BEQ	0x17A6
    017A5 C145      RJMP	0x18EB
(1963) 		           {
(1964) 			           aaa_cishu++;
    017A6 9180 0320 LDS	R24,aaa_cishu
    017A8 5F8F      SUBI	R24,0xFF
    017A9 9380 0320 STS	aaa_cishu,R24
(1965) 			           if(aaa_cishu==m_time)
    017AB 3180      CPI	R24,0x10
    017AC F009      BEQ	0x17AE
    017AD C13D      RJMP	0x18EB
(1966) 			           {
(1967) 		                aaa_cishu=0; 
    017AE 2422      CLR	R2
    017AF 9220 0320 STS	aaa_cishu,R2
(1968) 			            //执行代码
(1969) 			            auto_cishu++;
    017B1 9180 0322 LDS	R24,auto_cishu
    017B3 5F8F      SUBI	R24,0xFF
    017B4 9380 0322 STS	auto_cishu,R24
(1970) 			            if(auto_cishu==7)
    017B6 3087      CPI	R24,7
    017B7 F419      BNE	0x17BB
(1971) 			            {
(1972) 			                 auto_cishu=1;
    017B8 E081      LDI	R24,1
    017B9 9380 0322 STS	auto_cishu,R24
(1973) 			             }//if(auto_cishu==6)
(1974) 
(1975) 					   switch(auto_cishu)
    017BB 9160 0322 LDS	R22,auto_cishu
    017BD 2777      CLR	R23
    017BE 3061      CPI	R22,1
    017BF E0E0      LDI	R30,0
    017C0 077E      CPC	R23,R30
    017C1 F0D1      BEQ	0x17DC
    017C2 3062      CPI	R22,2
    017C3 E0E0      LDI	R30,0
    017C4 077E      CPC	R23,R30
    017C5 F409      BNE	0x17C7
    017C6 C042      RJMP	0x1809
    017C7 3063      CPI	R22,3
    017C8 E0E0      LDI	R30,0
    017C9 077E      CPC	R23,R30
    017CA F409      BNE	0x17CC
    017CB C06B      RJMP	0x1837
    017CC 3064      CPI	R22,4
    017CD E0E0      LDI	R30,0
    017CE 077E      CPC	R23,R30
    017CF F409      BNE	0x17D1
    017D0 C093      RJMP	0x1864
    017D1 3065      CPI	R22,5
    017D2 E0E0      LDI	R30,0
    017D3 077E      CPC	R23,R30
    017D4 F409      BNE	0x17D6
    017D5 C0BB      RJMP	0x1891
    017D6 3066      CPI	R22,6
    017D7 E0E0      LDI	R30,0
    017D8 077E      CPC	R23,R30
    017D9 F409      BNE	0x17DB
    017DA C0E4      RJMP	0x18BF
    017DB C10F      RJMP	0x18EB
(1976) 					   {
(1977) 					   case 0x01://直游，15
(1978) 						   Speed=Speed_tem_z[15];
    017DC 9020 0160 LDS	R2,Speed_tem_z+15
    017DE 9220 0100 STS	Speed,R2
(1979) 						   for(i=0;i<=2;i++)//对应摆幅变化
    017E0 2744      CLR	R20
    017E1 C00F      RJMP	0x17F1
(1980) 							   Amplitude_degree[i]=Amplitude_degree_tem[15][i];
    017E2 E18E      LDI	R24,0x1E
    017E3 E094      LDI	R25,4
    017E4 2FE4      MOV	R30,R20
    017E5 27FF      CLR	R31
    017E6 0FE8      ADD	R30,R24
    017E7 1FF9      ADC	R31,R25
    017E8 8020      LD	R2,Z
    017E9 EE8E      LDI	R24,0xEE
    017EA E093      LDI	R25,3
    017EB 2FE4      MOV	R30,R20
    017EC 27FF      CLR	R31
    017ED 0FE8      ADD	R30,R24
    017EE 1FF9      ADC	R31,R25
    017EF 8220      ST	Z,R2
    017F0 9543      INC	R20
    017F1 E082      LDI	R24,2
    017F2 1784      CP	R24,R20
    017F3 F770      BCC	0x17E2
(1981) 						   for(i=0;i<=2;i++)
    017F4 2744      CLR	R20
    017F5 C00D      RJMP	0x1803
(1982) 							   Dynamic_Offset_degree[i]=0;
    017F6 EC8A      LDI	R24,0xCA
    017F7 E093      LDI	R25,3
    017F8 2FE4      MOV	R30,R20
    017F9 27FF      CLR	R31
    017FA 0FEE      LSL	R30
    017FB 1FFF      ROL	R31
    017FC 0FE8      ADD	R30,R24
    017FD 1FF9      ADC	R31,R25
    017FE 2422      CLR	R2
    017FF 2433      CLR	R3
    01800 8231      STD	Z+1,R3
    01801 8220      ST	Z,R2
    01802 9543      INC	R20
    01803 E082      LDI	R24,2
    01804 1784      CP	R24,R20
    01805 F780      BCC	0x17F6
(1983) 						   init_dynamic_offset();
    01806 940E 04B9 CALL	_init_dynamic_offset
(1984) 						   break;
    01808 C0E2      RJMP	0x18EB
(1985) 					   case 0x02://右转
(1986) 						   Speed=Speed_tem_z[15];
    01809 9020 0160 LDS	R2,Speed_tem_z+15
    0180B 9220 0100 STS	Speed,R2
(1987) 						   for(i=0;i<=2;i++)
    0180D 2744      CLR	R20
    0180E C022      RJMP	0x1831
(1988) 							{
(1989) 								Dynamic_Offset_degree_char[i]=Dynamic_Offset_degree_origin[3][i];
    0180F E48F      LDI	R24,0x4F
    01810 E093      LDI	R25,3
    01811 2FE4      MOV	R30,R20
    01812 27FF      CLR	R31
    01813 0FE8      ADD	R30,R24
    01814 1FF9      ADC	R31,R25
    01815 8020      LD	R2,Z
    01816 ED80      LDI	R24,0xD0
    01817 E093      LDI	R25,3
    01818 2FE4      MOV	R30,R20
    01819 27FF      CLR	R31
    0181A 0FE8      ADD	R30,R24
    0181B 1FF9      ADC	R31,R25
    0181C 8220      ST	Z,R2
(1990) 								Dynamic_Offset_degree[i]=char2int(Dynamic_Offset_degree_char[i],0);
    0181D 2722      CLR	R18
    0181E 2FE4      MOV	R30,R20
    0181F 27FF      CLR	R31
    01820 0FE8      ADD	R30,R24
    01821 1FF9      ADC	R31,R25
    01822 8100      LD	R16,Z
    01823 940E 065E CALL	_char2int
    01825 0158      MOVW	R10,R16
    01826 EC8A      LDI	R24,0xCA
    01827 E093      LDI	R25,3
    01828 2FE4      MOV	R30,R20
    01829 27FF      CLR	R31
    0182A 0FEE      LSL	R30
    0182B 1FFF      ROL	R31
    0182C 0FE8      ADD	R30,R24
    0182D 1FF9      ADC	R31,R25
    0182E 82B1      STD	Z+1,R11
    0182F 82A0      ST	Z,R10
    01830 9543      INC	R20
    01831 E082      LDI	R24,2
    01832 1784      CP	R24,R20
    01833 F6D8      BCC	0x180F
(1991) 							}
(1992) 							init_dynamic_offset();
    01834 940E 04B9 CALL	_init_dynamic_offset
(1993) 						   break;
    01836 C0B4      RJMP	0x18EB
(1994) 					   case 0x03://直游，11
(1995) 						   Speed=Speed_tem_z[11];
    01837 9020 015C LDS	R2,Speed_tem_z+11
    01839 9220 0100 STS	Speed,R2
(1996) 						   for(i=0;i<=2;i++)//对应摆幅变化
    0183B 2744      CLR	R20
    0183C C00F      RJMP	0x184C
(1997) 							   Amplitude_degree[i]=Amplitude_degree_tem[11][i];
    0183D E182      LDI	R24,0x12
    0183E E094      LDI	R25,4
    0183F 2FE4      MOV	R30,R20
    01840 27FF      CLR	R31
    01841 0FE8      ADD	R30,R24
    01842 1FF9      ADC	R31,R25
    01843 8020      LD	R2,Z
    01844 EE8E      LDI	R24,0xEE
    01845 E093      LDI	R25,3
    01846 2FE4      MOV	R30,R20
    01847 27FF      CLR	R31
    01848 0FE8      ADD	R30,R24
    01849 1FF9      ADC	R31,R25
    0184A 8220      ST	Z,R2
    0184B 9543      INC	R20
    0184C E082      LDI	R24,2
    0184D 1784      CP	R24,R20
    0184E F770      BCC	0x183D
(1998) 						   for(i=0;i<=2;i++)
    0184F 2744      CLR	R20
    01850 C00D      RJMP	0x185E
(1999) 							   Dynamic_Offset_degree[i]=0;
    01851 EC8A      LDI	R24,0xCA
    01852 E093      LDI	R25,3
    01853 2FE4      MOV	R30,R20
    01854 27FF      CLR	R31
    01855 0FEE      LSL	R30
    01856 1FFF      ROL	R31
    01857 0FE8      ADD	R30,R24
    01858 1FF9      ADC	R31,R25
    01859 2422      CLR	R2
    0185A 2433      CLR	R3
    0185B 8231      STD	Z+1,R3
    0185C 8220      ST	Z,R2
    0185D 9543      INC	R20
    0185E E082      LDI	R24,2
    0185F 1784      CP	R24,R20
    01860 F780      BCC	0x1851
(2000) 						   init_dynamic_offset();
    01861 940E 04B9 CALL	_init_dynamic_offset
(2001) 						   break;
    01863 C087      RJMP	0x18EB
(2002) 					   case 0x04://直游，11
(2003) 						   Speed=Speed_tem_z[11];
    01864 9020 015C LDS	R2,Speed_tem_z+11
    01866 9220 0100 STS	Speed,R2
(2004) 						   for(i=0;i<=2;i++)//对应摆幅变化
    01868 2744      CLR	R20
    01869 C00F      RJMP	0x1879
(2005) 							   Amplitude_degree[i]=Amplitude_degree_tem[11][i];
    0186A E182      LDI	R24,0x12
    0186B E094      LDI	R25,4
    0186C 2FE4      MOV	R30,R20
    0186D 27FF      CLR	R31
    0186E 0FE8      ADD	R30,R24
    0186F 1FF9      ADC	R31,R25
    01870 8020      LD	R2,Z
    01871 EE8E      LDI	R24,0xEE
    01872 E093      LDI	R25,3
    01873 2FE4      MOV	R30,R20
    01874 27FF      CLR	R31
    01875 0FE8      ADD	R30,R24
    01876 1FF9      ADC	R31,R25
    01877 8220      ST	Z,R2
    01878 9543      INC	R20
    01879 E082      LDI	R24,2
    0187A 1784      CP	R24,R20
    0187B F770      BCC	0x186A
(2006) 						   for(i=0;i<=2;i++)
    0187C 2744      CLR	R20
    0187D C00D      RJMP	0x188B
(2007) 							   Dynamic_Offset_degree[i]=0;
    0187E EC8A      LDI	R24,0xCA
    0187F E093      LDI	R25,3
    01880 2FE4      MOV	R30,R20
    01881 27FF      CLR	R31
    01882 0FEE      LSL	R30
    01883 1FFF      ROL	R31
    01884 0FE8      ADD	R30,R24
    01885 1FF9      ADC	R31,R25
    01886 2422      CLR	R2
    01887 2433      CLR	R3
    01888 8231      STD	Z+1,R3
    01889 8220      ST	Z,R2
    0188A 9543      INC	R20
    0188B E082      LDI	R24,2
    0188C 1784      CP	R24,R20
    0188D F780      BCC	0x187E
(2008) 						   init_dynamic_offset();
    0188E 940E 04B9 CALL	_init_dynamic_offset
(2009) 						   break;
    01890 C05A      RJMP	0x18EB
(2010) 					   case 0x05://右转
(2011) 						   Speed=Speed_tem_z[11];
    01891 9020 015C LDS	R2,Speed_tem_z+11
    01893 9220 0100 STS	Speed,R2
(2012)                            for(i=0;i<=2;i++)
    01895 2744      CLR	R20
    01896 C022      RJMP	0x18B9
(2013) 							{
(2014) 								Dynamic_Offset_degree_char[i]=Dynamic_Offset_degree_origin[3][i];
    01897 E48F      LDI	R24,0x4F
    01898 E093      LDI	R25,3
    01899 2FE4      MOV	R30,R20
    0189A 27FF      CLR	R31
    0189B 0FE8      ADD	R30,R24
    0189C 1FF9      ADC	R31,R25
    0189D 8020      LD	R2,Z
    0189E ED80      LDI	R24,0xD0
    0189F E093      LDI	R25,3
    018A0 2FE4      MOV	R30,R20
    018A1 27FF      CLR	R31
    018A2 0FE8      ADD	R30,R24
    018A3 1FF9      ADC	R31,R25
    018A4 8220      ST	Z,R2
(2015) 								Dynamic_Offset_degree[i]=char2int(Dynamic_Offset_degree_char[i],0);
    018A5 2722      CLR	R18
    018A6 2FE4      MOV	R30,R20
    018A7 27FF      CLR	R31
    018A8 0FE8      ADD	R30,R24
    018A9 1FF9      ADC	R31,R25
    018AA 8100      LD	R16,Z
    018AB 940E 065E CALL	_char2int
    018AD 0158      MOVW	R10,R16
    018AE EC8A      LDI	R24,0xCA
    018AF E093      LDI	R25,3
    018B0 2FE4      MOV	R30,R20
    018B1 27FF      CLR	R31
    018B2 0FEE      LSL	R30
    018B3 1FFF      ROL	R31
    018B4 0FE8      ADD	R30,R24
    018B5 1FF9      ADC	R31,R25
    018B6 82B1      STD	Z+1,R11
    018B7 82A0      ST	Z,R10
    018B8 9543      INC	R20
    018B9 E082      LDI	R24,2
    018BA 1784      CP	R24,R20
    018BB F6D8      BCC	0x1897
(2016) 							}
(2017) 							init_dynamic_offset();
    018BC 940E 04B9 CALL	_init_dynamic_offset
(2018) 							break;
    018BE C02C      RJMP	0x18EB
(2019) 						case 0x06://直游，15
(2020) 						   Speed=Speed_tem_z[15];
    018BF 9020 0160 LDS	R2,Speed_tem_z+15
    018C1 9220 0100 STS	Speed,R2
(2021) 						   for(i=0;i<=2;i++)//对应摆幅变化
    018C3 2744      CLR	R20
    018C4 C00F      RJMP	0x18D4
(2022) 							   Amplitude_degree[i]=Amplitude_degree_tem[15][i];
    018C5 E18E      LDI	R24,0x1E
    018C6 E094      LDI	R25,4
    018C7 2FE4      MOV	R30,R20
    018C8 27FF      CLR	R31
    018C9 0FE8      ADD	R30,R24
    018CA 1FF9      ADC	R31,R25
    018CB 8020      LD	R2,Z
    018CC EE8E      LDI	R24,0xEE
    018CD E093      LDI	R25,3
    018CE 2FE4      MOV	R30,R20
    018CF 27FF      CLR	R31
    018D0 0FE8      ADD	R30,R24
    018D1 1FF9      ADC	R31,R25
    018D2 8220      ST	Z,R2
    018D3 9543      INC	R20
    018D4 E082      LDI	R24,2
    018D5 1784      CP	R24,R20
    018D6 F770      BCC	0x18C5
(2023) 						   for(i=0;i<=2;i++)
    018D7 2744      CLR	R20
    018D8 C00D      RJMP	0x18E6
(2024) 							   Dynamic_Offset_degree[i]=0;
    018D9 EC8A      LDI	R24,0xCA
    018DA E093      LDI	R25,3
    018DB 2FE4      MOV	R30,R20
    018DC 27FF      CLR	R31
    018DD 0FEE      LSL	R30
    018DE 1FFF      ROL	R31
    018DF 0FE8      ADD	R30,R24
    018E0 1FF9      ADC	R31,R25
    018E1 2422      CLR	R2
    018E2 2433      CLR	R3
    018E3 8231      STD	Z+1,R3
    018E4 8220      ST	Z,R2
    018E5 9543      INC	R20
    018E6 E082      LDI	R24,2
    018E7 1784      CP	R24,R20
    018E8 F780      BCC	0x18D9
(2025) 						   init_dynamic_offset();
    018E9 940E 04B9 CALL	_init_dynamic_offset
    018EB C99B      RJMP	0x1287
    018EC 962A      ADIW	R28,0xA
    018ED 9508      RET
FILE: G:\wsg\SchoolTrain\FishRobot\机器鱼\机器鱼培训资料\机器鱼培训资料\机器鱼鱼体波程序\fish_0_100115\TWI_Master.c
(0001) /*****************************************************************************
(0002) *
(0003) * Atmel Corporation
(0004) *
(0005) * File              : TWI_Master.c
(0006) * Compiler          : ICCAVR
(0007) * Revision          : Revision: 2.0
(0008) * Date              : Date: 2005-7-19
(0009) * Updated by        : Author: Yonghui Hu
(0010) *
(0011) * Support mail      : yonghhu@pku.edu.cn
(0012) *
(0013) * Supported devices : All devices with a TWI module can be used.
(0014) *                     The example is written for the ATmega16
(0015) *
(0016) * AppNote           : AVR315 - TWI Master Implementation
(0017) *
(0018) * Description       : This is a sample driver for the TWI hardware modules.
(0019) *                     It is interrupt driveren. All functionality is controlled through 
(0020) *                     passing information to and from functions. Se main.c for samples
(0021) *                     of how to use the driver.
(0022) *
(0023) *
(0024) ****************************************************************************/
(0025) 
(0026) #include "iom128v.h"              
(0027) #include "macros.h"
(0028) #include "TWI_Master.h"
(0029) 
(0030) unsigned char TWI_buf[ TWI_BUFFER_SIZE ];    // Transceiver buffer
(0031) static unsigned char TWI_msgSize;             // Number of bytes to be transmitted.
(0032) static unsigned char TWI_state = TWI_NO_STATE;// State byte. Default set to TWI_NO_STATE.
(0033) 
(0034) unsigned char TWI_statusReg=0;                // TWI_statusReg is defined in TWI_Master.h
(0035) 
(0036) /****************************************************************************
(0037) Call this function to set up the TWI master to its initial standby state.
(0038) Remember to enable interrupts from the main application after initializing the TWI.
(0039) ****************************************************************************/
(0040) void TWI_Master_Initialise(void)
(0041) {
(0042)   TWBR = TWI_TWBR;               //*设置波特率，当处于主机模式时，用来产生SCL引脚上的时钟信号
_TWI_Master_Initialise:
    018EE E08C      LDI	R24,0xC
    018EF 9380 0070 STS	0x70,R24
(0043)                                  // Set bit rate register (Baudrate). Defined in header file.
(0044)                                  // Not used. Driver presumes prescaler to be 00.
(0045)   TWDR = 0xFF;                 //*默认值
    018F1 EF8F      LDI	R24,0xFF
    018F2 9380 0073 STS	0x73,R24
(0046)                               // Default content = SDA released.
(0047)  
(0048)   //*使能IIC
(0049)   TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
    018F4 E084      LDI	R24,4
    018F5 9380 0074 STS	0x74,R24
    018F7 9508      RET
(0050)          (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
(0051)          (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
(0052)          (0<<TWWC);                                 //
(0053)   
(0054) }    
(0055)     
(0056) /****************************************************************************
(0057) Call this function to test if the TWI_ISR is busy transmitting.
(0058) ****************************************************************************/
(0059) unsigned char TWI_Transceiver_Busy( void )
(0060) {
(0061)                // IF TWI Interrupt is enabled then the Transceiver is busy
(0062)     return ( TWCR & (1<<TWIE) );
_TWI_Transceiver_Busy:
    018F8 9100 0074 LDS	R16,0x74
    018FA 7001      ANDI	R16,1
    018FB 9508      RET
(0063) }
(0064) 
(0065) /****************************************************************************
(0066) Call this function to fetch the state information of the previous operation. The function will hold execution (loop)
(0067) until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
(0068) will return the TWI State code. 
(0069) ****************************************************************************/
(0070) unsigned char TWI_Get_State_Info( void )
(0071) {
(0072)   while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
_TWI_Get_State_Info:
    018FC DFFB      RCALL	_TWI_Transceiver_Busy
    018FD 2300      TST	R16
    018FE F7E9      BNE	0x18FC
(0073)   return ( TWI_state );                         // Return error state.
    018FF 9100 0421 LDS	R16,TWI_Master.c:TWI_state
    01901 9508      RET
_TWI_Start_Transceiver_With_Data:
  temp                 --> R20
  msgSize              --> R12
  msg                  --> R10
    01902 940E 1ADC CALL	push_xgset303C
    01904 2EC2      MOV	R12,R18
    01905 0158      MOVW	R10,R16
(0074) }
(0075) 
(0076) /****************************************************************************
(0077) Call this function to send a prepared message. The first byte must contain the slave address and the
(0078) read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
(0079) from the slave. Also include how many bytes that should be sent/read including the address byte.
(0080) The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
(0081) then initialize the next operation and return.
(0082) ****************************************************************************/
(0083) void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
(0084) {
(0085)   unsigned char temp;
(0086) 
(0087)   while ( TWI_Transceiver_Busy() );            // Wait until TWI is ready for next transmission.
    01906 DFF1      RCALL	_TWI_Transceiver_Busy
    01907 2300      TST	R16
    01908 F7E9      BNE	0x1906
(0088) 
(0089)   TWI_msgSize = msgSize;                        // Number of data to transmit.
    01909 92C0 042F STS	TWI_Master.c:TWI_msgSize,R12
(0090)   TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
    0190B 01F5      MOVW	R30,R10
    0190C 8020      LD	R2,Z
    0190D 9220 0430 STS	TWI_buf,R2
(0091)   if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
    0190F FC20      SBRC	R2,0
    01910 C011      RJMP	0x1922
(0092)   {
(0093)     for ( temp = 1; temp < msgSize; temp++ )
    01911 E041      LDI	R20,1
    01912 C00D      RJMP	0x1920
(0094)       TWI_buf[ temp ] = msg[ temp ];
    01913 2FE4      MOV	R30,R20
    01914 27FF      CLR	R31
    01915 0DEA      ADD	R30,R10
    01916 1DFB      ADC	R31,R11
    01917 8020      LD	R2,Z
    01918 E380      LDI	R24,0x30
    01919 E094      LDI	R25,4
    0191A 2FE4      MOV	R30,R20
    0191B 27FF      CLR	R31
    0191C 0FE8      ADD	R30,R24
    0191D 1FF9      ADC	R31,R25
    0191E 8220      ST	Z,R2
    0191F 9543      INC	R20
    01920 154C      CP	R20,R12
    01921 F388      BCS	0x1913
(0095)   }
(0096)   TWI_statusReg = FALSE;      
    01922 2422      CLR	R2
    01923 9220 0422 STS	TWI_statusReg,R2
(0097)   TWI_state = TWI_NO_STATE ;
    01925 EF88      LDI	R24,0xF8
    01926 9380 0421 STS	TWI_Master.c:TWI_state,R24
(0098)   TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    01928 EA85      LDI	R24,0xA5
    01929 9380 0074 STS	0x74,R24
    0192B 940C 1AE3 JMP	pop_xgset303C
(0099)          (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
(0100)          (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
(0101)          (0<<TWWC);                             //
(0102) }
(0103) 
(0104) /****************************************************************************
(0105) Call this function to resend the last message. The driver will reuse the data previously put in the transceiver buffers.
(0106) The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
(0107) then initialize the next operation and return.
(0108) ****************************************************************************/
(0109) void TWI_Start_Transceiver( void )
(0110) {
(0111)   while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
_TWI_Start_Transceiver:
    0192D DFCA      RCALL	_TWI_Transceiver_Busy
    0192E 2300      TST	R16
    0192F F7E9      BNE	0x192D
(0112)   TWI_statusReg =FALSE;      
    01930 2422      CLR	R2
    01931 9220 0422 STS	TWI_statusReg,R2
(0113)   TWI_state         = TWI_NO_STATE ;
    01933 EF88      LDI	R24,0xF8
    01934 9380 0421 STS	TWI_Master.c:TWI_state,R24
(0114)   TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    01936 EA85      LDI	R24,0xA5
    01937 9380 0074 STS	0x74,R24
    01939 9508      RET
_TWI_Get_Data_From_Transceiver:
  i                    --> R10
  msgSize              --> R12
  msg                  --> R14
    0193A 940E 1ACB CALL	push_xgset00FC
    0193C 2EC2      MOV	R12,R18
    0193D 0178      MOVW	R14,R16
(0115)          (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
(0116)          (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
(0117)          (0<<TWWC);                             //
(0118) }
(0119) 
(0120) /****************************************************************************
(0121) Call this function to read out the requested data from the TWI transceiver buffer. I.e. first call
(0122) TWI_Start_Transceiver to send a request for data to the slave. Then Run this function to collect the
(0123) data when they have arrived. Include a pointer to where to place the data and the number of bytes
(0124) requested (including the address field) in the function call. The function will hold execution (loop)
(0125) until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
(0126) If there was an error in the previous transmission the function will return the TWI error code.
(0127) ****************************************************************************/
(0128) unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
(0129) {
(0130)   unsigned char i;
(0131) 
(0132)   while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    0193E DFB9      RCALL	_TWI_Transceiver_Busy
    0193F 2300      TST	R16
    01940 F7E9      BNE	0x193E
(0133) 
(0134)   if( TWI_statusReg )               // Last transmission competed successfully.              
    01941 9020 0422 LDS	R2,TWI_statusReg
    01943 2022      TST	R2
    01944 F089      BEQ	0x1956
(0135)   {                                             
(0136)     for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    01945 24AA      CLR	R10
    01946 C00D      RJMP	0x1954
(0137)     {
(0138)       msg[ i ] = TWI_buf[ i ];
    01947 E380      LDI	R24,0x30
    01948 E094      LDI	R25,4
    01949 2DEA      MOV	R30,R10
    0194A 27FF      CLR	R31
    0194B 0FE8      ADD	R30,R24
    0194C 1FF9      ADC	R31,R25
    0194D 8020      LD	R2,Z
    0194E 2DEA      MOV	R30,R10
    0194F 27FF      CLR	R31
    01950 0DEE      ADD	R30,R14
    01951 1DFF      ADC	R31,R15
    01952 8220      ST	Z,R2
    01953 94A3      INC	R10
    01954 14AC      CP	R10,R12
    01955 F388      BCS	0x1947
(0139)     }
(0140)   }
(0141)   return( TWI_statusReg );                                   
    01956 9100 0422 LDS	R16,TWI_statusReg
    01958 940C 1AB5 JMP	pop_xgset00FC
_twi_isr:
    0195A 922A      ST	-Y,R2
    0195B 923A      ST	-Y,R3
    0195C 930A      ST	-Y,R16
    0195D 931A      ST	-Y,R17
    0195E 938A      ST	-Y,R24
    0195F 939A      ST	-Y,R25
    01960 93AA      ST	-Y,R26
    01961 93EA      ST	-Y,R30
    01962 93FA      ST	-Y,R31
    01963 B62F      IN	R2,0x3F
    01964 922A      ST	-Y,R2
(0142) }
(0143) 
(0144) // ********** Interrupt Handlers ********** //
(0145) /****************************************************************************
(0146) This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
(0147) that is whenever a TWI event has occurred. This function should not be called directly from the main
(0148) application.
(0149) ****************************************************************************/
(0150) #pragma interrupt_handler twi_isr:34
(0151) void twi_isr(void)
(0152) {
(0153)   static unsigned char TWI_bufPtr;
(0154)   
(0155)   switch (TWSR)
    01965 9100 0071 LDS	R16,0x71
    01967 2711      CLR	R17
    01968 3208      CPI	R16,0x28
    01969 E0E0      LDI	R30,0
    0196A 071E      CPC	R17,R30
    0196B F409      BNE	0x196D
    0196C C061      RJMP	0x19CE
    0196D E288      LDI	R24,0x28
    0196E E090      LDI	R25,0
    0196F 1780      CP	R24,R16
    01970 0791      CPC	R25,R17
    01971 F14C      BLT	0x199B
    01972 3100      CPI	R16,0x10
    01973 E0E0      LDI	R30,0
    01974 071E      CPC	R17,R30
    01975 F409      BNE	0x1977
    01976 C054      RJMP	0x19CB
    01977 E180      LDI	R24,0x10
    01978 E090      LDI	R25,0
    01979 1780      CP	R24,R16
    0197A 0791      CPC	R25,R17
    0197B F07C      BLT	0x198B
    0197C 3000      CPI	R16,0
    0197D 0701      CPC	R16,R17
    0197E F409      BNE	0x1980
    0197F C0A2      RJMP	0x1A22
    01980 3000      CPI	R16,0
    01981 E0E0      LDI	R30,0
    01982 071E      CPC	R17,R30
    01983 F40C      BGE	0x1985
    01984 C09D      RJMP	0x1A22
    01985 3008      CPI	R16,0x8
    01986 E0E0      LDI	R30,0
    01987 071E      CPC	R17,R30
    01988 F409      BNE	0x198A
    01989 C041      RJMP	0x19CB
    0198A C097      RJMP	0x1A22
    0198B 3108      CPI	R16,0x18
    0198C E0E0      LDI	R30,0
    0198D 071E      CPC	R17,R30
    0198E F409      BNE	0x1990
    0198F C03E      RJMP	0x19CE
    01990 3108      CPI	R16,0x18
    01991 E0E0      LDI	R30,0
    01992 071E      CPC	R17,R30
    01993 F40C      BGE	0x1995
    01994 C08D      RJMP	0x1A22
    01995 3200      CPI	R16,0x20
    01996 E0E0      LDI	R30,0
    01997 071E      CPC	R17,R30
    01998 F409      BNE	0x199A
    01999 C088      RJMP	0x1A22
    0199A C087      RJMP	0x1A22
    0199B 3400      CPI	R16,0x40
    0199C E0E0      LDI	R30,0
    0199D 071E      CPC	R17,R30
    0199E F409      BNE	0x19A0
    0199F C05E      RJMP	0x19FE
    019A0 E480      LDI	R24,0x40
    019A1 E090      LDI	R25,0
    019A2 1780      CP	R24,R16
    019A3 0791      CPC	R25,R17
    019A4 F084      BLT	0x19B5
    019A5 3300      CPI	R16,0x30
    019A6 E0E0      LDI	R30,0
    019A7 071E      CPC	R17,R30
    019A8 F409      BNE	0x19AA
    019A9 C078      RJMP	0x1A22
    019AA 3300      CPI	R16,0x30
    019AB E0E0      LDI	R30,0
    019AC 071E      CPC	R17,R30
    019AD F40C      BGE	0x19AF
    019AE C073      RJMP	0x1A22
    019AF 3308      CPI	R16,0x38
    019B0 E0E0      LDI	R30,0
    019B1 071E      CPC	R17,R30
    019B2 F409      BNE	0x19B4
    019B3 C06A      RJMP	0x1A1E
    019B4 C06D      RJMP	0x1A22
    019B5 3500      CPI	R16,0x50
    019B6 E0E0      LDI	R30,0
    019B7 071E      CPC	R17,R30
    019B8 F409      BNE	0x19BA
    019B9 C034      RJMP	0x19EE
    019BA E580      LDI	R24,0x50
    019BB E090      LDI	R25,0
    019BC 1780      CP	R24,R16
    019BD 0791      CPC	R25,R17
    019BE F034      BLT	0x19C5
    019BF 3408      CPI	R16,0x48
    019C0 E0E0      LDI	R30,0
    019C1 071E      CPC	R17,R30
    019C2 F409      BNE	0x19C4
    019C3 C05E      RJMP	0x1A22
    019C4 C05D      RJMP	0x1A22
    019C5 3508      CPI	R16,0x58
    019C6 E0E0      LDI	R30,0
    019C7 071E      CPC	R17,R30
    019C8 F409      BNE	0x19CA
    019C9 C043      RJMP	0x1A0D
    019CA C057      RJMP	0x1A22
(0156)   {
(0157)     case TWI_START:             // START has been transmitted  
(0158)     case TWI_REP_START:         // Repeated START has been transmitted
(0159)       TWI_bufPtr = 0;           // Set buffer pointer to the TWI Address location
    019CB 2422      CLR	R2
    019CC 9220 042E STS	TWI_Master.c:TWI_bufPtr,R2
(0160)     case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
(0161)     case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
(0162)       if (TWI_bufPtr < TWI_msgSize)
    019CE 9020 042F LDS	R2,TWI_Master.c:TWI_msgSize
    019D0 9030 042E LDS	R3,TWI_Master.c:TWI_bufPtr
    019D2 1432      CP	R3,R2
    019D3 F498      BCC	0x19E7
(0163)       {
(0164) 	  /////////////////////////////////////////////延时~~
(0165) 	 // t_delay_nms(100);
(0166) 	  //////////////////////////////////////////////延时~~~
(0167)         TWDR = TWI_buf[TWI_bufPtr++];
    019D4 2C23      MOV	R2,R3
    019D5 2433      CLR	R3
    019D6 2D82      MOV	R24,R2
    019D7 5F8F      SUBI	R24,0xFF
    019D8 9380 042E STS	TWI_Master.c:TWI_bufPtr,R24
    019DA E380      LDI	R24,0x30
    019DB E094      LDI	R25,4
    019DC 2DE2      MOV	R30,R2
    019DD 27FF      CLR	R31
    019DE 0FE8      ADD	R30,R24
    019DF 1FF9      ADC	R31,R25
    019E0 8020      LD	R2,Z
    019E1 9220 0073 STS	0x73,R2
(0168)         TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    019E3 E885      LDI	R24,0x85
    019E4 9380 0074 STS	0x74,R24
(0169)                (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
(0170)                (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
(0171)                (0<<TWWC);                                 //  
(0172)       }else                    // Send STOP after last byte
    019E6 C042      RJMP	0x1A29
(0173)       {
(0174)         TWI_statusReg = TRUE;                 // Set status bits to completed successfully. 
    019E7 E081      LDI	R24,1
    019E8 9380 0422 STS	TWI_statusReg,R24
(0175)         TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    019EA E984      LDI	R24,0x94
    019EB 9380 0074 STS	0x74,R24
(0176)                (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
(0177)                (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
(0178)                (0<<TWWC);                                 //
(0179)       }
(0180)       break;
    019ED C03B      RJMP	0x1A29
(0181)     case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
(0182)       TWI_buf[TWI_bufPtr++] = TWDR;
    019EE 9020 042E LDS	R2,TWI_Master.c:TWI_bufPtr
    019F0 2433      CLR	R3
    019F1 2D82      MOV	R24,R2
    019F2 5F8F      SUBI	R24,0xFF
    019F3 9380 042E STS	TWI_Master.c:TWI_bufPtr,R24
    019F5 E380      LDI	R24,0x30
    019F6 E094      LDI	R25,4
    019F7 2DE2      MOV	R30,R2
    019F8 27FF      CLR	R31
    019F9 0FE8      ADD	R30,R24
    019FA 1FF9      ADC	R31,R25
    019FB 9020 0073 LDS	R2,0x73
    019FD 8220      ST	Z,R2
(0183)     case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
(0184)       if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    019FE 9180 042F LDS	R24,TWI_Master.c:TWI_msgSize
    01A00 5081      SUBI	R24,1
    01A01 9020 042E LDS	R2,TWI_Master.c:TWI_bufPtr
    01A03 1628      CP	R2,R24
    01A04 F420      BCC	0x1A09
(0185)       {
(0186)         TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    01A05 EC85      LDI	R24,0xC5
    01A06 9380 0074 STS	0x74,R24
(0187)                (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
(0188)                (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
(0189)                (0<<TWWC);                                 //  
(0190)       }else                    // Send NACK after next reception
    01A08 C020      RJMP	0x1A29
(0191)       {
(0192)         TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    01A09 E885      LDI	R24,0x85
    01A0A 9380 0074 STS	0x74,R24
(0193)                (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
(0194)                (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
(0195)                (0<<TWWC);                                 // 
(0196)       }    
(0197)       break; 
    01A0C C01C      RJMP	0x1A29
(0198)     case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
(0199)       TWI_buf[TWI_bufPtr] = TWDR;
    01A0D E380      LDI	R24,0x30
    01A0E E094      LDI	R25,4
    01A0F 91E0 042E LDS	R30,TWI_Master.c:TWI_bufPtr
    01A11 27FF      CLR	R31
    01A12 0FE8      ADD	R30,R24
    01A13 1FF9      ADC	R31,R25
    01A14 9020 0073 LDS	R2,0x73
    01A16 8220      ST	Z,R2
(0200)       TWI_statusReg = TRUE;                 // Set status bits to completed successfully. 
    01A17 E081      LDI	R24,1
    01A18 9380 0422 STS	TWI_statusReg,R24
(0201)       TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    01A1A E984      LDI	R24,0x94
    01A1B 9380 0074 STS	0x74,R24
(0202)              (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
(0203)              (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
(0204)              (0<<TWWC);                                 //
(0205)       break;      
    01A1D C00B      RJMP	0x1A29
(0206)     case TWI_ARB_LOST:          // Arbitration lost
(0207)       TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    01A1E EA85      LDI	R24,0xA5
    01A1F 9380 0074 STS	0x74,R24
(0208)              (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
(0209)              (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
(0210)              (0<<TWWC);                                 //
(0211)       break;
    01A21 C007      RJMP	0x1A29
(0212)     case TWI_MTX_ADR_NACK:      // SLA+W has been tramsmitted and NACK received
(0213)     case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
(0214)     case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
(0215)           // No relevant state information available; TWINT = ??
(0216)     case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
(0217)     default:     
(0218)       TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    01A22 9020 0071 LDS	R2,0x71
    01A24 9220 0421 STS	TWI_Master.c:TWI_state,R2
(0219)                                                         // Reset TWI Interface
(0220)       TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    01A26 E084      LDI	R24,4
    01A27 9380 0074 STS	0x74,R24
(0221)              (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
(0222)              (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
(0223)              (0<<TWWC);                                 //
(0224)   }
FILE: <library>
    01A29 9029      LD	R2,Y+
    01A2A BE2F      OUT	0x3F,R2
    01A2B 91F9      LD	R31,Y+
    01A2C 91E9      LD	R30,Y+
    01A2D 91A9      LD	R26,Y+
    01A2E 9199      LD	R25,Y+
    01A2F 9189      LD	R24,Y+
    01A30 9119      LD	R17,Y+
    01A31 9109      LD	R16,Y+
    01A32 9039      LD	R3,Y+
    01A33 9029      LD	R2,Y+
    01A34 9518      RETI
push_arg4:
    01A35 933A      ST	-Y,R19
    01A36 932A      ST	-Y,R18
push_arg2:
    01A37 931A      ST	-Y,R17
    01A38 930A      ST	-Y,R16
    01A39 9508      RET
mod16s:
    01A3A 9468      BSET	6
    01A3B 92DA      ST	-Y,R13
    01A3C 2ED1      MOV	R13,R17
    01A3D C004      RJMP	0x1A42
div16s:
    01A3E 94E8      BCLR	6
    01A3F 92DA      ST	-Y,R13
    01A40 2ED1      MOV	R13,R17
    01A41 26D3      EOR	R13,R19
    01A42 FF17      SBRS	R17,7
    01A43 C004      RJMP	0x1A48
    01A44 9510      COM	R17
    01A45 9500      COM	R16
    01A46 5F0F      SUBI	R16,0xFF
    01A47 4F1F      SBCI	R17,0xFF
    01A48 FF37      SBRS	R19,7
    01A49 C004      RJMP	0x1A4E
    01A4A 9530      COM	R19
    01A4B 9520      COM	R18
    01A4C 5F2F      SUBI	R18,0xFF
    01A4D 4F3F      SBCI	R19,0xFF
    01A4E 940E 1A5B CALL	xdiv16u
    01A50 FED7      SBRS	R13,7
    01A51 C004      RJMP	0x1A56
    01A52 9510      COM	R17
    01A53 9500      COM	R16
    01A54 5F0F      SUBI	R16,0xFF
    01A55 4F1F      SBCI	R17,0xFF
    01A56 90D9      LD	R13,Y+
    01A57 9508      RET
mod16u:
    01A58 9468      BSET	6
    01A59 C001      RJMP	xdiv16u
div16u:
    01A5A 94E8      BCLR	6
xdiv16u:
    01A5B 92EA      ST	-Y,R14
    01A5C 92FA      ST	-Y,R15
    01A5D 938A      ST	-Y,R24
    01A5E 24EE      CLR	R14
    01A5F 24FF      CLR	R15
    01A60 E180      LDI	R24,0x10
    01A61 0F00      LSL	R16
    01A62 1F11      ROL	R17
    01A63 1CEE      ROL	R14
    01A64 1CFF      ROL	R15
    01A65 16E2      CP	R14,R18
    01A66 06F3      CPC	R15,R19
    01A67 F018      BCS	0x1A6B
    01A68 1AE2      SUB	R14,R18
    01A69 0AF3      SBC	R15,R19
    01A6A 9503      INC	R16
    01A6B 958A      DEC	R24
    01A6C F7A1      BNE	0x1A61
    01A6D F416      BRTC	0x1A70
    01A6E 2D0E      MOV	R16,R14
    01A6F 2D1F      MOV	R17,R15
    01A70 9189      LD	R24,Y+
    01A71 90F9      LD	R15,Y+
    01A72 90E9      LD	R14,Y+
    01A73 9508      RET
mod8u:
    01A74 9468      BSET	6
    01A75 C001      RJMP	xdiv8u
div8u:
    01A76 94E8      BCLR	6
xdiv8u:
    01A77 932A      ST	-Y,R18
    01A78 92FA      ST	-Y,R15
    01A79 92EA      ST	-Y,R14
    01A7A 24FF      CLR	R15
    01A7B 24EE      CLR	R14
    01A7C E120      LDI	R18,0x10
    01A7D 0F00      LSL	R16
    01A7E 1CFF      ROL	R15
    01A7F 1CEE      ROL	R14
    01A80 16E1      CP	R14,R17
    01A81 F010      BCS	0x1A84
    01A82 1AE1      SUB	R14,R17
    01A83 9503      INC	R16
    01A84 952A      DEC	R18
    01A85 F7B9      BNE	0x1A7D
    01A86 F40E      BRTC	0x1A88
    01A87 2D0E      MOV	R16,R14
    01A88 90E9      LD	R14,Y+
    01A89 90F9      LD	R15,Y+
    01A8A 9129      LD	R18,Y+
    01A8B 9508      RET
elpm32:
    01A8C 93EA      ST	-Y,R30
    01A8D 93FA      ST	-Y,R31
    01A8E 920A      ST	-Y,R0
    01A8F 2FE0      MOV	R30,R16
    01A90 2FF1      MOV	R31,R17
    01A91 95D8      ELPM
    01A92 2D00      MOV	R16,R0
    01A93 9631      ADIW	R30,1
    01A94 95D8      ELPM
    01A95 2D10      MOV	R17,R0
    01A96 9631      ADIW	R30,1
    01A97 95D8      ELPM
    01A98 2D20      MOV	R18,R0
    01A99 9631      ADIW	R30,1
    01A9A 95D8      ELPM
    01A9B 2D30      MOV	R19,R0
    01A9C 9009      LD	R0,Y+
    01A9D 91F9      LD	R31,Y+
    01A9E 91E9      LD	R30,Y+
    01A9F 9508      RET
empy16s:
    01AA0 920A      ST	-Y,R0
    01AA1 921A      ST	-Y,R1
    01AA2 938A      ST	-Y,R24
    01AA3 939A      ST	-Y,R25
    01AA4 9F02      MUL	R16,R18
    01AA5 01C0      MOVW	R24,R0
    01AA6 9F12      MUL	R17,R18
    01AA7 0D90      ADD	R25,R0
    01AA8 9F03      MUL	R16,R19
    01AA9 0D90      ADD	R25,R0
    01AAA 018C      MOVW	R16,R24
    01AAB 9199      LD	R25,Y+
    01AAC 9189      LD	R24,Y+
    01AAD 9019      LD	R1,Y+
    01AAE 9009      LD	R0,Y+
    01AAF 9508      RET
pop_xgset003C:
    01AB0 90A9      LD	R10,Y+
    01AB1 90B9      LD	R11,Y+
    01AB2 90C9      LD	R12,Y+
    01AB3 90D9      LD	R13,Y+
    01AB4 9508      RET
pop_xgset00FC:
    01AB5 90A9      LD	R10,Y+
    01AB6 90B9      LD	R11,Y+
    01AB7 90C9      LD	R12,Y+
    01AB8 90D9      LD	R13,Y+
    01AB9 90E9      LD	R14,Y+
    01ABA 90F9      LD	R15,Y+
    01ABB 9508      RET
pop_xgsetF0FC:
    01ABC 90A9      LD	R10,Y+
    01ABD 90B9      LD	R11,Y+
    01ABE 90C9      LD	R12,Y+
    01ABF 90D9      LD	R13,Y+
    01AC0 90E9      LD	R14,Y+
    01AC1 90F9      LD	R15,Y+
    01AC2 9149      LD	R20,Y+
    01AC3 9159      LD	R21,Y+
    01AC4 9169      LD	R22,Y+
    01AC5 9179      LD	R23,Y+
    01AC6 9508      RET
push_xgsetF0FC:
    01AC7 937A      ST	-Y,R23
    01AC8 936A      ST	-Y,R22
push_xgset30FC:
    01AC9 935A      ST	-Y,R21
    01ACA 934A      ST	-Y,R20
push_xgset00FC:
    01ACB 92FA      ST	-Y,R15
    01ACC 92EA      ST	-Y,R14
push_xgset003C:
    01ACD 92DA      ST	-Y,R13
    01ACE 92CA      ST	-Y,R12
    01ACF 92BA      ST	-Y,R11
    01AD0 92AA      ST	-Y,R10
    01AD1 9508      RET
push_xgset300C:
    01AD2 935A      ST	-Y,R21
    01AD3 934A      ST	-Y,R20
    01AD4 92BA      ST	-Y,R11
    01AD5 92AA      ST	-Y,R10
    01AD6 9508      RET
pop_xgset300C:
    01AD7 90A9      LD	R10,Y+
    01AD8 90B9      LD	R11,Y+
    01AD9 9149      LD	R20,Y+
    01ADA 9159      LD	R21,Y+
    01ADB 9508      RET
push_xgset303C:
    01ADC 935A      ST	-Y,R21
    01ADD 934A      ST	-Y,R20
    01ADE 92DA      ST	-Y,R13
    01ADF 92CA      ST	-Y,R12
    01AE0 92BA      ST	-Y,R11
    01AE1 92AA      ST	-Y,R10
    01AE2 9508      RET
pop_xgset303C:
    01AE3 90A9      LD	R10,Y+
    01AE4 90B9      LD	R11,Y+
    01AE5 90C9      LD	R12,Y+
    01AE6 90D9      LD	R13,Y+
    01AE7 9149      LD	R20,Y+
    01AE8 9159      LD	R21,Y+
    01AE9 9508      RET
push_xgsetF03C:
    01AEA 937A      ST	-Y,R23
    01AEB 936A      ST	-Y,R22
    01AEC 935A      ST	-Y,R21
    01AED 934A      ST	-Y,R20
    01AEE 92DA      ST	-Y,R13
    01AEF 92CA      ST	-Y,R12
    01AF0 92BA      ST	-Y,R11
    01AF1 92AA      ST	-Y,R10
    01AF2 9508      RET
pop_xgsetF03C:
    01AF3 90A9      LD	R10,Y+
    01AF4 90B9      LD	R11,Y+
    01AF5 90C9      LD	R12,Y+
    01AF6 90D9      LD	R13,Y+
    01AF7 9149      LD	R20,Y+
    01AF8 9159      LD	R21,Y+
    01AF9 9169      LD	R22,Y+
    01AFA 9179      LD	R23,Y+
    01AFB 9508      RET
neg32:
    01AFC 9500      COM	R16
    01AFD 9510      COM	R17
    01AFE 9520      COM	R18
    01AFF 9530      COM	R19
    01B00 5F0F      SUBI	R16,0xFF
    01B01 4F1F      SBCI	R17,0xFF
    01B02 4F2F      SBCI	R18,0xFF
    01B03 4F3F      SBCI	R19,0xFF
    01B04 9508      RET
fpsub:
    01B05 9468      BSET	6
    01B06 C001      RJMP	fpadd_alt
fpadd:
    01B07 94E8      BCLR	6
fpadd_alt:
    01B08 940E 1CED CALL	saveFPRegs
    01B0A 940E 1C7F CALL	unpacks
    01B0C F409      BNE	0x1B0E
    01B0D C048      RJMP	0x1B56
    01B0E 2CE6      MOV	R14,R6
    01B0F 2CD5      MOV	R13,R5
    01B10 2CC4      MOV	R12,R4
    01B11 2EB3      MOV	R11,R19
    01B12 2EA2      MOV	R10,R18
    01B13 2E91      MOV	R9,R17
    01B14 2E80      MOV	R8,R16
    01B15 8100      LD	R16,Z
    01B16 8111      LDD	R17,Z+1
    01B17 8122      LDD	R18,Z+2
    01B18 8133      LDD	R19,Z+3
    01B19 940E 1C7F CALL	unpacks
    01B1B F409      BNE	0x1B1D
    01B1C C044      RJMP	0x1B61
    01B1D 2D84      MOV	R24,R4
    01B1E 2D95      MOV	R25,R5
    01B1F 198C      SUB	R24,R12
    01B20 099D      SBC	R25,R13
    01B21 F0B9      BEQ	0x1B39
    01B22 F472      BPL	0x1B31
    01B23 9590      COM	R25
    01B24 9580      COM	R24
    01B25 9601      ADIW	R24,1
    01B26 2C4C      MOV	R4,R12
    01B27 2C5D      MOV	R5,R13
    01B28 3188      CPI	R24,0x18
    01B29 F5B8      BCC	0x1B61
    01B2A 9535      ASR	R19
    01B2B 9527      ROR	R18
    01B2C 9517      ROR	R17
    01B2D 9507      ROR	R16
    01B2E 9701      SBIW	R24,1
    01B2F F7D1      BNE	0x1B2A
    01B30 C008      RJMP	0x1B39
    01B31 3188      CPI	R24,0x18
    01B32 F518      BCC	0x1B56
    01B33 94B5      ASR	R11
    01B34 94A7      ROR	R10
    01B35 9497      ROR	R9
    01B36 9487      ROR	R8
    01B37 9701      SBIW	R24,1
    01B38 F7D1      BNE	0x1B33
    01B39 2466      CLR	R6
    01B3A F02E      BRTS	0x1B40
    01B3B 0D08      ADD	R16,R8
    01B3C 1D19      ADC	R17,R9
    01B3D 1D2A      ADC	R18,R10
    01B3E 1D3B      ADC	R19,R11
    01B3F C009      RJMP	0x1B49
    01B40 1A80      SUB	R8,R16
    01B41 0A91      SBC	R9,R17
    01B42 0AA2      SBC	R10,R18
    01B43 0AB3      SBC	R11,R19
    01B44 2D08      MOV	R16,R8
    01B45 2D19      MOV	R17,R9
    01B46 2D2A      MOV	R18,R10
    01B47 2D3B      MOV	R19,R11
    01B48 2333      TST	R19
    01B49 F422      BPL	0x1B4E
    01B4A 940E 1AFC CALL	neg32
    01B4C E880      LDI	R24,0x80
    01B4D 2E68      MOV	R6,R24
    01B4E 940E 1CA8 CALL	normalize_and_pack
    01B50 C002      RJMP	0x1B53
    01B51 940E 1CDD CALL	pack
    01B53 940E 1CFC CALL	restoreFPRegs
    01B55 9508      RET
    01B56 8100      LD	R16,Z
    01B57 8111      LDD	R17,Z+1
    01B58 8122      LDD	R18,Z+2
    01B59 8133      LDD	R19,Z+3
    01B5A F7C6      BRTC	0x1B53
    01B5B 940E 1C87 CALL	tstR16_R19
    01B5D F3A9      BEQ	0x1B53
    01B5E E880      LDI	R24,0x80
    01B5F 2738      EOR	R19,R24
    01B60 CFF2      RJMP	0x1B53
    01B61 2D08      MOV	R16,R8
    01B62 2D19      MOV	R17,R9
    01B63 2D2A      MOV	R18,R10
    01B64 2D3B      MOV	R19,R11
    01B65 2C4C      MOV	R4,R12
    01B66 2C5D      MOV	R5,R13
    01B67 2C6E      MOV	R6,R14
    01B68 2333      TST	R19
    01B69 F73A      BPL	0x1B51
    01B6A 940E 1AFC CALL	neg32
    01B6C E880      LDI	R24,0x80
    01B6D 2E68      MOV	R6,R24
    01B6E CFE2      RJMP	0x1B51
fpadd2:
    01B6F 93FA      ST	-Y,R31
    01B70 93EA      ST	-Y,R30
    01B71 2FEC      MOV	R30,R28
    01B72 2FFD      MOV	R31,R29
    01B73 9632      ADIW	R30,2
    01B74 940E 1B07 CALL	fpadd
    01B76 91E9      LD	R30,Y+
    01B77 91F9      LD	R31,Y+
    01B78 9624      ADIW	R28,4
    01B79 9508      RET
fpsub1:
    01B7A 93FA      ST	-Y,R31
    01B7B 93EA      ST	-Y,R30
    01B7C 81EA      LDD	R30,Y+2
    01B7D 81FB      LDD	R31,Y+3
    01B7E 940E 1B05 CALL	fpsub
    01B80 91E9      LD	R30,Y+
    01B81 91F9      LD	R31,Y+
    01B82 9622      ADIW	R28,2
    01B83 9508      RET
fpsub2:
    01B84 93FA      ST	-Y,R31
    01B85 93EA      ST	-Y,R30
    01B86 2FEC      MOV	R30,R28
    01B87 2FFD      MOV	R31,R29
    01B88 9632      ADIW	R30,2
    01B89 940E 1B05 CALL	fpsub
    01B8B 91E9      LD	R30,Y+
    01B8C 91F9      LD	R31,Y+
    01B8D 9624      ADIW	R28,4
    01B8E 9508      RET
fpint:
    01B8F 924A      ST	-Y,R4
    01B90 925A      ST	-Y,R5
    01B91 926A      ST	-Y,R6
    01B92 938A      ST	-Y,R24
    01B93 940E 1C8F CALL	unpacku
    01B95 F111      BEQ	0x1BB8
    01B96 2055      TST	R5
    01B97 F0E2      BMI	0x1BB4
    01B98 E18F      LDI	R24,0x1F
    01B99 1648      CP	R4,R24
    01B9A F4C0      BCC	0x1BB3
    01B9B E187      LDI	R24,0x17
    01B9C 1648      CP	R4,R24
    01B9D F0D1      BEQ	0x1BB8
    01B9E F458      BCC	0x1BAA
    01B9F 9441      NEG	R4
    01BA0 EE89      LDI	R24,0xE9
    01BA1 1A48      SUB	R4,R24
    01BA2 C005      RJMP	0x1BA8
    01BA3 9535      ASR	R19
    01BA4 9527      ROR	R18
    01BA5 9517      ROR	R17
    01BA6 9507      ROR	R16
    01BA7 944A      DEC	R4
    01BA8 F7D1      BNE	0x1BA3
    01BA9 C00E      RJMP	0x1BB8
    01BAA E187      LDI	R24,0x17
    01BAB 1A48      SUB	R4,R24
    01BAC 0F00      LSL	R16
    01BAD 1F11      ROL	R17
    01BAE 1F22      ROL	R18
    01BAF 1F33      ROL	R19
    01BB0 944A      DEC	R4
    01BB1 F7D1      BNE	0x1BAC
    01BB2 C005      RJMP	0x1BB8
    01BB3 E73F      LDI	R19,0x7F
    01BB4 2F23      MOV	R18,R19
    01BB5 2F13      MOV	R17,R19
    01BB6 2F03      MOV	R16,R19
    01BB7 C004      RJMP	0x1BBC
    01BB8 2066      TST	R6
    01BB9 F011      BEQ	0x1BBC
    01BBA 940E 1AFC CALL	neg32
    01BBC 9189      LD	R24,Y+
    01BBD 9069      LD	R6,Y+
    01BBE 9059      LD	R5,Y+
    01BBF 9049      LD	R4,Y+
    01BC0 9508      RET
uint2fp:
    01BC1 9468      BSET	6
    01BC2 C001      RJMP	0x1BC4
int2fp:
    01BC3 94E8      BCLR	6
    01BC4 2722      CLR	R18
    01BC5 2733      CLR	R19
    01BC6 F046      BRTS	0x1BCF
    01BC7 FD17      SBRC	R17,7
    01BC8 9520      COM	R18
    01BC9 FD17      SBRC	R17,7
    01BCA 9530      COM	R19
    01BCB C003      RJMP	0x1BCF
ulong2fp:
    01BCC 9468      BSET	6
    01BCD C001      RJMP	0x1BCF
long2fp:
    01BCE 94E8      BCLR	6
    01BCF 924A      ST	-Y,R4
    01BD0 925A      ST	-Y,R5
    01BD1 926A      ST	-Y,R6
    01BD2 938A      ST	-Y,R24
    01BD3 E187      LDI	R24,0x17
    01BD4 2E48      MOV	R4,R24
    01BD5 2455      CLR	R5
    01BD6 2466      CLR	R6
    01BD7 F036      BRTS	0x1BDE
    01BD8 2333      TST	R19
    01BD9 F422      BPL	0x1BDE
    01BDA 940E 1AFC CALL	neg32
    01BDC E880      LDI	R24,0x80
    01BDD 2E68      MOV	R6,R24
    01BDE 940E 1CA8 CALL	normalize_and_pack
    01BE0 9189      LD	R24,Y+
    01BE1 9069      LD	R6,Y+
    01BE2 9059      LD	R5,Y+
    01BE3 9049      LD	R4,Y+
    01BE4 9508      RET
fpdiv1:
    01BE5 93FA      ST	-Y,R31
    01BE6 93EA      ST	-Y,R30
    01BE7 81EA      LDD	R30,Y+2
    01BE8 81FB      LDD	R31,Y+3
    01BE9 D027      RCALL	0x1C11
    01BEA 91E9      LD	R30,Y+
    01BEB 91F9      LD	R31,Y+
    01BEC 9622      ADIW	R28,2
    01BED 9508      RET
fpdiv2:
    01BEE 93FA      ST	-Y,R31
    01BEF 93EA      ST	-Y,R30
    01BF0 2FEC      MOV	R30,R28
    01BF1 2FFD      MOV	R31,R29
    01BF2 9632      ADIW	R30,2
    01BF3 D01D      RCALL	0x1C11
    01BF4 91E9      LD	R30,Y+
    01BF5 91F9      LD	R31,Y+
    01BF6 9624      ADIW	R28,4
    01BF7 9508      RET
fpdiv1x:
    01BF8 93FA      ST	-Y,R31
    01BF9 93EA      ST	-Y,R30
    01BFA 81EA      LDD	R30,Y+2
    01BFB 81FB      LDD	R31,Y+3
    01BFC D014      RCALL	0x1C11
    01BFD 91E9      LD	R30,Y+
    01BFE 91F9      LD	R31,Y+
    01BFF 8339      STD	Y+1,R19
    01C00 8328      ST	Y,R18
    01C01 931A      ST	-Y,R17
    01C02 930A      ST	-Y,R16
    01C03 9508      RET
fpdiv2x:
    01C04 93FA      ST	-Y,R31
    01C05 93EA      ST	-Y,R30
    01C06 2FEC      MOV	R30,R28
    01C07 2FFD      MOV	R31,R29
    01C08 9632      ADIW	R30,2
    01C09 D007      RCALL	0x1C11
    01C0A 91E9      LD	R30,Y+
    01C0B 91F9      LD	R31,Y+
    01C0C 833B      STD	Y+3,R19
    01C0D 832A      STD	Y+2,R18
    01C0E 8319      STD	Y+1,R17
    01C0F 8308      ST	Y,R16
    01C10 9508      RET
    01C11 920A      ST	-Y,R0
    01C12 921A      ST	-Y,R1
    01C13 922A      ST	-Y,R2
    01C14 923A      ST	-Y,R3
    01C15 940E 1CED CALL	saveFPRegs
    01C17 933A      ST	-Y,R19
    01C18 932A      ST	-Y,R18
    01C19 931A      ST	-Y,R17
    01C1A 930A      ST	-Y,R16
    01C1B 8100      LD	R16,Z
    01C1C 8111      LDD	R17,Z+1
    01C1D 8122      LDD	R18,Z+2
    01C1E 8133      LDD	R19,Z+3
    01C1F 940E 1C8F CALL	unpacku
    01C21 F409      BNE	0x1C23
    01C22 C057      RJMP	0x1C7A
    01C23 2CE6      MOV	R14,R6
    01C24 2CD5      MOV	R13,R5
    01C25 2CC4      MOV	R12,R4
    01C26 2EB3      MOV	R11,R19
    01C27 2EA2      MOV	R10,R18
    01C28 2E91      MOV	R9,R17
    01C29 2E80      MOV	R8,R16
    01C2A 9109      LD	R16,Y+
    01C2B 9119      LD	R17,Y+
    01C2C 9129      LD	R18,Y+
    01C2D 9139      LD	R19,Y+
    01C2E 940E 1C8F CALL	unpacku
    01C30 F1A1      BEQ	0x1C65
    01C31 246E      EOR	R6,R14
    01C32 184C      SUB	R4,R12
    01C33 085D      SBC	R5,R13
    01C34 E880      LDI	R24,0x80
    01C35 1648      CP	R4,R24
    01C36 0653      CPC	R5,R19
    01C37 F00C      BLT	0x1C39
    01C38 C033      RJMP	0x1C6C
    01C39 E881      LDI	R24,0x81
    01C3A 1648      CP	R4,R24
    01C3B EF8F      LDI	R24,0xFF
    01C3C 0658      CPC	R5,R24
    01C3D F40C      BGE	0x1C3F
    01C3E C036      RJMP	0x1C75
    01C3F E280      LDI	R24,0x20
    01C40 2433      CLR	R3
    01C41 2E23      MOV	R2,R19
    01C42 2E12      MOV	R1,R18
    01C43 2E01      MOV	R0,R17
    01C44 2F30      MOV	R19,R16
    01C45 2722      CLR	R18
    01C46 2711      CLR	R17
    01C47 2700      CLR	R16
    01C48 9426      LSR	R2
    01C49 9417      ROR	R1
    01C4A 9407      ROR	R0
    01C4B 9537      ROR	R19
    01C4C 9527      ROR	R18
    01C4D 0F00      LSL	R16
    01C4E 1F11      ROL	R17
    01C4F 1F22      ROL	R18
    01C50 1F33      ROL	R19
    01C51 1C00      ROL	R0
    01C52 1C11      ROL	R1
    01C53 1C22      ROL	R2
    01C54 1C33      ROL	R3
    01C55 F028      BCS	0x1C5B
    01C56 1808      SUB	R0,R8
    01C57 0819      SBC	R1,R9
    01C58 082A      SBC	R2,R10
    01C59 083B      SBC	R3,R11
    01C5A C004      RJMP	0x1C5F
    01C5B 0C08      ADD	R0,R8
    01C5C 1C19      ADC	R1,R9
    01C5D 1C2A      ADC	R2,R10
    01C5E 1C3B      ADC	R3,R11
    01C5F F00A      BMI	0x1C61
    01C60 6001      ORI	R16,1
    01C61 958A      DEC	R24
    01C62 F751      BNE	0x1C4D
    01C63 940E 1CA8 CALL	normalize_and_pack
    01C65 940E 1CFC CALL	restoreFPRegs
    01C67 9039      LD	R3,Y+
    01C68 9029      LD	R2,Y+
    01C69 9019      LD	R1,Y+
    01C6A 9009      LD	R0,Y+
    01C6B 9508      RET
    01C6C EF0F      LDI	R16,0xFF
    01C6D 2F10      MOV	R17,R16
    01C6E E72F      LDI	R18,0x7F
    01C6F E73F      LDI	R19,0x7F
    01C70 2066      TST	R6
    01C71 F399      BEQ	0x1C65
    01C72 940E 1AFC CALL	neg32
    01C74 CFF0      RJMP	0x1C65
    01C75 2700      CLR	R16
    01C76 2F10      MOV	R17,R16
    01C77 2F20      MOV	R18,R16
    01C78 2F30      MOV	R19,R16
    01C79 CFEB      RJMP	0x1C65
    01C7A 9109      LD	R16,Y+
    01C7B 9119      LD	R17,Y+
    01C7C 9129      LD	R18,Y+
    01C7D 9139      LD	R19,Y+
    01C7E CFED      RJMP	0x1C6C
unpacks:
    01C7F D00F      RCALL	unpacku
    01C80 F029      BEQ	0x1C86
    01C81 2066      TST	R6
    01C82 F011      BEQ	0x1C85
    01C83 940E 1AFC CALL	neg32
    01C85 9498      BCLR	1
    01C86 9508      RET
tstR16_R19:
    01C87 2300      TST	R16
    01C88 F429      BNE	0x1C8E
    01C89 2311      TST	R17
    01C8A F419      BNE	0x1C8E
    01C8B 2322      TST	R18
    01C8C F409      BNE	0x1C8E
    01C8D 2333      TST	R19
    01C8E 9508      RET
unpacku:
    01C8F DFF7      RCALL	tstR16_R19
    01C90 F099      BEQ	0x1CA4
    01C91 938A      ST	-Y,R24
    01C92 2E63      MOV	R6,R19
    01C93 E880      LDI	R24,0x80
    01C94 2268      AND	R6,R24
    01C95 0F22      LSL	R18
    01C96 1F33      ROL	R19
    01C97 2E43      MOV	R4,R19
    01C98 E78F      LDI	R24,0x7F
    01C99 1A48      SUB	R4,R24
    01C9A 2455      CLR	R5
    01C9B 2788      CLR	R24
    01C9C 0A58      SBC	R5,R24
    01C9D 9526      LSR	R18
    01C9E E830      LDI	R19,0x80
    01C9F 2B23      OR	R18,R19
    01CA0 2733      CLR	R19
    01CA1 9189      LD	R24,Y+
    01CA2 9498      BCLR	1
    01CA3 9508      RET
    01CA4 2444      CLR	R4
    01CA5 2455      CLR	R5
    01CA6 2466      CLR	R6
    01CA7 9508      RET
normalize_and_pack:
    01CA8 DFDE      RCALL	tstR16_R19
    01CA9 F409      BNE	0x1CAB
    01CAA 9508      RET
    01CAB 93AA      ST	-Y,R26
    01CAC 93BA      ST	-Y,R27
    01CAD 01D2      MOVW	R26,R4
    01CAE 939A      ST	-Y,R25
    01CAF 938A      ST	-Y,R24
    01CB0 E78E      LDI	R24,0x7E
    01CB1 E090      LDI	R25,0
    01CB2 2333      TST	R19
    01CB3 F049      BEQ	0x1CBD
    01CB4 9536      LSR	R19
    01CB5 9527      ROR	R18
    01CB6 9517      ROR	R17
    01CB7 9507      ROR	R16
    01CB8 17A8      CP	R26,R24
    01CB9 07B9      CPC	R27,R25
    01CBA F4CC      BGE	0x1CD4
    01CBB 9611      ADIW	R26,1
    01CBC CFF5      RJMP	0x1CB2
    01CBD 9580      COM	R24
    01CBE 9590      COM	R25
    01CBF 9601      ADIW	R24,1
    01CC0 2322      TST	R18
    01CC1 F0BA      BMI	0x1CD9
    01CC2 0F00      LSL	R16
    01CC3 1F11      ROL	R17
    01CC4 1F22      ROL	R18
    01CC5 17A8      CP	R26,R24
    01CC6 07B9      CPC	R27,R25
    01CC7 F014      BLT	0x1CCA
    01CC8 9711      SBIW	R26,1
    01CC9 CFF6      RJMP	0x1CC0
    01CCA 2700      CLR	R16
    01CCB 2711      CLR	R17
    01CCC 2722      CLR	R18
    01CCD 2733      CLR	R19
    01CCE 9189      LD	R24,Y+
    01CCF 9199      LD	R25,Y+
    01CD0 012D      MOVW	R4,R26
    01CD1 91B9      LD	R27,Y+
    01CD2 91A9      LD	R26,Y+
    01CD3 9508      RET
    01CD4 2733      CLR	R19
    01CD5 EF0F      LDI	R16,0xFF
    01CD6 2F10      MOV	R17,R16
    01CD7 E72F      LDI	R18,0x7F
    01CD8 2F32      MOV	R19,R18
    01CD9 9189      LD	R24,Y+
    01CDA 9199      LD	R25,Y+
    01CDB 012D      MOVW	R4,R26
    01CDC C002      RJMP	0x1CDF
pack:
    01CDD 93AA      ST	-Y,R26
    01CDE 93BA      ST	-Y,R27
    01CDF DFA7      RCALL	tstR16_R19
    01CE0 F049      BEQ	0x1CEA
    01CE1 01D2      MOVW	R26,R4
    01CE2 58A1      SUBI	R26,0x81
    01CE3 4FBF      SBCI	R27,0xFF
    01CE4 012D      MOVW	R4,R26
    01CE5 2D34      MOV	R19,R4
    01CE6 0F22      LSL	R18
    01CE7 9536      LSR	R19
    01CE8 9527      ROR	R18
    01CE9 2936      OR	R19,R6
    01CEA 91B9      LD	R27,Y+
    01CEB 91A9      LD	R26,Y+
    01CEC 9508      RET
saveFPRegs:
    01CED 924A      ST	-Y,R4
    01CEE 925A      ST	-Y,R5
    01CEF 926A      ST	-Y,R6
    01CF0 927A      ST	-Y,R7
    01CF1 928A      ST	-Y,R8
    01CF2 929A      ST	-Y,R9
    01CF3 92AA      ST	-Y,R10
    01CF4 92BA      ST	-Y,R11
    01CF5 92CA      ST	-Y,R12
    01CF6 92DA      ST	-Y,R13
    01CF7 92EA      ST	-Y,R14
    01CF8 92FA      ST	-Y,R15
    01CF9 938A      ST	-Y,R24
    01CFA 939A      ST	-Y,R25
    01CFB 9508      RET
restoreFPRegs:
    01CFC 9199      LD	R25,Y+
    01CFD 9189      LD	R24,Y+
    01CFE 90F9      LD	R15,Y+
    01CFF 90E9      LD	R14,Y+
    01D00 90D9      LD	R13,Y+
    01D01 90C9      LD	R12,Y+
    01D02 90B9      LD	R11,Y+
    01D03 90A9      LD	R10,Y+
    01D04 9099      LD	R9,Y+
    01D05 9089      LD	R8,Y+
    01D06 9079      LD	R7,Y+
    01D07 9069      LD	R6,Y+
    01D08 9059      LD	R5,Y+
    01D09 9049      LD	R4,Y+
    01D0A 9508      RET
fpmule:
    01D0B 940E 1CED CALL	saveFPRegs
    01D0D 93AA      ST	-Y,R26
    01D0E 93BA      ST	-Y,R27
    01D0F 940E 1C8F CALL	unpacku
    01D11 F1E1      BEQ	0x1D4E
    01D12 2CE6      MOV	R14,R6
    01D13 2CD5      MOV	R13,R5
    01D14 2CC4      MOV	R12,R4
    01D15 2EB3      MOV	R11,R19
    01D16 2EA2      MOV	R10,R18
    01D17 2E91      MOV	R9,R17
    01D18 2E80      MOV	R8,R16
    01D19 8100      LD	R16,Z
    01D1A 8111      LDD	R17,Z+1
    01D1B 8122      LDD	R18,Z+2
    01D1C 8133      LDD	R19,Z+3
    01D1D 940E 1C8F CALL	unpacku
    01D1F F171      BEQ	0x1D4E
    01D20 246E      EOR	R6,R14
    01D21 0C4C      ADD	R4,R12
    01D22 1C5D      ADC	R5,R13
    01D23 E880      LDI	R24,0x80
    01D24 1648      CP	R4,R24
    01D25 0653      CPC	R5,R19
    01D26 F564      BGE	0x1D53
    01D27 E881      LDI	R24,0x81
    01D28 1648      CP	R4,R24
    01D29 EF8F      LDI	R24,0xFF
    01D2A 0658      CPC	R5,R24
    01D2B F16C      BLT	0x1D59
    01D2C 9EA2      MUL	R10,R18
    01D2D 2DB1      MOV	R27,R1
    01D2E 2DA0      MOV	R26,R0
    01D2F 9E91      MUL	R9,R17
    01D30 2D91      MOV	R25,R1
    01D31 2D80      MOV	R24,R0
    01D32 9EA0      MUL	R10,R16
    01D33 0D80      ADD	R24,R0
    01D34 1D91      ADC	R25,R1
    01D35 1FA3      ADC	R26,R19
    01D36 1FB3      ADC	R27,R19
    01D37 9E82      MUL	R8,R18
    01D38 0D80      ADD	R24,R0
    01D39 1D91      ADC	R25,R1
    01D3A 1FA3      ADC	R26,R19
    01D3B 1FB3      ADC	R27,R19
    01D3C 9E92      MUL	R9,R18
    01D3D 0D90      ADD	R25,R0
    01D3E 1DA1      ADC	R26,R1
    01D3F 1FB3      ADC	R27,R19
    01D40 9EA1      MUL	R10,R17
    01D41 0D90      ADD	R25,R0
    01D42 1DA1      ADC	R26,R1
    01D43 1FB3      ADC	R27,R19
    01D44 2F2B      MOV	R18,R27
    01D45 2F1A      MOV	R17,R26
    01D46 2F09      MOV	R16,R25
    01D47 0F88      LSL	R24
    01D48 1F00      ROL	R16
    01D49 1F11      ROL	R17
    01D4A 1F22      ROL	R18
    01D4B 1F33      ROL	R19
    01D4C 940E 1CA8 CALL	normalize_and_pack
    01D4E 91B9      LD	R27,Y+
    01D4F 91A9      LD	R26,Y+
    01D50 940E 1CFC CALL	restoreFPRegs
    01D52 9508      RET
    01D53 EF0F      LDI	R16,0xFF
    01D54 2F10      MOV	R17,R16
    01D55 E72F      LDI	R18,0x7F
    01D56 E78F      LDI	R24,0x7F
    01D57 2E48      MOV	R4,R24
    01D58 CFF5      RJMP	0x1D4E
    01D59 2700      CLR	R16
    01D5A 2F10      MOV	R17,R16
    01D5B 2F20      MOV	R18,R16
    01D5C 2F30      MOV	R19,R16
    01D5D CFF0      RJMP	0x1D4E
fpmule1:
    01D5E 93FA      ST	-Y,R31
    01D5F 93EA      ST	-Y,R30
    01D60 81EA      LDD	R30,Y+2
    01D61 81FB      LDD	R31,Y+3
    01D62 940E 1D0B CALL	fpmule
    01D64 91E9      LD	R30,Y+
    01D65 91F9      LD	R31,Y+
    01D66 9622      ADIW	R28,2
    01D67 9508      RET
fpmule2:
    01D68 93FA      ST	-Y,R31
    01D69 93EA      ST	-Y,R30
    01D6A 2FEC      MOV	R30,R28
    01D6B 2FFD      MOV	R31,R29
    01D6C 9632      ADIW	R30,2
    01D6D 940E 1D0B CALL	fpmule
    01D6F 91E9      LD	R30,Y+
    01D70 91F9      LD	R31,Y+
    01D71 9624      ADIW	R28,4
    01D72 9508      RET
fpmule2x:
    01D73 93FA      ST	-Y,R31
    01D74 93EA      ST	-Y,R30
    01D75 2FEC      MOV	R30,R28
    01D76 2FFD      MOV	R31,R29
    01D77 9632      ADIW	R30,2
    01D78 940E 1D0B CALL	fpmule
    01D7A 91E9      LD	R30,Y+
    01D7B 91F9      LD	R31,Y+
    01D7C 833B      STD	Y+3,R19
    01D7D 832A      STD	Y+2,R18
    01D7E 8319      STD	Y+1,R17
    01D7F 8308      ST	Y,R16
    01D80 9508      RET
fpcmp:
    01D81 940E 1B05 CALL	fpsub
    01D83 2333      TST	R19
    01D84 F03A      BMI	0x1D8C
    01D85 940E 1C87 CALL	tstR16_R19
    01D87 F011      BEQ	0x1D8A
    01D88 E001      LDI	R16,1
    01D89 9508      RET
    01D8A 2700      CLR	R16
    01D8B 9508      RET
    01D8C EF0F      LDI	R16,0xFF
    01D8D 9508      RET
fpcmp1:
    01D8E 93FA      ST	-Y,R31
    01D8F 93EA      ST	-Y,R30
    01D90 81EA      LDD	R30,Y+2
    01D91 81FB      LDD	R31,Y+3
    01D92 940E 1D81 CALL	fpcmp
    01D94 91E9      LD	R30,Y+
    01D95 91F9      LD	R31,Y+
    01D96 9622      ADIW	R28,2
    01D97 2300      TST	R16
    01D98 9508      RET
fpcmp2:
    01D99 93FA      ST	-Y,R31
    01D9A 93EA      ST	-Y,R30
    01D9B 2FEC      MOV	R30,R28
    01D9C 2FFD      MOV	R31,R29
    01D9D 9632      ADIW	R30,2
    01D9E 940E 1D81 CALL	fpcmp
    01DA0 91E9      LD	R30,Y+
    01DA1 91F9      LD	R31,Y+
    01DA2 9624      ADIW	R28,4
    01DA3 2300      TST	R16
    01DA4 9508      RET
